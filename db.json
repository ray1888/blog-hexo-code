{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/stun/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/stun/source/images/algolia.svg","path":"images/algolia.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/loading.svg","path":"images/loading.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/js/header.js","path":"js/header.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/scroll.js","path":"js/scroll.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/stun-boot.js","path":"js/stun-boot.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/stun/source/images/icons/favicon-16x16.png","path":"images/icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/stun/source/images/icons/favicon-32x32.png","path":"images/icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/stun/source/images/icons/stun-logo.svg","path":"images/icons/stun-logo.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":1},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":0},{"_id":"source/images/gdut.jpg","path":"images/gdut.jpg","modified":1,"renderable":0},{"_id":"source/images/profile.png","path":"images/profile.png","modified":1,"renderable":0},{"_id":"source/images/programmingebooks.png","path":"images/programmingebooks.png","modified":1,"renderable":0},{"_id":"source/images/sandstone.png","path":"images/sandstone.png","modified":1,"renderable":0},{"_id":"source/images/styleguide.png","path":"images/styleguide.png","modified":1,"renderable":0},{"_id":"source/images/zoom.jpg","path":"images/zoom.jpg","modified":1,"renderable":0},{"_id":"source/images/posts/GoSlice.png","path":"images/posts/GoSlice.png","modified":1,"renderable":0},{"_id":"source/images/posts/GoSliceExtend.png","path":"images/posts/GoSliceExtend.png","modified":1,"renderable":0},{"_id":"source/images/posts/Lab3-Process.png","path":"images/posts/Lab3-Process.png","modified":1,"renderable":0},{"_id":"source/images/posts/LamportTimestamp.png","path":"images/posts/LamportTimestamp.png","modified":1,"renderable":0},{"_id":"source/images/posts/Prometheus.png","path":"images/posts/Prometheus.png","modified":1,"renderable":0},{"_id":"source/images/posts/RaftProcess.png","path":"images/posts/RaftProcess.png","modified":1,"renderable":0},{"_id":"source/images/posts/RaftStateMachine.png","path":"images/posts/RaftStateMachine.png","modified":1,"renderable":0},{"_id":"source/images/posts/deploy-using-github-pages-and-travis.png","path":"images/posts/deploy-using-github-pages-and-travis.png","modified":1,"renderable":0},{"_id":"source/images/posts/devlopr-starter.png","path":"images/posts/devlopr-starter.png","modified":1,"renderable":0},{"_id":"source/images/posts/devlopr.png","path":"images/posts/devlopr.png","modified":1,"renderable":0},{"_id":"source/images/posts/distributed-db.jpg","path":"images/posts/distributed-db.jpg","modified":1,"renderable":0},{"_id":"source/images/posts/distributed-system.png","path":"images/posts/distributed-system.png","modified":1,"renderable":0},{"_id":"source/images/posts/docker.png","path":"images/posts/docker.png","modified":1,"renderable":0},{"_id":"source/images/posts/generate-line.png","path":"images/posts/generate-line.png","modified":1,"renderable":0},{"_id":"source/images/posts/go.png","path":"images/posts/go.png","modified":1,"renderable":0},{"_id":"source/images/posts/hello.jpg","path":"images/posts/hello.jpg","modified":1,"renderable":0},{"_id":"source/images/posts/lab4.png","path":"images/posts/lab4.png","modified":1,"renderable":0},{"_id":"source/images/posts/line-final.png","path":"images/posts/line-final.png","modified":1,"renderable":0},{"_id":"source/images/posts/more-detail-line.png","path":"images/posts/more-detail-line.png","modified":1,"renderable":0},{"_id":"source/images/posts/non-linearized-example.png","path":"images/posts/non-linearized-example.png","modified":1,"renderable":0},{"_id":"source/images/posts/quroum-fail.png","path":"images/posts/quroum-fail.png","modified":1,"renderable":0},{"_id":"source/images/posts/siteleaf.jpg","path":"images/posts/siteleaf.jpg","modified":1,"renderable":0},{"_id":"source/images/posts/sql.jfif","path":"images/posts/sql.jfif","modified":1,"renderable":0},{"_id":"source/images/posts/prometheus/DiscoverManager.png","path":"images/posts/prometheus/DiscoverManager.png","modified":1,"renderable":0},{"_id":"source/images/posts/prometheus/ScrapeModule.png","path":"images/posts/prometheus/ScrapeModule.png","modified":1,"renderable":0},{"_id":"source/images/posts/siteleaf/1.png","path":"images/posts/siteleaf/1.png","modified":1,"renderable":0},{"_id":"source/images/posts/siteleaf/2.png","path":"images/posts/siteleaf/2.png","modified":1,"renderable":0},{"_id":"source/images/posts/siteleaf/3.png","path":"images/posts/siteleaf/3.png","modified":1,"renderable":0},{"_id":"source/images/posts/siteleaf/4.png","path":"images/posts/siteleaf/4.png","modified":1,"renderable":0},{"_id":"source/images/posts/siteleaf/5.png","path":"images/posts/siteleaf/5.png","modified":1,"renderable":0},{"_id":"source/images/posts/siteleaf/6.png","path":"images/posts/siteleaf/6.png","modified":1,"renderable":0},{"_id":"source/images/posts/siteleaf/8.png","path":"images/posts/siteleaf/8.png","modified":1,"renderable":0},{"_id":"source/images/posts/siteleaf/9.png","path":"images/posts/siteleaf/9.png","modified":1,"renderable":0},{"_id":"source/images/posts/sqlJoin/FULL_OUTER_JOIN.png","path":"images/posts/sqlJoin/FULL_OUTER_JOIN.png","modified":1,"renderable":0},{"_id":"source/images/posts/sqlJoin/INNER_JOIN.png","path":"images/posts/sqlJoin/INNER_JOIN.png","modified":1,"renderable":0},{"_id":"source/images/posts/sqlJoin/LEFT_EXCLUDING_JOIN.png","path":"images/posts/sqlJoin/LEFT_EXCLUDING_JOIN.png","modified":1,"renderable":0},{"_id":"source/images/posts/sqlJoin/LEFT_JOIN.png","path":"images/posts/sqlJoin/LEFT_JOIN.png","modified":1,"renderable":0},{"_id":"source/images/posts/sqlJoin/OUTER_EXCLUDING_JOIN.png","path":"images/posts/sqlJoin/OUTER_EXCLUDING_JOIN.png","modified":1,"renderable":0},{"_id":"source/images/posts/sqlJoin/RIGHT_EXCLUDING_JOIN.png","path":"images/posts/sqlJoin/RIGHT_EXCLUDING_JOIN.png","modified":1,"renderable":0},{"_id":"source/images/posts/sqlJoin/RIGHT_JOIN.png","path":"images/posts/sqlJoin/RIGHT_JOIN.png","modified":1,"renderable":0},{"_id":"source/images/posts/sqlJoin/Visual_SQL_JOINS_orig.jpg","path":"images/posts/sqlJoin/Visual_SQL_JOINS_orig.jpg","modified":1,"renderable":0},{"_id":"source/images/posts/sqlPost/Union-1.png","path":"images/posts/sqlPost/Union-1.png","modified":1,"renderable":0},{"_id":"source/images/posts/sqlPost/Union-2.png","path":"images/posts/sqlPost/Union-2.png","modified":1,"renderable":0},{"_id":"source/images/posts/sqlPost/Union-3.png","path":"images/posts/sqlPost/Union-3.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1611195039720},{"_id":"themes/stun/.editorconfig","hash":"1ca001b8a7ed235eb9f5c21360b3a11eedb84ae7","modified":1611195879133},{"_id":"themes/stun/.commitlintrc.js","hash":"af8f006fbdfc6a1880605c7a35e63de300d6929b","modified":1611195879133},{"_id":"themes/stun/.cz-config.js","hash":"fbb89df58c60cf4f3827059d0574accc8407e1bb","modified":1611195879133},{"_id":"themes/stun/.eslintrc","hash":"1ba4f0ddd4bef04884c7fda6ef04f9d9697a62b4","modified":1611195879133},{"_id":"themes/stun/.gitignore","hash":"7745f04d70b1ea58b02d68dde999708836343c7a","modified":1611195879133},{"_id":"themes/stun/.prettierrc","hash":"4b6589404c509f4538daf6f3b8b3ee2ec37d2f4c","modified":1611195879133},{"_id":"themes/stun/CHANGELOG.md","hash":"28a248f28bbe27f6ca9234be2026d74dc7bf4387","modified":1611195879133},{"_id":"themes/stun/FAQ.md","hash":"df56d44b1297fe507d8b4edefb303629f4b23c67","modified":1611195879133},{"_id":"themes/stun/.stylintrc","hash":"3305c42a95c986341d7c7dd03ed9f37a42da343c","modified":1611195879133},{"_id":"themes/stun/LICENSE","hash":"c79ab3fe0ee8f2388376574dfe704b3df0c70a69","modified":1611195879133},{"_id":"themes/stun/README.md","hash":"b77f5b18bfe474178fee322ff6065f960f33c96d","modified":1611195879133},{"_id":"themes/stun/README_en-US.md","hash":"5e7bff4bcd02badcd3207379d353c5d1ea403a4f","modified":1611195879133},{"_id":"themes/stun/package.json","hash":"73b9d4773d487897e7c2bc28409771ff553044b6","modified":1611195879137},{"_id":"themes/stun/.github/FUNDING.yml","hash":"963cf7fb304865af888ad4bbb87a0f5991f3790f","modified":1611195879133},{"_id":"themes/stun/languages/en.yml","hash":"e1348852aa00d2d57f5215c83709f6428f8e8a71","modified":1611195879133},{"_id":"themes/stun/_config.yml","hash":"9862b4d55700dd208dd89f2a064ffbb8a4979a97","modified":1611201629087},{"_id":"themes/stun/languages/es.yml","hash":"e150c8a1f56ae9ed065611951aa124fb548577fc","modified":1611195879133},{"_id":"themes/stun/languages/zh-CN.yml","hash":"ef231652f77466527465788089ff91228d6eff54","modified":1611201565966},{"_id":"themes/stun/languages/zh-HK.yml","hash":"aef25f329cc05dbe8e38753fccd98d63c9fcd174","modified":1611195879133},{"_id":"themes/stun/layout/archive.pug","hash":"d45d078ae4196add83e21fcaed3ef168b237af90","modified":1611195879137},{"_id":"themes/stun/layout/_layout.pug","hash":"5052ee5040ae736d78ad208df7352be69b61b0d1","modified":1611195879133},{"_id":"themes/stun/layout/category.pug","hash":"24153408b2971542d177227f09e93da7754bf75e","modified":1611195879137},{"_id":"themes/stun/layout/index.pug","hash":"df40cf1f051fd29f0f51ace74e9f7394f6ea2ab7","modified":1611195879137},{"_id":"themes/stun/layout/page.pug","hash":"22ba5928bd9ae8c56b3242b7caa5fc3ec471b082","modified":1611195879137},{"_id":"themes/stun/layout/post.pug","hash":"a4d16dbb919df5d4ffdb5a1d0114a4e1c8c21197","modified":1611195879137},{"_id":"themes/stun/layout/tag.pug","hash":"46f956ad7e2aed879999ddf5e768d80c4bbe5b5f","modified":1611195879137},{"_id":"themes/stun/scripts/engine.js","hash":"a63a57c9206a77a79f93dbd86e86204447d7d904","modified":1611195879137},{"_id":"themes/stun/scripts/merge-config.js","hash":"bb914100129c5ca2d1a9e087fffd7bedcb6ae6a6","modified":1611195879137},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/feature-request_en.md","hash":"af7175a0d0f7edfbfbeef3eeb949e20d1e41bf38","modified":1611195879133},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/feature-request_zh.md","hash":"1ecd119a1f4c6fbe3886c885b7d13f1fcc048a5b","modified":1611195879133},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/other_en.md","hash":"6b6afbfc66ee51624f7eeaeb5a1fc959e290e06d","modified":1611195879133},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/other_zh.md","hash":"a9f7abd311731c21082fa5e553251f4704e555c5","modified":1611195879133},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/bug-report_zh.md","hash":"0b42693e9577d3203473caa11ceaa9f64096a67c","modified":1611195879133},{"_id":"themes/stun/.github/workflows/files-shaking.yml","hash":"3593429efe2f5b196a44d185e810b226cef26714","modified":1611195879133},{"_id":"themes/stun/layout/_mixins/gallery.pug","hash":"3054e2c09bc205173c517fb1c36321f7c4c0db63","modified":1611195879133},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/bug-report_en.md","hash":"70022617d944b410a21c28d2abafcfe0b2928f01","modified":1611195879133},{"_id":"themes/stun/layout/_mixins/menu-item.pug","hash":"93c4454e48a6f1456c29aeb9d1332be186b49d4f","modified":1611195879133},{"_id":"themes/stun/layout/_mixins/meta-item.pug","hash":"3d74dc8ba8651efd4a605e56a21e314678d04057","modified":1611195879133},{"_id":"themes/stun/layout/_partials/config.pug","hash":"4fb832652485161148ea957067c06d50ed11578b","modified":1611195879133},{"_id":"themes/stun/layout/_scripts/stun.pug","hash":"961554914427578b57ea3912d751d398f4eb381d","modified":1611195879137},{"_id":"themes/stun/layout/_mixins/timeline.pug","hash":"4e19a670f002d3c6bc740a2d6ef03964e6b59c09","modified":1611195879133},{"_id":"themes/stun/layout/_scripts/vendors.pug","hash":"62a6831d3b1d90d6c8335ce3402efc50e141eafb","modified":1611195879137},{"_id":"themes/stun/.github/workflows/codeql-analysis.yml","hash":"7a9d289addb10720f6b666157efe170d47774906","modified":1611195879133},{"_id":"themes/stun/scripts/filters/external-link.js","hash":"f5369becfd8cc6e43d6dc3595b1edbe014d9aa7c","modified":1611195879137},{"_id":"themes/stun/layout/_mixins/post-header.pug","hash":"9486d07e56acf7bcc5d691bef93c19e2e5c98022","modified":1611195879133},{"_id":"themes/stun/scripts/filters/lazyload.js","hash":"d5baf39faeff5368182be1f59fb598d023985cde","modified":1611195879137},{"_id":"themes/stun/scripts/filters/post-heading.js","hash":"6785e981bfcf87ca587bef36231be430bba2254d","modified":1611195879137},{"_id":"themes/stun/scripts/filters/image-setting.js","hash":"412318b6d189d5355dbcc52c9762072f7ecdaad4","modified":1611195879137},{"_id":"themes/stun/scripts/filters/wrap-table.js","hash":"888c9eaaddcdb9b88d07837a9091aa39ed3fe677","modified":1611195879137},{"_id":"themes/stun/scripts/filters/shake-file.js","hash":"159dff6e4f7020545c9b151108398cd383d613e2","modified":1611195879137},{"_id":"themes/stun/scripts/tags/note.js","hash":"b436593a56e3bab8dd59c71e73ac9efbc8fa29d4","modified":1611195879137},{"_id":"themes/stun/scripts/tags/table.js","hash":"177061e1bfb296981a101643f51a27ccc1469307","modified":1611195879137},{"_id":"themes/stun/source/css/index.styl","hash":"8a75ec81fb064b0da2f978a064cc5bec2395f27d","modified":1611195879141},{"_id":"themes/stun/scripts/tags/friends.js","hash":"c2fe1e8e128f464d772bcb7534efef54ad224310","modified":1611195879137},{"_id":"themes/stun/source/images/algolia.svg","hash":"90322f80db6ad0daf26ea3ec71dea6f691a8b2f1","modified":1611195879141},{"_id":"themes/stun/source/images/cc-by-nc-nd.svg","hash":"017ad912874686a982ebceae359299b8f2a492e2","modified":1611195879141},{"_id":"themes/stun/source/images/cc-by-nc.svg","hash":"4608189edbe7636dd651df65473298a3c5afb20d","modified":1611195879141},{"_id":"themes/stun/source/images/cc-by-nc-sa.svg","hash":"71d035c34219f924dbf1bf852166ee8fb58d2f24","modified":1611195879141},{"_id":"themes/stun/layout/_third-party/quicklink.pug","hash":"2bed65ed4d314dc587e2359e20ae099b46181ed5","modified":1611195879137},{"_id":"themes/stun/source/images/cc-by-nd.svg","hash":"20c66ae3c393903e6eab3bc8cf7c3be6d753f9f8","modified":1611195879141},{"_id":"themes/stun/source/images/cc-by.svg","hash":"77f74c241902447424207869c74cb9d9264bdced","modified":1611195879141},{"_id":"themes/stun/source/images/cc-by-sa.svg","hash":"0455a8857ba096925d4145a56e8d10537fccb378","modified":1611195879141},{"_id":"themes/stun/source/images/loading.svg","hash":"32a6e770d217ae6c0cf0f6beef3172f1b5b9a0a2","modified":1611195879141},{"_id":"themes/stun/source/js/scroll.js","hash":"8926ab87181a49c730ce5132518b608c54b8cdb1","modified":1611195879141},{"_id":"themes/stun/source/js/stun-boot.js","hash":"8358ac0d879c0ca340c52e4de606523c2a91e156","modified":1611195879141},{"_id":"themes/stun/source/js/sidebar.js","hash":"20adff7f54bcd8299d32690d41ebc7a4eb7a8728","modified":1611195879141},{"_id":"themes/stun/layout/_partials/analytics/busuanzi.pug","hash":"80d2f4f8706a96b367ac1e89f5b56ada4684d571","modified":1611195879133},{"_id":"themes/stun/source/js/header.js","hash":"63d407ee6f80114e220171ba829b79b28d420fe0","modified":1611195879141},{"_id":"themes/stun/layout/_partials/head/kill-old-ie.pug","hash":"427a95d02844f29e63c5e9f014ede3609aec1a5b","modified":1611195879133},{"_id":"themes/stun/layout/_partials/footer/footer.pug","hash":"9a8e56bcc504f251c13ee3d0d18a08142fb7ee43","modified":1611195879133},{"_id":"themes/stun/layout/_partials/post/post-list.pug","hash":"c049078009aa251fc76cd948837c7a5efdd39cb2","modified":1611195879133},{"_id":"themes/stun/layout/_partials/search/algolia.pug","hash":"61181bece0e27929fe00df5204fefd8dee31a354","modified":1611195879133},{"_id":"themes/stun/layout/_partials/search/assist-btns.pug","hash":"7e6dc0d975ccbe291116487b15277d27a391fb9a","modified":1611195879133},{"_id":"themes/stun/layout/_partials/header/header.pug","hash":"7ecbe18da15d3a52c56f69c542540291b6178763","modified":1611195879133},{"_id":"themes/stun/layout/_partials/search/index.pug","hash":"0f84aa013a96e7eb3bb25b87f20bab9b7ac55538","modified":1611195879133},{"_id":"themes/stun/layout/_partials/head/head.pug","hash":"c7909a6a50c7a76a6c1810b700a5d72bcb1e20c9","modified":1611195879133},{"_id":"themes/stun/layout/_partials/search/localsearch.pug","hash":"4d8e0bc33f92a603e0b2a5f4296af6bcc7cc31b8","modified":1611195879133},{"_id":"themes/stun/layout/_partials/sidebar/sidebar.pug","hash":"18173a2acf99db39748c392f2e669acd805b4090","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/back2top.pug","hash":"48b7fedeb472bd01fd1f3317359a10e83ca919e1","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/loading-bar.pug","hash":"6cda7866f9589c9ffc05ce4a3d7c33b706e70324","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/copyright.pug","hash":"0938c885697f6eb388b28ddbf88f5631d024fe73","modified":1611195879133},{"_id":"themes/stun/source/js/utils.js","hash":"b570eafe77e47d7701348f172a4dbaaba6fa8123","modified":1611195879141},{"_id":"themes/stun/layout/_partials/widgets/comments.pug","hash":"af1b16be74c7e1242e0f57986672dc73e93546e2","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/night-mode.pug","hash":"c7f9bd67cd231b9bd40a84123644e009ac8d8ef3","modified":1611195879133},{"_id":"themes/stun/layout/_third-party/pjax.pug","hash":"4a786459a8e6a4f378a9d834502f8b11aa66f185","modified":1611195879137},{"_id":"themes/stun/layout/_partials/widgets/share.pug","hash":"1bb3d25298b7ee6a28150aa286ed6b0ae42ead4f","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/reward.pug","hash":"c9081c1dcf0ca18df06d23638654d8f43b28d55c","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/sticky-top.pug","hash":"bf86b2f9f4b1471afb8b31965d3230f6088682ae","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/paginator.pug","hash":"b0045dcb9b151ee31f1db5b7d741f10ef3b74be0","modified":1611195879133},{"_id":"themes/stun/layout/_third-party/advertising/google-adsense.pug","hash":"e489020f1130976d3ec2245915ede6319d89b89c","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/advertising/index.pug","hash":"1285cd65a873f688ae3c51846c1284447f502adc","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/analytics/baidu-analytics.pug","hash":"f7300991a29dbe2e8091a588dfa8c65c3dee6302","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/analytics/busuanzi.pug","hash":"78a4fc9c9380e31536f5b500638f2d005accd361","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/analytics/index.pug","hash":"0d72f844bf9532b3be644c27b0af7cb4331fc46c","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/analytics/google-analytics.pug","hash":"4eef66fbb8a8ad55e0868cf4b77a6b7bca0e7f35","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/analytics/tencent-analytics.pug","hash":"f88fb0f085812db6023c30308ba3458da7742993","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/disqus.pug","hash":"57bcbaac3d237d9168dd8f4b682f34351f11d250","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/fbcomments.pug","hash":"fb651812c87dc5e2134d7fb7d8f98d4d4227f1f6","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/gitalk.pug","hash":"c2a90e80c51b5b99e6804dbed5457a071b980bbd","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/index.pug","hash":"bec4d9c8ea360637e7da3314fa987e33facd8071","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/livere.pug","hash":"687f74a998519608944b40a41f3a98ccf4535139","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/minivaline.pug","hash":"5584ade7dd19deca418373115bde9d563d37d826","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/utterances.pug","hash":"6418baeb3aedcddb02a64bd89b26ac12e18551c8","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/math/katex.pug","hash":"345c59fe76a7c83b529328e5144d1036cb14f533","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/valine.pug","hash":"b519a6948d6ef37c037385e3e3f9590c17f7ad62","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/waline.pug","hash":"fd4c958b13777752f176556c7b109b7dede7cc68","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/math/index.pug","hash":"e952be6c736545e73c0e02f833f87a4f8c5a2582","modified":1611195879137},{"_id":"themes/stun/source/css/_common/index.styl","hash":"86057db6cb18263866d62a6669feee8752882398","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/math/mathjax.pug","hash":"72d51538cc85f01c8c64db74b9219ccaf334c9e9","modified":1611195879137},{"_id":"themes/stun/source/css/_common/responsive.styl","hash":"618c6005f1bc7c482fa37ae3ce15729a64044d9d","modified":1611195879137},{"_id":"themes/stun/source/css/_custom/index.styl","hash":"0d1adc70250941074c742f94f7801b3b43a7f1db","modified":1611195879137},{"_id":"themes/stun/source/css/_mixins/index.styl","hash":"f3060519f3acd05cb4b26bb5f6a5c6b857cb0d68","modified":1611195879137},{"_id":"themes/stun/source/css/_variables/index.styl","hash":"c81aac4285eb058026b255e31282d35f55a820ab","modified":1611195879141},{"_id":"themes/stun/source/images/icons/favicon-16x16.png","hash":"7bfd64eac26e17ea162f0c399a4a40164c26b412","modified":1611195879141},{"_id":"themes/stun/source/images/icons/favicon-32x32.png","hash":"02fead07726920400ede57ddfdbf071dd7203fd5","modified":1611195879141},{"_id":"themes/stun/source/images/icons/stun-logo.svg","hash":"069dc7590ad152373f1c346d892e32faa2bbdd87","modified":1611195879141},{"_id":"themes/stun/source/css/_common/components/index.styl","hash":"a54720db94121efd1a34ac88d344197c8206837e","modified":1611195879137},{"_id":"themes/stun/source/css/_common/outline/index.styl","hash":"467d4171c0690a95d40fbecea02e6b212b7c74f1","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/search/localsearch.pug","hash":"d98db7ed7e3e4c574212fa9d75adba681f3d0687","modified":1611195879137},{"_id":"themes/stun/source/css/_common/outline/macro.styl","hash":"13b96f239de15e1cfdc14d9c80e6959506556dd2","modified":1611195879137},{"_id":"themes/stun/source/css/_common/scaffolding/base.styl","hash":"4064a7e2c3f71d2ed72a47edd60e9be01af6c354","modified":1611195879137},{"_id":"themes/stun/source/css/_common/scaffolding/index.styl","hash":"e750f2dae9eb3385039ee018ff8001b0e6ec3b64","modified":1611195879137},{"_id":"themes/stun/source/css/_common/scaffolding/normalize.styl","hash":"c15a9616fddb267431416304d709185aeb3d45f5","modified":1611195879137},{"_id":"themes/stun/source/css/_common/scaffolding/utils.styl","hash":"7e62f34521ea539a25a101f25e1684e3a3ac4be8","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/analytics/busuanzi.styl","hash":"d196c88ea2e9b851e8d8f9c5a315dfc2929eb897","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/analytics/index.styl","hash":"339a43fd5ee97a77775b723118f6ab1af754fed4","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/footer/index.styl","hash":"14464841145cf3ecab66f1094653daa033c261eb","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/header/index.styl","hash":"904af0e73cdf0767ec781271856d7b5b63e043ef","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/highlight/diff.styl","hash":"056e70f6dfe45ec50427d7ab293d33361c9b956f","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/highlight/highlight.styl","hash":"bc0b01021a0d19b2c98f0c5c9fa1af96d67c1099","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/highlight/index.styl","hash":"85848179cbc78152d2521b601ac9f888dea4e255","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/highlight/theme.styl","hash":"dfc99b05302f8203040431e563c9f63d63da46de","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/pages/index.styl","hash":"463a4e6a92ec5f757e167fbeb171e4e92e83a822","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/search/algolia.pug","hash":"54233748e22ceae063f70ee49b44c4bd0a78f391","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/search/index.pug","hash":"0f84aa013a96e7eb3bb25b87f20bab9b7ac55538","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/pages/timeline.styl","hash":"21e9c8def1613030f0927e2ce80f4ecc721f078e","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/pages/page.styl","hash":"df732e267dfd9f1bda6a8cf1ede3198a205925f9","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/plugins/friends.styl","hash":"bdb015173f8e5fa391fc4fb2b2a8d42787022c4b","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/plugins/index.styl","hash":"c35d0cf421c6669ee0458c2f0264dca05769c01d","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/plugins/note.styl","hash":"ae0ad9b44a87839d220792336478a9ae6db11c47","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/plugins/table.styl","hash":"98cacc91e42f5e45279e2174a90ab26171085e2f","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/post/index.styl","hash":"08aad11e329cda0550efef226e0c4d0bb4540454","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/post/post-list.styl","hash":"d0ed844e28533f832cbd9b3f09203d16936628f7","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/post/post.styl","hash":"8b7b22225b40d028efee689d3700a9796291cb8d","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/search/algolia.styl","hash":"fb62e4baf25a66e46c27783be5d79353ec394b44","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/search/common.styl","hash":"1939b7dfbcf557794a188fbf8fec4ef2b5afa437","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/search/index.styl","hash":"1990d2c2a9bfe8e09d656f0c2ae6cf0c9f7f5542","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/search/localsearch.styl","hash":"bf1ac1b8ee8c4daaa7e6b47eec097a176624e6d0","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/copy-button.styl","hash":"378961fa7c986e3313053814806902bf76204a93","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/back2top.styl","hash":"b3da5ea71a9947e781056d1bd7d42e4045fa2aca","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/sidebar/index.styl","hash":"02138647437f7e8ee8927cae225d41072d936bdc","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/comments.styl","hash":"41d229ac4fa02a3a8b46687ccbafa7a608008e2f","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/copyright.styl","hash":"1d28fc8f76f7164a306ed81a9ede21c0a2b0f7cd","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/ending.styl","hash":"63985ca9a3f6c481cc60207966fa1267de14d945","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/fancybox.styl","hash":"3d677c0323d77199bb9fbfefd65e97d8b882d7b3","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/font-icon.styl","hash":"bdda0953611378e93a8d6387cbdc93e1de4f7f0a","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/gallery-image.styl","hash":"99b1cc42f38816083f93233778b299422b6d8f32","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/index.styl","hash":"03ffdc55fd5fb64c3158bc222d0e8e9d7844686b","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/lazyload.styl","hash":"eced96235f0ff5dc6a8fd068d4ed05934a29b430","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/loading-bar.styl","hash":"9f23e8762d01fb4a3cbf5e786fdead2926849e8a","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/night-mode.styl","hash":"9caeef13a913aba38976f082e1f0ca191bffc64e","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/paginator.styl","hash":"71ddb6a1e9664a4fde04a0ce143b8786ba6e0089","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/reward.styl","hash":"de1130ec3765879884cbdc77a15b458da6e37bcc","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/share.styl","hash":"fe32e3434107d92cefd7aacfdcef526a93c4b865","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/sticky-top.styl","hash":"f0e37944168a74a64b18dc54c6fde2308e4bf023","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/zoom-image.styl","hash":"40f832a199320642debabe32910c1168e3c6e40c","modified":1611195879137},{"_id":"themes/stun/package-lock.json","hash":"1da56d61e769a1f6d47444631d3ff29aecbf569b","modified":1611195879137},{"_id":"source/categories/index.md","hash":"ccd50c0021343ed02de529105275dad022f9f8d0","modified":1611200958283},{"_id":"source/tags/index.md","hash":"d7b0d8c4c7bb7ce8c8298fcba3cf2ae22f168066","modified":1611197601625},{"_id":"source/pics/background.jpg","hash":"d6e5f05e371fbd474d6d2183485c556c2aa52842","modified":1611197848489},{"_id":"themes/stun/source/images/background.jpg","hash":"d6e5f05e371fbd474d6d2183485c556c2aa52842","modified":1611197848489},{"_id":"public/categories/index.html","hash":"a1c7bc94e425f41d136ba9bcbf1ab1e858c6baa2","modified":1611200509055},{"_id":"public/tags/index.html","hash":"c4f9071dba02fee1923dbd9b4ea758377a7f1475","modified":1611200509055},{"_id":"public/2021/01/21/hello-world/index.html","hash":"8c74a26033fefb9797f280527f9fee6eed70478e","modified":1611200509055},{"_id":"public/archives/index.html","hash":"07fad6332542789a48d4e9b0051a1f4f61e91349","modified":1611200509055},{"_id":"public/archives/2021/index.html","hash":"464b3d51a5aec9707ca583932466345897ed7e25","modified":1611200509055},{"_id":"public/archives/2021/01/index.html","hash":"838f417e0de41d07e1df50c51ed1d338306f762c","modified":1611200509055},{"_id":"public/index.html","hash":"f057d1d93906f928792344d07554bc167fca6f16","modified":1611200509055},{"_id":"public/images/algolia.svg","hash":"90322f80db6ad0daf26ea3ec71dea6f691a8b2f1","modified":1611200509055},{"_id":"public/images/cc-by-nc-nd.svg","hash":"017ad912874686a982ebceae359299b8f2a492e2","modified":1611200509055},{"_id":"public/images/cc-by-nc-sa.svg","hash":"71d035c34219f924dbf1bf852166ee8fb58d2f24","modified":1611200509055},{"_id":"public/images/cc-by-nc.svg","hash":"4608189edbe7636dd651df65473298a3c5afb20d","modified":1611200509055},{"_id":"public/images/cc-by-nd.svg","hash":"20c66ae3c393903e6eab3bc8cf7c3be6d753f9f8","modified":1611200509055},{"_id":"public/images/cc-by-sa.svg","hash":"0455a8857ba096925d4145a56e8d10537fccb378","modified":1611200509055},{"_id":"public/images/cc-by.svg","hash":"77f74c241902447424207869c74cb9d9264bdced","modified":1611200509055},{"_id":"public/images/loading.svg","hash":"32a6e770d217ae6c0cf0f6beef3172f1b5b9a0a2","modified":1611200509055},{"_id":"public/images/icons/favicon-16x16.png","hash":"7bfd64eac26e17ea162f0c399a4a40164c26b412","modified":1611200509055},{"_id":"public/images/icons/favicon-32x32.png","hash":"02fead07726920400ede57ddfdbf071dd7203fd5","modified":1611200509055},{"_id":"public/images/icons/stun-logo.svg","hash":"069dc7590ad152373f1c346d892e32faa2bbdd87","modified":1611200509055},{"_id":"public/js/header.js","hash":"63d407ee6f80114e220171ba829b79b28d420fe0","modified":1611200509055},{"_id":"public/js/scroll.js","hash":"8926ab87181a49c730ce5132518b608c54b8cdb1","modified":1611200509055},{"_id":"public/js/sidebar.js","hash":"20adff7f54bcd8299d32690d41ebc7a4eb7a8728","modified":1611200509055},{"_id":"public/js/stun-boot.js","hash":"8358ac0d879c0ca340c52e4de606523c2a91e156","modified":1611200509055},{"_id":"public/css/index.css","hash":"4e00e962943eb85f788cd779eb26ea96813132fb","modified":1611200509055},{"_id":"public/js/utils.js","hash":"b570eafe77e47d7701348f172a4dbaaba6fa8123","modified":1611200509055},{"_id":"public/images/background.jpg","hash":"d6e5f05e371fbd474d6d2183485c556c2aa52842","modified":1611200509055},{"_id":"source/images/favicon.ico","hash":"bc2865e9aa14213954a065a601068fca82e30e48","modified":1611209774298},{"_id":"source/_posts/raft-lab-2.md","hash":"806a723c32b2cc248ecfff89b9d9886b62196bd9","modified":1611209718979},{"_id":"source/images/gdut.jpg","hash":"2a1b444969cd4ea3542c7765667691ede8cb89d4","modified":1611209774446},{"_id":"source/_posts/intro-distributed-system.md","hash":"76988bdc537c32855b9245f6d4172edad52496b4","modified":1611210377766},{"_id":"source/images/profile.png","hash":"24ca9409baced46858ea8a6ace5e4df1e56fab50","modified":1611209774562},{"_id":"source/images/sandstone.png","hash":"d9376295a520b26f3fffcad510d712fb55b4c0aa","modified":1611209774849},{"_id":"source/_posts/intro-distributed-system/SchdulerTimeJump.png","hash":"96bf07ff85553f0488994840d42abeee01b60ff7","modified":1611210290568},{"_id":"source/_posts/intro-distributed-system/TimeJump.png","hash":"06b9f53d7f1de9513ebc82f966da61f8c3245945","modified":1611210159454},{"_id":"source/images/posts/GoSlice.png","hash":"4479fa57bd48c6b5416534c3fd47c70ab1f5cdf0","modified":1611209764955},{"_id":"source/images/posts/Lab3-Process.png","hash":"ae7f4c8dfb423391ad0a308c67f7c53200cc55b1","modified":1611209764955},{"_id":"source/images/posts/GoSliceExtend.png","hash":"775b4081f260a70834ec1a3dfe95df1b3836c8ee","modified":1611209764955},{"_id":"source/images/posts/Prometheus.png","hash":"0506d03706999d9ef6aa1eac1cd6aa38e64481d2","modified":1611209764955},{"_id":"source/images/posts/RaftStateMachine.png","hash":"70b9c110053df72419c3b49b9af9dd0756a6746e","modified":1611209764959},{"_id":"source/images/posts/distributed-system.png","hash":"a8d43e346d395b6b3c821397b243b02269b5465b","modified":1611209764959},{"_id":"source/images/posts/docker.png","hash":"fa387d66e00872926990aeee452d8f4ed27dabf1","modified":1611209764959},{"_id":"source/images/posts/distributed-db.jpg","hash":"d12869dd81ffa87b28edf9ea658adda8c683925a","modified":1611209764959},{"_id":"source/images/posts/lab4.png","hash":"cd009a7990265f919125c0215a60c2c15da1ec88","modified":1611209764959},{"_id":"source/images/posts/go.png","hash":"700cd88adaaa4c83be5580dad2edea8a64779551","modified":1611209764959},{"_id":"source/images/posts/more-detail-line.png","hash":"72f5da21dcf6e130fcf2244d3e19a756f82accb7","modified":1611209764963},{"_id":"source/images/posts/sql.jfif","hash":"2af4d52a366d09c72de7edd73bb0943d26697bde","modified":1611209764963},{"_id":"source/images/posts/prometheus/ScrapeModule.png","hash":"2f5e7b38d366dd450f7c722887f3d7ed2d592bc3","modified":1611209764963},{"_id":"source/images/posts/prometheus/DiscoverManager.png","hash":"a373230ea1eff40b760eefd994f389ed079f5924","modified":1611209764963},{"_id":"source/images/posts/siteleaf/4.png","hash":"aee718d91c1957564223454555708230e193dfd8","modified":1611209764963},{"_id":"source/images/posts/siteleaf/1.png","hash":"2914adca89d0679239e50045f69176b4ed71d75a","modified":1611209764963},{"_id":"source/images/posts/siteleaf/2.png","hash":"705e3e4bfc44a38fcc1e86e3ae02e59d73855c84","modified":1611209764963},{"_id":"source/images/posts/siteleaf/3.png","hash":"ba54eaeab0f941bde9017e742fc434469aa0d22a","modified":1611209764963},{"_id":"source/images/posts/sqlJoin/FULL_OUTER_JOIN.png","hash":"328ffe185f047de564ee058df5782e0ac4d7e288","modified":1611209764963},{"_id":"source/images/posts/sqlJoin/INNER_JOIN.png","hash":"4855ad7e617ff7bd5d50661933f11397e98ead33","modified":1611209764963},{"_id":"source/images/posts/sqlJoin/LEFT_EXCLUDING_JOIN.png","hash":"d8fbfb2ff1f3f7edcf7eb151d004063b64672593","modified":1611209764967},{"_id":"source/images/posts/siteleaf/5.png","hash":"cce46cc1dc0036a3b8b676c690a9a47d1482f5c1","modified":1611209764963},{"_id":"source/images/posts/sqlJoin/LEFT_JOIN.png","hash":"6bebcdbb03998cee42b0eb8796366324937899c1","modified":1611209764967},{"_id":"source/images/posts/sqlJoin/OUTER_EXCLUDING_JOIN.png","hash":"80bfd5ad46985693297d43a9c199a8fa7149caa9","modified":1611209764967},{"_id":"source/images/posts/sqlJoin/RIGHT_EXCLUDING_JOIN.png","hash":"d25f73221c620d82f62519dacd7b826d7fa6ec7b","modified":1611209764967},{"_id":"source/images/posts/siteleaf/8.png","hash":"82ec6fb7698807e6a156c6c9b64c391bc7dbecc4","modified":1611209764963},{"_id":"source/images/posts/sqlJoin/RIGHT_JOIN.png","hash":"9508b89fabef50db34cd895df23e8dfca1f32e55","modified":1611209764967},{"_id":"source/images/posts/sqlPost/Union-1.png","hash":"a0b8d009947052d2860a5bfe38bea6ce2ddd319b","modified":1611209764967},{"_id":"source/images/posts/sqlPost/Union-2.png","hash":"f789f29d1f6499fdab82e0337f5c65827353d781","modified":1611209764967},{"_id":"source/images/posts/sqlPost/Union-3.png","hash":"b92a5c84b769dca861306b8533b90a220e3fec3e","modified":1611209764967},{"_id":"source/_posts/distribute-system-consensus.md","hash":"f0f0694f37f68c136f54a09ddee1960f19830c86","modified":1611209620869},{"_id":"source/_posts/intro-distributed-system/lockingproblem.png","hash":"fbb0f4ff829fbf4e7efd142690838d7c0ebeea5b","modified":1611210326067},{"_id":"source/images/posts/RaftProcess.png","hash":"e0ba0d2b3bb78cb49e1a925c6f6d39810c6919a4","modified":1611209764955},{"_id":"source/images/posts/deploy-using-github-pages-and-travis.png","hash":"55cb8ef319aa7efa31bf54faab1f7018099fe8be","modified":1611209764959},{"_id":"source/images/posts/devlopr-starter.png","hash":"a111df6ea8403c12b4855d0f105d93b43897084f","modified":1611209764959},{"_id":"source/images/posts/generate-line.png","hash":"af91ca7e6f039d4f2275074b90b2a03a75ff8de3","modified":1611209764959},{"_id":"source/images/posts/hello.jpg","hash":"a704aa62155f81ea564f25b7c936bab812a96bdf","modified":1611209764959},{"_id":"source/images/posts/siteleaf.jpg","hash":"03af20db7719e4f3349754a87ae14e65bcfdb61b","modified":1611209764963},{"_id":"source/images/posts/siteleaf/9.png","hash":"75846cd0289eb17778e9abea0b2a9cd580296738","modified":1611209764963},{"_id":"source/images/posts/siteleaf/6.png","hash":"fa55614cca7f2977f82a90b069afa4e17b4ede5d","modified":1611209764963},{"_id":"source/_posts/intro-distributed-system/Time&EventMissmatch.png","hash":"3c475b8773138ddc1860c09f4dab36da63a600a9","modified":1611210249156},{"_id":"source/_posts/intro-distributed-system/lockingproblem2.png","hash":"1e26a196fc0d38387a04bfca2f72e232494ba5df","modified":1611210326270},{"_id":"source/images/posts/LamportTimestamp.png","hash":"cd9167f36d443923340bc6696f2b2e9451845f54","modified":1611209764955},{"_id":"source/images/posts/sqlJoin/Visual_SQL_JOINS_orig.jpg","hash":"680a869474697bae045105b4ea3fb7db14cbdce9","modified":1611209764967},{"_id":"source/images/zoom.jpg","hash":"9990a9c0a92cc394e8ca19b12f57bfbaf3be875b","modified":1611209775084},{"_id":"source/images/posts/devlopr.png","hash":"a97e9f2070caed1fde9c0f3918f6e475bfa75252","modified":1611209764959},{"_id":"source/images/posts/line-final.png","hash":"b9d5a320acd4afd4bde5ff371d39083ec1d42e27","modified":1611209764959},{"_id":"source/images/posts/quroum-fail.png","hash":"a232d6ebba1f33265a1032cb348637d664f34e2f","modified":1611209764963},{"_id":"source/images/styleguide.png","hash":"c1a26070904f41146df18ce223ecc3f3df4a12d6","modified":1611209774970},{"_id":"source/images/posts/non-linearized-example.png","hash":"aa4ad4b7808ba88b228868f8c193cad6c965048d","modified":1611209764963},{"_id":"source/images/programmingebooks.png","hash":"7037191f871a1b8660268927c5beb259274e57ce","modified":1611209774727}],"Category":[],"Data":[],"Page":[{"type":"categories","_content":"Golang  \nBackendDevelop\nDevops\nMonitorSystem\n","source":"categories/index.md","raw":"---\ntype: \"categories\"\n---\nGolang  \nBackendDevelop\nDevops\nMonitorSystem\n","date":"2021-01-21T03:49:18.287Z","updated":"2021-01-21T03:49:18.283Z","path":"categories/index.html","_id":"ckk68q9f90000lpi53xl4h3wk","title":"","comments":1,"layout":"page","content":"<p>Golang<br>BackendDevelop<br>Devops<br>MonitorSystem</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Golang<br>BackendDevelop<br>Devops<br>MonitorSystem</p>\n"},{"type":"tags","_content":"","source":"tags/index.md","raw":"---\ntype: \"tags\"\n---\n","date":"2021-01-21T02:53:21.625Z","updated":"2021-01-21T02:53:21.625Z","path":"tags/index.html","_id":"ckk69ad5n0000w1i5dc7d9par","title":"","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"MIT6.824 Lab2 实现及解析","date":"2019-08-20T04:05:38.000Z","_content":"\n<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab2 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n# 目录\n1. [Raft论文阅读](#PaperReading)  \n2. [实现细节](#Detail)    \n        2.1 [Raft整体流程](#2.1)    \n        2.2 [Raft状态机维护](#2.2)  \n        2.3 [Raft代码实现](#2.3)  \n\n# <a id=\"PaperReading\"><span class=\"toptitle\">论文阅读及问题</span></a>\n\n论文各个章节主要解析\n1. 总体介绍，解析创造Raft的原因，并且简单描述Raft与Paxos的不同点\n2. 简单介绍一下副本状态机这个概念\n3. 简单描述Paxos的问题（包括了不好理解以及工业化上面的问题）\n4. 阐述Raft为什么比Paxos好理解\n5. Raft的算法的详细描述以及边界条件\n6. Raft集群出现成员变动的时候如何处理\n7. Raft的日志压缩和快照\n8. Client与Raft集群的交互方式\n\n实现的时候，重点要看Figure2中所提及的条件。\n\n# <a id=\"Detail\"><span class=\"toptitle\">代码实现</span></a>\n## <a id=\"2.1\"><span class=\"secondtitle\"> Raft整体流程</span></a>\n\n![Raft整体流程](/assets/img/posts/RaftProcess.png)\n\n此处只是一个比较简单的忽略具体可能出现错误细节的描述。\n本质上Raft就是一个通过一个维护一个协程里面的状态机，并且通过其他做网络请求的协程达成大部分节点在共识的算法。\n具体可以看这里的![演示动画](https://raft.github.io/)\n\n## <a id=\"2.2\"><span class=\"secondtitle\"> Raft状态机的转换</span></a>\n![Raft整体流程](/assets/img/posts/RaftStateMachine.png)\n\n此处是一个简单状态机的描述，具体转换的原因也已经在图上面有标出来。\n\n\n\n## <a id=\"2.3\"><span class=\"secondtitle\"> Raft代码的实现</span></a>\n代码实现在这个Lab中实际上分为了3part\n1. PartA  完成选举\n2. PartB  完成日志\n3. PartC  完成持久化的工作，并且处理共识的边界条件\n\n\n### PartA 的实现 \n跟随论文中提及的RequestVote RPC 以及 AppendEntries RPC 实现即可\n此处可以只需要完成心跳发送后可以保证非主节点不超时，不会使得Term有变动即可。\n\n一个注意的点，发送这两个RPC的时候，都是需要并行发送的，因此每个请求需要使用一个GoRoutine去进行实现。\n下面代码就是发送AppendEntries的代码的实例\n```\n    logs := make([]Log, 0)\n    tmpIndex := min(max(0, rf.nextIndex[number]-1), rf.logs[rf.getLen()].Index)\n    if tmpIndex < rf.logs[rf.getLen()].Index {\n        logs = rf.logs[tmpIndex+1-firstIndex:]\n        //DPrintf(\"server %d is Leader, tmpIndex is %d, firstIndex is %d, len of log is %d, commited index is %d\",\n        //\trf.me, tmpIndex, firstIndex, len(rf.logs), rf.commitedIndex)\n    }\n    args := AppendEntriesArgs{Term: rf.currentTerm, LeaderId: rf.me,\n        PrevLogTerm: rf.logs[tmpIndex-firstIndex].Term, PrevLogIndex: tmpIndex,\n        Entries: logs, Leadercommited: rf.commitedIndex}\n    //  使用Goroutine来发送请求\n    go func(args AppendEntriesArgs, number int) {\n        reply := AppendEntriesReply{}\n        ok := rf.sendAppendEntires(number, &args, &reply)\n        rf.mu.Lock()\n        defer rf.mu.Unlock()\n        if !ok {\n            DPrintf(\"allAppendEntries server %d call remote %d rpc AppendEntries failed\", rf.me, number)\n        }\n        if args.Term != rf.currentTerm {\n            return\n        }\n        if reply.Term > rf.currentTerm {\n            //rf.mu.Lock()\n            rf.state = Follower\n            rf.currentTerm = reply.Term\n            // TODO why Term voliate needed to persist?\n            rf.persist()\n            //rf.mu.Unlock()\n            return\n        }\n        if reply.Success == true && rf.state == Leader {\n            if len(args.Entries) > 0 {\n                rf.nextIndex[number] = args.Entries[len(args.Entries)-1].Index + 1\n                rf.matchIndex[number] = rf.nextIndex[number] - 1\n                if rf.matchIndex[number] > rf.commitedIndex {\n                    rf.updateCommit()\n                }\n            }\n        } else if rf.state == Leader {\n            if rf.nextIndex[number] > reply.PrevIndex+1 {\n                rf.nextIndex[number] = reply.PrevIndex + 1\n            } else {\n                rf.nextIndex[number] = max(rf.nextIndex[number]-1, 1)\n            }\n        }\n    }(args, number)\n```\n并且注意实现的时候的锁的使用，保证每次使用锁都有加锁和解锁的操作成对出现，否则可能会出现一些比较奇怪的情况。\n\n\n### PartB的实现\n此处需要接受模拟从客户端的请求进来然后把Log先放到本地的Log上面，然后把Log同步到其他的节点上面去进行共识的达成。\n\n首先的条件，需要确保Start函数接受请求的时候必须是Leader的角色，否则不会接收请求。（论文中有提及，此处Raft集群中非Leader节点不会把日志写入的请求转发到Leader节点上，这个是为了维护的方便来做的）\n```\nfunc (rf *Raft) Start(command interface{}) (int, int, bool) {\n\tindex := -1\n\tterm := -1\n\tisLeader := true\n\t// Wanring: do not double add lock for GetState function\n\trf.mu.Lock()\n\tdefer rf.mu.Unlock()\n\tterm, isLeader = rf.GetState()\n\tif isLeader {\n\t\tindex = rf.logs[rf.getLen()].Index + 1\n\t\t//oldLogLen := len(rf.logs)\n\t\trf.logs = append(rf.logs, Log{command, term, index})\n\t\t//DPrintf(\"server %d is Leader. new log has been appended, old length is %d, now is %d.  index number is %d, commitedindex is %d\",\n\t\t//\trf.me, oldLogLen, len(rf.logs), index, rf.commitedIndex)\n\t\tif len(rf.chanNewLog) == 0 {\n\t\t\trf.chanNewLog <- 1\n\t\t}\n\t\trf.persist()\n\t}\n\treturn index, term, isLeader\n}\n```\n重点处理的地方是nextIndex和MatchIndex 的计算以及维护的问题\n#### Apply的实现\n因为对于外部客户端的行为来说，Start函数是一个异步的函数, 所以实际上客户端是通过等待Make函数中输入的ApplyCh来确定能够apply成功，保证对外的原子性\n```\nfunc (rf *Raft) doApply() {\n\tfor {\n\t\trf.mu.Lock()\n\t\tst := rf.state\n\t\trf.mu.Unlock()\n\t\tif st == Killed {\n\t\t\treturn\n\t\t}\n\t\tselect {\n\t\tcase <-rf.chanCommit:\n\t\t\tfor {\n\t\t\t\trf.mu.Lock()\n\t\t\t\tif !(rf.lastApplied < rf.commitedIndex && rf.lastApplied < rf.logs[rf.getLen()].Index) {\n\t\t\t\t\trf.mu.Unlock()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tFirstIndex := rf.logs[0].Index\n\t\t\t\tif rf.lastApplied+1 >= FirstIndex {\n\t\t\t\t\tindex := min(rf.lastApplied+1-FirstIndex, rf.getLen())\n\t\t\t\t\tmsg := ApplyMsg{CommandValid: true, Command: rf.logs[index].Command, CommandIndex: rf.lastApplied + 1}\n\t\t\t\t\trf.lastApplied++\n\t\t\t\t\trf.mu.Unlock()\n\t\t\t\t\t//can't lock when send in channel, dead lock\n\t\t\t\t\t// canApplychan is to block the new\n\t\t\t\t\trf.chanCanApply <- 1\n\t\t\t\t\trf.chanApplyMsg <- msg\n\t\t\t\t\t<-rf.chanCanApply\n\t\t\t\t\trf.mu.Lock()\n\t\t\t\t}\n\t\t\t\trf.mu.Unlock()\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n\n### PartC的实现\n此处首先需要添加状态机的持久化的方法，并且需要在启动的时候添加一个读取旧的持久化状态机的方法。\n```\nfunc (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) {\n\trf.chanCanApply <- 1\n\trf.mu.Lock()\n\treply.Success = false\n\tpersistFlag := 0\n\tif args.Term < rf.currentTerm {\n\t\treply.Term = rf.currentTerm\n\t\trf.mu.Unlock()\n\t\t<-rf.chanCanApply\n\t\treturn\n\t}\n\tif rf.currentTerm < args.Term {\n\t\trf.currentTerm = args.Term\n\t\trf.ClearChan()\n\t\trf.voteFor = -1\n\t\trf.state = Follower\n\t\tpersistFlag = 1\n\t}\n\treply.Term = rf.currentTerm\n\t// similar to appendEntries receive call\n\trf.chanAppendEntries <- 1\n\tfirstIndex := rf.logs[0].Index\n\tnowIndex := args.LastIncludeIndex - firstIndex\n\tif nowIndex < 0 {\n\t\tif persistFlag == 1 {\n\t\t\trf.persist()\n\t\t}\n\t\treply.PrevIndex = firstIndex\n\t\trf.mu.Unlock()\n\t\t<-rf.chanCanApply\n\t\treturn\n\t}\n\trf.logs = args.Logs\n\trf.lastApplied = args.LastIncludeIndex\n\trf.commitedIndex = args.LeaderCommitIndex\n\trf.persister.SaveStateAndSnapshot(rf.getPersistByte(), args.Snapshot)\n\tmsg := ApplyMsg{CommandValid: false, Snapshot: args.Snapshot}\n\trf.mu.Unlock()\n\trf.chanApplyMsg <- msg\n\t<-rf.chanCanApply\n\treply.Success = true\n\n}\n\n```\n\n```\n// 启动的时候添加这个方法把Snapshotload出来\nrf.readPersist(persister.ReadRaftState())\n```\n\n并且需要注意在投票部分需要根据Safty那里提及的一个重要的地方，如果RequestVote RPC里面的日志Term与目前的Term不是一致的情况下，不能通过数票数的方法来进行计算。这个是为了整个集群的正确来考虑的。\n```\nfunc (rf *Raft) updateCommit() {\n\tN := rf.commitedIndex\n\tFirstIndex := rf.logs[0].Index\n\tfor i := max(rf.commitedIndex+1, FirstIndex+1); i <= rf.logs[rf.getLen()].Index; i++ {\n\t\tnum := 1\n\t\tfor j := range rf.peers {\n\t\t\tif j != rf.me {\n\t\t\t\tif rf.matchIndex[j] >= i {\n\t\t\t\t\t/*\n\t\t\t\t\t\tthis part is paper 5.4.2 limit, only can count replicate when log's term\n\t\t\t\t\t\tis equals to currentTerm\n\t\t\t\t\t*/\n\t\t\t\t\tif rf.logs[i-FirstIndex].Term == rf.currentTerm {\n\t\t\t\t\t\tnum++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif num > len(rf.peers)/2 {\n\t\t\tN = i\n\t\t}\n\t}\n\tif N > rf.commitedIndex && rf.state == Leader {\n\t\trf.commitedIndex = min(N, rf.logs[rf.getLen()].Index)\n\t\trf.chanCommit <- 1\n\t}\n}\n```","source":"_posts/raft-lab-2.md","raw":"---\ntitle:  MIT6.824 Lab2 实现及解析\ndate: 2019-08-20 12:05:38\ntags:  distributed-system\n---\n\n<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab2 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n# 目录\n1. [Raft论文阅读](#PaperReading)  \n2. [实现细节](#Detail)    \n        2.1 [Raft整体流程](#2.1)    \n        2.2 [Raft状态机维护](#2.2)  \n        2.3 [Raft代码实现](#2.3)  \n\n# <a id=\"PaperReading\"><span class=\"toptitle\">论文阅读及问题</span></a>\n\n论文各个章节主要解析\n1. 总体介绍，解析创造Raft的原因，并且简单描述Raft与Paxos的不同点\n2. 简单介绍一下副本状态机这个概念\n3. 简单描述Paxos的问题（包括了不好理解以及工业化上面的问题）\n4. 阐述Raft为什么比Paxos好理解\n5. Raft的算法的详细描述以及边界条件\n6. Raft集群出现成员变动的时候如何处理\n7. Raft的日志压缩和快照\n8. Client与Raft集群的交互方式\n\n实现的时候，重点要看Figure2中所提及的条件。\n\n# <a id=\"Detail\"><span class=\"toptitle\">代码实现</span></a>\n## <a id=\"2.1\"><span class=\"secondtitle\"> Raft整体流程</span></a>\n\n![Raft整体流程](/assets/img/posts/RaftProcess.png)\n\n此处只是一个比较简单的忽略具体可能出现错误细节的描述。\n本质上Raft就是一个通过一个维护一个协程里面的状态机，并且通过其他做网络请求的协程达成大部分节点在共识的算法。\n具体可以看这里的![演示动画](https://raft.github.io/)\n\n## <a id=\"2.2\"><span class=\"secondtitle\"> Raft状态机的转换</span></a>\n![Raft整体流程](/assets/img/posts/RaftStateMachine.png)\n\n此处是一个简单状态机的描述，具体转换的原因也已经在图上面有标出来。\n\n\n\n## <a id=\"2.3\"><span class=\"secondtitle\"> Raft代码的实现</span></a>\n代码实现在这个Lab中实际上分为了3part\n1. PartA  完成选举\n2. PartB  完成日志\n3. PartC  完成持久化的工作，并且处理共识的边界条件\n\n\n### PartA 的实现 \n跟随论文中提及的RequestVote RPC 以及 AppendEntries RPC 实现即可\n此处可以只需要完成心跳发送后可以保证非主节点不超时，不会使得Term有变动即可。\n\n一个注意的点，发送这两个RPC的时候，都是需要并行发送的，因此每个请求需要使用一个GoRoutine去进行实现。\n下面代码就是发送AppendEntries的代码的实例\n```\n    logs := make([]Log, 0)\n    tmpIndex := min(max(0, rf.nextIndex[number]-1), rf.logs[rf.getLen()].Index)\n    if tmpIndex < rf.logs[rf.getLen()].Index {\n        logs = rf.logs[tmpIndex+1-firstIndex:]\n        //DPrintf(\"server %d is Leader, tmpIndex is %d, firstIndex is %d, len of log is %d, commited index is %d\",\n        //\trf.me, tmpIndex, firstIndex, len(rf.logs), rf.commitedIndex)\n    }\n    args := AppendEntriesArgs{Term: rf.currentTerm, LeaderId: rf.me,\n        PrevLogTerm: rf.logs[tmpIndex-firstIndex].Term, PrevLogIndex: tmpIndex,\n        Entries: logs, Leadercommited: rf.commitedIndex}\n    //  使用Goroutine来发送请求\n    go func(args AppendEntriesArgs, number int) {\n        reply := AppendEntriesReply{}\n        ok := rf.sendAppendEntires(number, &args, &reply)\n        rf.mu.Lock()\n        defer rf.mu.Unlock()\n        if !ok {\n            DPrintf(\"allAppendEntries server %d call remote %d rpc AppendEntries failed\", rf.me, number)\n        }\n        if args.Term != rf.currentTerm {\n            return\n        }\n        if reply.Term > rf.currentTerm {\n            //rf.mu.Lock()\n            rf.state = Follower\n            rf.currentTerm = reply.Term\n            // TODO why Term voliate needed to persist?\n            rf.persist()\n            //rf.mu.Unlock()\n            return\n        }\n        if reply.Success == true && rf.state == Leader {\n            if len(args.Entries) > 0 {\n                rf.nextIndex[number] = args.Entries[len(args.Entries)-1].Index + 1\n                rf.matchIndex[number] = rf.nextIndex[number] - 1\n                if rf.matchIndex[number] > rf.commitedIndex {\n                    rf.updateCommit()\n                }\n            }\n        } else if rf.state == Leader {\n            if rf.nextIndex[number] > reply.PrevIndex+1 {\n                rf.nextIndex[number] = reply.PrevIndex + 1\n            } else {\n                rf.nextIndex[number] = max(rf.nextIndex[number]-1, 1)\n            }\n        }\n    }(args, number)\n```\n并且注意实现的时候的锁的使用，保证每次使用锁都有加锁和解锁的操作成对出现，否则可能会出现一些比较奇怪的情况。\n\n\n### PartB的实现\n此处需要接受模拟从客户端的请求进来然后把Log先放到本地的Log上面，然后把Log同步到其他的节点上面去进行共识的达成。\n\n首先的条件，需要确保Start函数接受请求的时候必须是Leader的角色，否则不会接收请求。（论文中有提及，此处Raft集群中非Leader节点不会把日志写入的请求转发到Leader节点上，这个是为了维护的方便来做的）\n```\nfunc (rf *Raft) Start(command interface{}) (int, int, bool) {\n\tindex := -1\n\tterm := -1\n\tisLeader := true\n\t// Wanring: do not double add lock for GetState function\n\trf.mu.Lock()\n\tdefer rf.mu.Unlock()\n\tterm, isLeader = rf.GetState()\n\tif isLeader {\n\t\tindex = rf.logs[rf.getLen()].Index + 1\n\t\t//oldLogLen := len(rf.logs)\n\t\trf.logs = append(rf.logs, Log{command, term, index})\n\t\t//DPrintf(\"server %d is Leader. new log has been appended, old length is %d, now is %d.  index number is %d, commitedindex is %d\",\n\t\t//\trf.me, oldLogLen, len(rf.logs), index, rf.commitedIndex)\n\t\tif len(rf.chanNewLog) == 0 {\n\t\t\trf.chanNewLog <- 1\n\t\t}\n\t\trf.persist()\n\t}\n\treturn index, term, isLeader\n}\n```\n重点处理的地方是nextIndex和MatchIndex 的计算以及维护的问题\n#### Apply的实现\n因为对于外部客户端的行为来说，Start函数是一个异步的函数, 所以实际上客户端是通过等待Make函数中输入的ApplyCh来确定能够apply成功，保证对外的原子性\n```\nfunc (rf *Raft) doApply() {\n\tfor {\n\t\trf.mu.Lock()\n\t\tst := rf.state\n\t\trf.mu.Unlock()\n\t\tif st == Killed {\n\t\t\treturn\n\t\t}\n\t\tselect {\n\t\tcase <-rf.chanCommit:\n\t\t\tfor {\n\t\t\t\trf.mu.Lock()\n\t\t\t\tif !(rf.lastApplied < rf.commitedIndex && rf.lastApplied < rf.logs[rf.getLen()].Index) {\n\t\t\t\t\trf.mu.Unlock()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tFirstIndex := rf.logs[0].Index\n\t\t\t\tif rf.lastApplied+1 >= FirstIndex {\n\t\t\t\t\tindex := min(rf.lastApplied+1-FirstIndex, rf.getLen())\n\t\t\t\t\tmsg := ApplyMsg{CommandValid: true, Command: rf.logs[index].Command, CommandIndex: rf.lastApplied + 1}\n\t\t\t\t\trf.lastApplied++\n\t\t\t\t\trf.mu.Unlock()\n\t\t\t\t\t//can't lock when send in channel, dead lock\n\t\t\t\t\t// canApplychan is to block the new\n\t\t\t\t\trf.chanCanApply <- 1\n\t\t\t\t\trf.chanApplyMsg <- msg\n\t\t\t\t\t<-rf.chanCanApply\n\t\t\t\t\trf.mu.Lock()\n\t\t\t\t}\n\t\t\t\trf.mu.Unlock()\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n\n### PartC的实现\n此处首先需要添加状态机的持久化的方法，并且需要在启动的时候添加一个读取旧的持久化状态机的方法。\n```\nfunc (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) {\n\trf.chanCanApply <- 1\n\trf.mu.Lock()\n\treply.Success = false\n\tpersistFlag := 0\n\tif args.Term < rf.currentTerm {\n\t\treply.Term = rf.currentTerm\n\t\trf.mu.Unlock()\n\t\t<-rf.chanCanApply\n\t\treturn\n\t}\n\tif rf.currentTerm < args.Term {\n\t\trf.currentTerm = args.Term\n\t\trf.ClearChan()\n\t\trf.voteFor = -1\n\t\trf.state = Follower\n\t\tpersistFlag = 1\n\t}\n\treply.Term = rf.currentTerm\n\t// similar to appendEntries receive call\n\trf.chanAppendEntries <- 1\n\tfirstIndex := rf.logs[0].Index\n\tnowIndex := args.LastIncludeIndex - firstIndex\n\tif nowIndex < 0 {\n\t\tif persistFlag == 1 {\n\t\t\trf.persist()\n\t\t}\n\t\treply.PrevIndex = firstIndex\n\t\trf.mu.Unlock()\n\t\t<-rf.chanCanApply\n\t\treturn\n\t}\n\trf.logs = args.Logs\n\trf.lastApplied = args.LastIncludeIndex\n\trf.commitedIndex = args.LeaderCommitIndex\n\trf.persister.SaveStateAndSnapshot(rf.getPersistByte(), args.Snapshot)\n\tmsg := ApplyMsg{CommandValid: false, Snapshot: args.Snapshot}\n\trf.mu.Unlock()\n\trf.chanApplyMsg <- msg\n\t<-rf.chanCanApply\n\treply.Success = true\n\n}\n\n```\n\n```\n// 启动的时候添加这个方法把Snapshotload出来\nrf.readPersist(persister.ReadRaftState())\n```\n\n并且需要注意在投票部分需要根据Safty那里提及的一个重要的地方，如果RequestVote RPC里面的日志Term与目前的Term不是一致的情况下，不能通过数票数的方法来进行计算。这个是为了整个集群的正确来考虑的。\n```\nfunc (rf *Raft) updateCommit() {\n\tN := rf.commitedIndex\n\tFirstIndex := rf.logs[0].Index\n\tfor i := max(rf.commitedIndex+1, FirstIndex+1); i <= rf.logs[rf.getLen()].Index; i++ {\n\t\tnum := 1\n\t\tfor j := range rf.peers {\n\t\t\tif j != rf.me {\n\t\t\t\tif rf.matchIndex[j] >= i {\n\t\t\t\t\t/*\n\t\t\t\t\t\tthis part is paper 5.4.2 limit, only can count replicate when log's term\n\t\t\t\t\t\tis equals to currentTerm\n\t\t\t\t\t*/\n\t\t\t\t\tif rf.logs[i-FirstIndex].Term == rf.currentTerm {\n\t\t\t\t\t\tnum++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif num > len(rf.peers)/2 {\n\t\t\tN = i\n\t\t}\n\t}\n\tif N > rf.commitedIndex && rf.state == Leader {\n\t\trf.commitedIndex = min(N, rf.logs[rf.getLen()].Index)\n\t\trf.chanCommit <- 1\n\t}\n}\n```","slug":"raft-lab-2","published":1,"updated":"2021-01-21T06:15:18.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6h2epb0000eci53tuy7iuk","content":"<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab2 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#PaperReading\">Raft论文阅读</a>  </li>\n<li><a href=\"#Detail\">实现细节</a>    <pre><code> 2.1 [Raft整体流程](#2.1)    \n 2.2 [Raft状态机维护](#2.2)  \n 2.3 [Raft代码实现](#2.3)  </code></pre>\n</li>\n</ol>\n\n        <h1 id=\"论文阅读及问题\"   >\n          <a href=\"#论文阅读及问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>论文阅读及问题</h1>\n      <p>论文各个章节主要解析</p>\n<ol>\n<li>总体介绍，解析创造Raft的原因，并且简单描述Raft与Paxos的不同点</li>\n<li>简单介绍一下副本状态机这个概念</li>\n<li>简单描述Paxos的问题（包括了不好理解以及工业化上面的问题）</li>\n<li>阐述Raft为什么比Paxos好理解</li>\n<li>Raft的算法的详细描述以及边界条件</li>\n<li>Raft集群出现成员变动的时候如何处理</li>\n<li>Raft的日志压缩和快照</li>\n<li>Client与Raft集群的交互方式</li>\n</ol>\n<p>实现的时候，重点要看Figure2中所提及的条件。</p>\n\n        <h1 id=\"代码实现\"   >\n          <a href=\"#代码实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码实现</h1>\n      \n        <h2 id=\"Raft整体流程\"   >\n          <a href=\"#Raft整体流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft整体流程</h2>\n      <p><img src=\"/assets/img/posts/RaftProcess.png\" alt=\"Raft整体流程\"></p>\n<p>此处只是一个比较简单的忽略具体可能出现错误细节的描述。<br>本质上Raft就是一个通过一个维护一个协程里面的状态机，并且通过其他做网络请求的协程达成大部分节点在共识的算法。<br>具体可以看这里的<img src=\"https://raft.github.io/\" alt=\"演示动画\"></p>\n\n        <h2 id=\"Raft状态机的转换\"   >\n          <a href=\"#Raft状态机的转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft状态机的转换</h2>\n      <p><img src=\"/assets/img/posts/RaftStateMachine.png\" alt=\"Raft整体流程\"></p>\n<p>此处是一个简单状态机的描述，具体转换的原因也已经在图上面有标出来。</p>\n\n        <h2 id=\"Raft代码的实现\"   >\n          <a href=\"#Raft代码的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft代码的实现</h2>\n      <p>代码实现在这个Lab中实际上分为了3part</p>\n<ol>\n<li>PartA  完成选举</li>\n<li>PartB  完成日志</li>\n<li>PartC  完成持久化的工作，并且处理共识的边界条件</li>\n</ol>\n\n        <h3 id=\"PartA-的实现\"   >\n          <a href=\"#PartA-的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartA 的实现</h3>\n      <p>跟随论文中提及的RequestVote RPC 以及 AppendEntries RPC 实现即可<br>此处可以只需要完成心跳发送后可以保证非主节点不超时，不会使得Term有变动即可。</p>\n<p>一个注意的点，发送这两个RPC的时候，都是需要并行发送的，因此每个请求需要使用一个GoRoutine去进行实现。<br>下面代码就是发送AppendEntries的代码的实例</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logs :&#x3D; make([]Log, 0)</span><br><span class=\"line\">tmpIndex :&#x3D; min(max(0, rf.nextIndex[number]-1), rf.logs[rf.getLen()].Index)</span><br><span class=\"line\">if tmpIndex &lt; rf.logs[rf.getLen()].Index &#123;</span><br><span class=\"line\">    logs &#x3D; rf.logs[tmpIndex+1-firstIndex:]</span><br><span class=\"line\">    &#x2F;&#x2F;DPrintf(&quot;server %d is Leader, tmpIndex is %d, firstIndex is %d, len of log is %d, commited index is %d&quot;,</span><br><span class=\"line\">    &#x2F;&#x2F;\trf.me, tmpIndex, firstIndex, len(rf.logs), rf.commitedIndex)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">args :&#x3D; AppendEntriesArgs&#123;Term: rf.currentTerm, LeaderId: rf.me,</span><br><span class=\"line\">    PrevLogTerm: rf.logs[tmpIndex-firstIndex].Term, PrevLogIndex: tmpIndex,</span><br><span class=\"line\">    Entries: logs, Leadercommited: rf.commitedIndex&#125;</span><br><span class=\"line\">&#x2F;&#x2F;  使用Goroutine来发送请求</span><br><span class=\"line\">go func(args AppendEntriesArgs, number int) &#123;</span><br><span class=\"line\">    reply :&#x3D; AppendEntriesReply&#123;&#125;</span><br><span class=\"line\">    ok :&#x3D; rf.sendAppendEntires(number, &amp;args, &amp;reply)</span><br><span class=\"line\">    rf.mu.Lock()</span><br><span class=\"line\">    defer rf.mu.Unlock()</span><br><span class=\"line\">    if !ok &#123;</span><br><span class=\"line\">        DPrintf(&quot;allAppendEntries server %d call remote %d rpc AppendEntries failed&quot;, rf.me, number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if args.Term !&#x3D; rf.currentTerm &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if reply.Term &gt; rf.currentTerm &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;rf.mu.Lock()</span><br><span class=\"line\">        rf.state &#x3D; Follower</span><br><span class=\"line\">        rf.currentTerm &#x3D; reply.Term</span><br><span class=\"line\">        &#x2F;&#x2F; TODO why Term voliate needed to persist?</span><br><span class=\"line\">        rf.persist()</span><br><span class=\"line\">        &#x2F;&#x2F;rf.mu.Unlock()</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if reply.Success &#x3D;&#x3D; true &amp;&amp; rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">        if len(args.Entries) &gt; 0 &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; args.Entries[len(args.Entries)-1].Index + 1</span><br><span class=\"line\">            rf.matchIndex[number] &#x3D; rf.nextIndex[number] - 1</span><br><span class=\"line\">            if rf.matchIndex[number] &gt; rf.commitedIndex &#123;</span><br><span class=\"line\">                rf.updateCommit()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else if rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">        if rf.nextIndex[number] &gt; reply.PrevIndex+1 &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; reply.PrevIndex + 1</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; max(rf.nextIndex[number]-1, 1)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(args, number)</span><br></pre></td></tr></table></div></figure>\n<p>并且注意实现的时候的锁的使用，保证每次使用锁都有加锁和解锁的操作成对出现，否则可能会出现一些比较奇怪的情况。</p>\n\n        <h3 id=\"PartB的实现\"   >\n          <a href=\"#PartB的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartB的实现</h3>\n      <p>此处需要接受模拟从客户端的请求进来然后把Log先放到本地的Log上面，然后把Log同步到其他的节点上面去进行共识的达成。</p>\n<p>首先的条件，需要确保Start函数接受请求的时候必须是Leader的角色，否则不会接收请求。（论文中有提及，此处Raft集群中非Leader节点不会把日志写入的请求转发到Leader节点上，这个是为了维护的方便来做的）</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) Start(command interface&#123;&#125;) (int, int, bool) &#123;</span><br><span class=\"line\">\tindex :&#x3D; -1</span><br><span class=\"line\">\tterm :&#x3D; -1</span><br><span class=\"line\">\tisLeader :&#x3D; true</span><br><span class=\"line\">\t&#x2F;&#x2F; Wanring: do not double add lock for GetState function</span><br><span class=\"line\">\trf.mu.Lock()</span><br><span class=\"line\">\tdefer rf.mu.Unlock()</span><br><span class=\"line\">\tterm, isLeader &#x3D; rf.GetState()</span><br><span class=\"line\">\tif isLeader &#123;</span><br><span class=\"line\">\t\tindex &#x3D; rf.logs[rf.getLen()].Index + 1</span><br><span class=\"line\">\t\t&#x2F;&#x2F;oldLogLen :&#x3D; len(rf.logs)</span><br><span class=\"line\">\t\trf.logs &#x3D; append(rf.logs, Log&#123;command, term, index&#125;)</span><br><span class=\"line\">\t\t&#x2F;&#x2F;DPrintf(&quot;server %d is Leader. new log has been appended, old length is %d, now is %d.  index number is %d, commitedindex is %d&quot;,</span><br><span class=\"line\">\t\t&#x2F;&#x2F;\trf.me, oldLogLen, len(rf.logs), index, rf.commitedIndex)</span><br><span class=\"line\">\t\tif len(rf.chanNewLog) &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\trf.chanNewLog &lt;- 1</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\trf.persist()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn index, term, isLeader</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>重点处理的地方是nextIndex和MatchIndex 的计算以及维护的问题</p>\n\n        <h4 id=\"Apply的实现\"   >\n          <a href=\"#Apply的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Apply的实现</h4>\n      <p>因为对于外部客户端的行为来说，Start函数是一个异步的函数, 所以实际上客户端是通过等待Make函数中输入的ApplyCh来确定能够apply成功，保证对外的原子性</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) doApply() &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\trf.mu.Lock()</span><br><span class=\"line\">\t\tst :&#x3D; rf.state</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\tif st &#x3D;&#x3D; Killed &#123;</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-rf.chanCommit:</span><br><span class=\"line\">\t\t\tfor &#123;</span><br><span class=\"line\">\t\t\t\trf.mu.Lock()</span><br><span class=\"line\">\t\t\t\tif !(rf.lastApplied &lt; rf.commitedIndex &amp;&amp; rf.lastApplied &lt; rf.logs[rf.getLen()].Index) &#123;</span><br><span class=\"line\">\t\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tFirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\t\t\t\tif rf.lastApplied+1 &gt;&#x3D; FirstIndex &#123;</span><br><span class=\"line\">\t\t\t\t\tindex :&#x3D; min(rf.lastApplied+1-FirstIndex, rf.getLen())</span><br><span class=\"line\">\t\t\t\t\tmsg :&#x3D; ApplyMsg&#123;CommandValid: true, Command: rf.logs[index].Command, CommandIndex: rf.lastApplied + 1&#125;</span><br><span class=\"line\">\t\t\t\t\trf.lastApplied++</span><br><span class=\"line\">\t\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F;can&#39;t lock when send in channel, dead lock</span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F; canApplychan is to block the new</span><br><span class=\"line\">\t\t\t\t\trf.chanCanApply &lt;- 1</span><br><span class=\"line\">\t\t\t\t\trf.chanApplyMsg &lt;- msg</span><br><span class=\"line\">\t\t\t\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\t\t\t\trf.mu.Lock()</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"PartC的实现\"   >\n          <a href=\"#PartC的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartC的实现</h3>\n      <p>此处首先需要添加状态机的持久化的方法，并且需要在启动的时候添加一个读取旧的持久化状态机的方法。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class=\"line\">\trf.chanCanApply &lt;- 1</span><br><span class=\"line\">\trf.mu.Lock()</span><br><span class=\"line\">\treply.Success &#x3D; false</span><br><span class=\"line\">\tpersistFlag :&#x3D; 0</span><br><span class=\"line\">\tif args.Term &lt; rf.currentTerm &#123;</span><br><span class=\"line\">\t\treply.Term &#x3D; rf.currentTerm</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif rf.currentTerm &lt; args.Term &#123;</span><br><span class=\"line\">\t\trf.currentTerm &#x3D; args.Term</span><br><span class=\"line\">\t\trf.ClearChan()</span><br><span class=\"line\">\t\trf.voteFor &#x3D; -1</span><br><span class=\"line\">\t\trf.state &#x3D; Follower</span><br><span class=\"line\">\t\tpersistFlag &#x3D; 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treply.Term &#x3D; rf.currentTerm</span><br><span class=\"line\">\t&#x2F;&#x2F; similar to appendEntries receive call</span><br><span class=\"line\">\trf.chanAppendEntries &lt;- 1</span><br><span class=\"line\">\tfirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\tnowIndex :&#x3D; args.LastIncludeIndex - firstIndex</span><br><span class=\"line\">\tif nowIndex &lt; 0 &#123;</span><br><span class=\"line\">\t\tif persistFlag &#x3D;&#x3D; 1 &#123;</span><br><span class=\"line\">\t\t\trf.persist()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treply.PrevIndex &#x3D; firstIndex</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trf.logs &#x3D; args.Logs</span><br><span class=\"line\">\trf.lastApplied &#x3D; args.LastIncludeIndex</span><br><span class=\"line\">\trf.commitedIndex &#x3D; args.LeaderCommitIndex</span><br><span class=\"line\">\trf.persister.SaveStateAndSnapshot(rf.getPersistByte(), args.Snapshot)</span><br><span class=\"line\">\tmsg :&#x3D; ApplyMsg&#123;CommandValid: false, Snapshot: args.Snapshot&#125;</span><br><span class=\"line\">\trf.mu.Unlock()</span><br><span class=\"line\">\trf.chanApplyMsg &lt;- msg</span><br><span class=\"line\">\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\treply.Success &#x3D; true</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 启动的时候添加这个方法把Snapshotload出来</span><br><span class=\"line\">rf.readPersist(persister.ReadRaftState())</span><br></pre></td></tr></table></div></figure>\n<p>并且需要注意在投票部分需要根据Safty那里提及的一个重要的地方，如果RequestVote RPC里面的日志Term与目前的Term不是一致的情况下，不能通过数票数的方法来进行计算。这个是为了整个集群的正确来考虑的。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) updateCommit() &#123;</span><br><span class=\"line\">\tN :&#x3D; rf.commitedIndex</span><br><span class=\"line\">\tFirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\tfor i :&#x3D; max(rf.commitedIndex+1, FirstIndex+1); i &lt;&#x3D; rf.logs[rf.getLen()].Index; i++ &#123;</span><br><span class=\"line\">\t\tnum :&#x3D; 1</span><br><span class=\"line\">\t\tfor j :&#x3D; range rf.peers &#123;</span><br><span class=\"line\">\t\t\tif j !&#x3D; rf.me &#123;</span><br><span class=\"line\">\t\t\t\tif rf.matchIndex[j] &gt;&#x3D; i &#123;</span><br><span class=\"line\">\t\t\t\t\t&#x2F;*</span><br><span class=\"line\">\t\t\t\t\t\tthis part is paper 5.4.2 limit, only can count replicate when log&#39;s term</span><br><span class=\"line\">\t\t\t\t\t\tis equals to currentTerm</span><br><span class=\"line\">\t\t\t\t\t*&#x2F;</span><br><span class=\"line\">\t\t\t\t\tif rf.logs[i-FirstIndex].Term &#x3D;&#x3D; rf.currentTerm &#123;</span><br><span class=\"line\">\t\t\t\t\t\tnum++</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif num &gt; len(rf.peers)&#x2F;2 &#123;</span><br><span class=\"line\">\t\t\tN &#x3D; i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif N &gt; rf.commitedIndex &amp;&amp; rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">\t\trf.commitedIndex &#x3D; min(N, rf.logs[rf.getLen()].Index)</span><br><span class=\"line\">\t\trf.chanCommit &lt;- 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>","site":{"data":{}},"excerpt":"","more":"<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab2 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#PaperReading\">Raft论文阅读</a>  </li>\n<li><a href=\"#Detail\">实现细节</a>    <pre><code> 2.1 [Raft整体流程](#2.1)    \n 2.2 [Raft状态机维护](#2.2)  \n 2.3 [Raft代码实现](#2.3)  </code></pre>\n</li>\n</ol>\n\n        <h1 id=\"论文阅读及问题\"   >\n          <a href=\"#论文阅读及问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>论文阅读及问题</h1>\n      <p>论文各个章节主要解析</p>\n<ol>\n<li>总体介绍，解析创造Raft的原因，并且简单描述Raft与Paxos的不同点</li>\n<li>简单介绍一下副本状态机这个概念</li>\n<li>简单描述Paxos的问题（包括了不好理解以及工业化上面的问题）</li>\n<li>阐述Raft为什么比Paxos好理解</li>\n<li>Raft的算法的详细描述以及边界条件</li>\n<li>Raft集群出现成员变动的时候如何处理</li>\n<li>Raft的日志压缩和快照</li>\n<li>Client与Raft集群的交互方式</li>\n</ol>\n<p>实现的时候，重点要看Figure2中所提及的条件。</p>\n\n        <h1 id=\"代码实现\"   >\n          <a href=\"#代码实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码实现</h1>\n      \n        <h2 id=\"Raft整体流程\"   >\n          <a href=\"#Raft整体流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft整体流程</h2>\n      <p><img src=\"/assets/img/posts/RaftProcess.png\" alt=\"Raft整体流程\"></p>\n<p>此处只是一个比较简单的忽略具体可能出现错误细节的描述。<br>本质上Raft就是一个通过一个维护一个协程里面的状态机，并且通过其他做网络请求的协程达成大部分节点在共识的算法。<br>具体可以看这里的<img src=\"https://raft.github.io/\" alt=\"演示动画\"></p>\n\n        <h2 id=\"Raft状态机的转换\"   >\n          <a href=\"#Raft状态机的转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft状态机的转换</h2>\n      <p><img src=\"/assets/img/posts/RaftStateMachine.png\" alt=\"Raft整体流程\"></p>\n<p>此处是一个简单状态机的描述，具体转换的原因也已经在图上面有标出来。</p>\n\n        <h2 id=\"Raft代码的实现\"   >\n          <a href=\"#Raft代码的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft代码的实现</h2>\n      <p>代码实现在这个Lab中实际上分为了3part</p>\n<ol>\n<li>PartA  完成选举</li>\n<li>PartB  完成日志</li>\n<li>PartC  完成持久化的工作，并且处理共识的边界条件</li>\n</ol>\n\n        <h3 id=\"PartA-的实现\"   >\n          <a href=\"#PartA-的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartA 的实现</h3>\n      <p>跟随论文中提及的RequestVote RPC 以及 AppendEntries RPC 实现即可<br>此处可以只需要完成心跳发送后可以保证非主节点不超时，不会使得Term有变动即可。</p>\n<p>一个注意的点，发送这两个RPC的时候，都是需要并行发送的，因此每个请求需要使用一个GoRoutine去进行实现。<br>下面代码就是发送AppendEntries的代码的实例</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logs :&#x3D; make([]Log, 0)</span><br><span class=\"line\">tmpIndex :&#x3D; min(max(0, rf.nextIndex[number]-1), rf.logs[rf.getLen()].Index)</span><br><span class=\"line\">if tmpIndex &lt; rf.logs[rf.getLen()].Index &#123;</span><br><span class=\"line\">    logs &#x3D; rf.logs[tmpIndex+1-firstIndex:]</span><br><span class=\"line\">    &#x2F;&#x2F;DPrintf(&quot;server %d is Leader, tmpIndex is %d, firstIndex is %d, len of log is %d, commited index is %d&quot;,</span><br><span class=\"line\">    &#x2F;&#x2F;\trf.me, tmpIndex, firstIndex, len(rf.logs), rf.commitedIndex)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">args :&#x3D; AppendEntriesArgs&#123;Term: rf.currentTerm, LeaderId: rf.me,</span><br><span class=\"line\">    PrevLogTerm: rf.logs[tmpIndex-firstIndex].Term, PrevLogIndex: tmpIndex,</span><br><span class=\"line\">    Entries: logs, Leadercommited: rf.commitedIndex&#125;</span><br><span class=\"line\">&#x2F;&#x2F;  使用Goroutine来发送请求</span><br><span class=\"line\">go func(args AppendEntriesArgs, number int) &#123;</span><br><span class=\"line\">    reply :&#x3D; AppendEntriesReply&#123;&#125;</span><br><span class=\"line\">    ok :&#x3D; rf.sendAppendEntires(number, &amp;args, &amp;reply)</span><br><span class=\"line\">    rf.mu.Lock()</span><br><span class=\"line\">    defer rf.mu.Unlock()</span><br><span class=\"line\">    if !ok &#123;</span><br><span class=\"line\">        DPrintf(&quot;allAppendEntries server %d call remote %d rpc AppendEntries failed&quot;, rf.me, number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if args.Term !&#x3D; rf.currentTerm &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if reply.Term &gt; rf.currentTerm &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;rf.mu.Lock()</span><br><span class=\"line\">        rf.state &#x3D; Follower</span><br><span class=\"line\">        rf.currentTerm &#x3D; reply.Term</span><br><span class=\"line\">        &#x2F;&#x2F; TODO why Term voliate needed to persist?</span><br><span class=\"line\">        rf.persist()</span><br><span class=\"line\">        &#x2F;&#x2F;rf.mu.Unlock()</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if reply.Success &#x3D;&#x3D; true &amp;&amp; rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">        if len(args.Entries) &gt; 0 &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; args.Entries[len(args.Entries)-1].Index + 1</span><br><span class=\"line\">            rf.matchIndex[number] &#x3D; rf.nextIndex[number] - 1</span><br><span class=\"line\">            if rf.matchIndex[number] &gt; rf.commitedIndex &#123;</span><br><span class=\"line\">                rf.updateCommit()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else if rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">        if rf.nextIndex[number] &gt; reply.PrevIndex+1 &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; reply.PrevIndex + 1</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; max(rf.nextIndex[number]-1, 1)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(args, number)</span><br></pre></td></tr></table></div></figure>\n<p>并且注意实现的时候的锁的使用，保证每次使用锁都有加锁和解锁的操作成对出现，否则可能会出现一些比较奇怪的情况。</p>\n\n        <h3 id=\"PartB的实现\"   >\n          <a href=\"#PartB的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartB的实现</h3>\n      <p>此处需要接受模拟从客户端的请求进来然后把Log先放到本地的Log上面，然后把Log同步到其他的节点上面去进行共识的达成。</p>\n<p>首先的条件，需要确保Start函数接受请求的时候必须是Leader的角色，否则不会接收请求。（论文中有提及，此处Raft集群中非Leader节点不会把日志写入的请求转发到Leader节点上，这个是为了维护的方便来做的）</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) Start(command interface&#123;&#125;) (int, int, bool) &#123;</span><br><span class=\"line\">\tindex :&#x3D; -1</span><br><span class=\"line\">\tterm :&#x3D; -1</span><br><span class=\"line\">\tisLeader :&#x3D; true</span><br><span class=\"line\">\t&#x2F;&#x2F; Wanring: do not double add lock for GetState function</span><br><span class=\"line\">\trf.mu.Lock()</span><br><span class=\"line\">\tdefer rf.mu.Unlock()</span><br><span class=\"line\">\tterm, isLeader &#x3D; rf.GetState()</span><br><span class=\"line\">\tif isLeader &#123;</span><br><span class=\"line\">\t\tindex &#x3D; rf.logs[rf.getLen()].Index + 1</span><br><span class=\"line\">\t\t&#x2F;&#x2F;oldLogLen :&#x3D; len(rf.logs)</span><br><span class=\"line\">\t\trf.logs &#x3D; append(rf.logs, Log&#123;command, term, index&#125;)</span><br><span class=\"line\">\t\t&#x2F;&#x2F;DPrintf(&quot;server %d is Leader. new log has been appended, old length is %d, now is %d.  index number is %d, commitedindex is %d&quot;,</span><br><span class=\"line\">\t\t&#x2F;&#x2F;\trf.me, oldLogLen, len(rf.logs), index, rf.commitedIndex)</span><br><span class=\"line\">\t\tif len(rf.chanNewLog) &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\trf.chanNewLog &lt;- 1</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\trf.persist()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn index, term, isLeader</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>重点处理的地方是nextIndex和MatchIndex 的计算以及维护的问题</p>\n\n        <h4 id=\"Apply的实现\"   >\n          <a href=\"#Apply的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Apply的实现</h4>\n      <p>因为对于外部客户端的行为来说，Start函数是一个异步的函数, 所以实际上客户端是通过等待Make函数中输入的ApplyCh来确定能够apply成功，保证对外的原子性</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) doApply() &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\trf.mu.Lock()</span><br><span class=\"line\">\t\tst :&#x3D; rf.state</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\tif st &#x3D;&#x3D; Killed &#123;</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-rf.chanCommit:</span><br><span class=\"line\">\t\t\tfor &#123;</span><br><span class=\"line\">\t\t\t\trf.mu.Lock()</span><br><span class=\"line\">\t\t\t\tif !(rf.lastApplied &lt; rf.commitedIndex &amp;&amp; rf.lastApplied &lt; rf.logs[rf.getLen()].Index) &#123;</span><br><span class=\"line\">\t\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tFirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\t\t\t\tif rf.lastApplied+1 &gt;&#x3D; FirstIndex &#123;</span><br><span class=\"line\">\t\t\t\t\tindex :&#x3D; min(rf.lastApplied+1-FirstIndex, rf.getLen())</span><br><span class=\"line\">\t\t\t\t\tmsg :&#x3D; ApplyMsg&#123;CommandValid: true, Command: rf.logs[index].Command, CommandIndex: rf.lastApplied + 1&#125;</span><br><span class=\"line\">\t\t\t\t\trf.lastApplied++</span><br><span class=\"line\">\t\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F;can&#39;t lock when send in channel, dead lock</span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F; canApplychan is to block the new</span><br><span class=\"line\">\t\t\t\t\trf.chanCanApply &lt;- 1</span><br><span class=\"line\">\t\t\t\t\trf.chanApplyMsg &lt;- msg</span><br><span class=\"line\">\t\t\t\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\t\t\t\trf.mu.Lock()</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"PartC的实现\"   >\n          <a href=\"#PartC的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartC的实现</h3>\n      <p>此处首先需要添加状态机的持久化的方法，并且需要在启动的时候添加一个读取旧的持久化状态机的方法。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class=\"line\">\trf.chanCanApply &lt;- 1</span><br><span class=\"line\">\trf.mu.Lock()</span><br><span class=\"line\">\treply.Success &#x3D; false</span><br><span class=\"line\">\tpersistFlag :&#x3D; 0</span><br><span class=\"line\">\tif args.Term &lt; rf.currentTerm &#123;</span><br><span class=\"line\">\t\treply.Term &#x3D; rf.currentTerm</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif rf.currentTerm &lt; args.Term &#123;</span><br><span class=\"line\">\t\trf.currentTerm &#x3D; args.Term</span><br><span class=\"line\">\t\trf.ClearChan()</span><br><span class=\"line\">\t\trf.voteFor &#x3D; -1</span><br><span class=\"line\">\t\trf.state &#x3D; Follower</span><br><span class=\"line\">\t\tpersistFlag &#x3D; 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treply.Term &#x3D; rf.currentTerm</span><br><span class=\"line\">\t&#x2F;&#x2F; similar to appendEntries receive call</span><br><span class=\"line\">\trf.chanAppendEntries &lt;- 1</span><br><span class=\"line\">\tfirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\tnowIndex :&#x3D; args.LastIncludeIndex - firstIndex</span><br><span class=\"line\">\tif nowIndex &lt; 0 &#123;</span><br><span class=\"line\">\t\tif persistFlag &#x3D;&#x3D; 1 &#123;</span><br><span class=\"line\">\t\t\trf.persist()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treply.PrevIndex &#x3D; firstIndex</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trf.logs &#x3D; args.Logs</span><br><span class=\"line\">\trf.lastApplied &#x3D; args.LastIncludeIndex</span><br><span class=\"line\">\trf.commitedIndex &#x3D; args.LeaderCommitIndex</span><br><span class=\"line\">\trf.persister.SaveStateAndSnapshot(rf.getPersistByte(), args.Snapshot)</span><br><span class=\"line\">\tmsg :&#x3D; ApplyMsg&#123;CommandValid: false, Snapshot: args.Snapshot&#125;</span><br><span class=\"line\">\trf.mu.Unlock()</span><br><span class=\"line\">\trf.chanApplyMsg &lt;- msg</span><br><span class=\"line\">\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\treply.Success &#x3D; true</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 启动的时候添加这个方法把Snapshotload出来</span><br><span class=\"line\">rf.readPersist(persister.ReadRaftState())</span><br></pre></td></tr></table></div></figure>\n<p>并且需要注意在投票部分需要根据Safty那里提及的一个重要的地方，如果RequestVote RPC里面的日志Term与目前的Term不是一致的情况下，不能通过数票数的方法来进行计算。这个是为了整个集群的正确来考虑的。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) updateCommit() &#123;</span><br><span class=\"line\">\tN :&#x3D; rf.commitedIndex</span><br><span class=\"line\">\tFirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\tfor i :&#x3D; max(rf.commitedIndex+1, FirstIndex+1); i &lt;&#x3D; rf.logs[rf.getLen()].Index; i++ &#123;</span><br><span class=\"line\">\t\tnum :&#x3D; 1</span><br><span class=\"line\">\t\tfor j :&#x3D; range rf.peers &#123;</span><br><span class=\"line\">\t\t\tif j !&#x3D; rf.me &#123;</span><br><span class=\"line\">\t\t\t\tif rf.matchIndex[j] &gt;&#x3D; i &#123;</span><br><span class=\"line\">\t\t\t\t\t&#x2F;*</span><br><span class=\"line\">\t\t\t\t\t\tthis part is paper 5.4.2 limit, only can count replicate when log&#39;s term</span><br><span class=\"line\">\t\t\t\t\t\tis equals to currentTerm</span><br><span class=\"line\">\t\t\t\t\t*&#x2F;</span><br><span class=\"line\">\t\t\t\t\tif rf.logs[i-FirstIndex].Term &#x3D;&#x3D; rf.currentTerm &#123;</span><br><span class=\"line\">\t\t\t\t\t\tnum++</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif num &gt; len(rf.peers)&#x2F;2 &#123;</span><br><span class=\"line\">\t\t\tN &#x3D; i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif N &gt; rf.commitedIndex &amp;&amp; rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">\t\trf.commitedIndex &#x3D; min(N, rf.logs[rf.getLen()].Index)</span><br><span class=\"line\">\t\trf.chanCommit &lt;- 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>"},{"title":"分布式系统一致性与共识","date":"2019-08-20T03:08:38.000Z","_content":"\n<!-- ---\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 11:08:38 +0800'\ncategory: \nsummary: Distributed System Consistency and Consensus\nthumbnail: distributed-system.png\n--- -->\n\n# 目录\n1. [分布式系统可以提供的若干保证和抽象机制](#PromiseAbstraction)  \n   1.1 [共识算法的意义](#1.1)  \n2. [如何在分布式系统中做到原子性](#atomic)  \n   2.1 [可线性化](#2.1)  \n   2.2 [顺序化](#2.2)  \n        2.2.1 [顺序、因果、全局序号的关系](#2.2.1)  \n        2.2.2 [全局关系的广播](#2.2.2)  \n3. [分布式系统的能力边界](#Capability)  \n   3.1  [分布式事务](#3.1)  \n   3.2  [容错的共识](#3.2)  \n4. [ShareNote](#ShareNote)  \n\n# <a id=\"PromiseAbstraction\"><span class=\"toptitle\">分布式系统可以提供的若干保证和抽象机制</span></a>\n\n## <a id=\"1.1\"><span class=\"secondtitle\">共识(分布式一致性)算法的意义</span></a>\n对于大多数的多副本的数据库（N>=2)的情况下，它至少达到了最终的一致性。但是因为只是最终，但是到达最终的状态的时间是未知的。  \n最终一致性的多副本数据状态（如Aurora、Riak、Cassandra）的不一致对于应用开发者是比较棘手，因为很多底层保证一致的东西需要挪动到应用层上面去添加规则来继续保证。并且导致测试和验证都会变得异常的困难\n\n基于上面的问题，我们可能需要找到一个更加强一致性的模型来进行构建，可以把应用层可能遇到的数据库不一致的问题封装起来。虽然可能会付出其他的代价（如性能下降、容错性差）\n\n### 与事务隔离的级别的差别\n共识与事务隔离都有类似与副本的概念（事务隔离是使用乐观锁（MVCC） 共识是使用多副本）  \n共识：更加强调是针对延时和故障协调副本之间的关系。  \n事务隔离：处理并发事务的各种临界的条件  \n\n# <a id=\"atomic\"><span class=\"toptitle\">如何在分布式系统中做到原子性</span></a>\n## <a id=\"2.1\"><span class=\"secondtitle\">可线性化</span></a>\n（此部分主要是DDIA第9章节的内容）\n定义： 让一个分布式的系统看起来像一个单副本的系统，并且所有的操作都是原子的。  \n### 一个非线性化的例子\n\n![非线性化图片](/assets/img/posts/non-linearized-example.png)  \n\n对于上面这个图的简要描述：  \n因为使用了多节点非强一致性的数据库，当Referee修改数据库的情况下，因为集群内同步的时间不一致，导致可能Alice先查的的Slave-1 已经修改了，但是Bob查询的Slave-2的库上面还没有修改，导致Alice和Bob获取到的结果不一致。这种场景对于一些一致性需求比较强的情况下不能接受。\n\n### <span class=\"thirdtitle\">线性化的例子的直觉表达</span>\n\n<b><font color=\"#FF0000\">线性化的简洁但是事实上的描述： 让分布式系统具有寄存器的语义。</font></b>  \n对于这个部分，我们详细去探讨一下  \n一般我们的对于读写请求并发（在客户端的角度）是这样的:\n定义一个前提， 下图中的一个框是指客户端从发出请求到接收到返回值的整个过程  \n单个框可以理解为 客户端发出请求-> 服务器端接受并且处理请求-> 服务器端返回结果-> 客户端在应用级别收到返回  \n下面可能出现框比较长的情况是在上一篇文章（![分布式系统简介以及其问题](https://ray1888.github.io/distributed-system/2019/08/20/chanllange-of-distributed-system/)）的假设所提及的情况，此处不再复述。  \n\n分布式系统中的寄存器： 线性化数据库中的相同的主键。（此处为X)  \n![粗粒度线性一致](/assets/img/posts/generate-line.png)  \n此处对于寄存器有两类的操作：\n1. read(x)  读取主键为X的值，数据库返回值v\n2. write(x,v) 客户端把X的值更新为V，数据库返回值为r(成功或者失败)\n\n对于上图在read和write重合的过程中，read的结果可能有2种情况：  \n1. read在write完成之前结束(返回0)  \n2. read在write完成之后结束 (返回1)  \n\n但是这个描述的粒度还是比较大，为了把系统线性化的更好的描述，我们添加下面的约束  \n![细粒度线性一致](/assets/img/posts/more-detail-line.png)  \n\n约束为，在写操作的过程中，肯定有某一个时间点，存储上面的x的值会出现冲0到1的跳变。  \n对于上图， 客户端A在某个节点能够读到X的值为1，那么因为客户端B的读操作是晚于客户端A读的发生的，因此  \n客户端B获取到的值也必然是1（如果不是1，则不是可线性化的系统）。  \n![线性一致](/assets/img/posts/line-final.png)\n但是上面的讨论颗粒还是太大了，此处我们加入进去存储，以及存储接收到的操作来整体观察线性一致。\n我们此处引入一个概念\n```\nCAS(compare and swap):一个原子的比较设置操作。编程语言中一般都要实现此概念，此处不详细叙述\n```\n并且添加一个假设：即使客户端可能还没有收到成功的响应，但是分布式的存储已经全部同步成新的值。\n上图中每个操作都有竖线，表示可能的执行的时间点，把这些点连接起来，最终结果必须是一个有效的寄存器读写顺序。  \n可线性化的要求： 按时间箭头向前移动，不能向后移动。\n可以看到上图中，最后客户端A的操作在c的Cas操作完成后，x的值已经变成了4，但是如果发现读的值为2的话，按时间线的理解就是错误了。因为根据可线性化的要求，cas操作已经执行了，并且时间只能向前走的情况下，客户端A的读操作必然是需要返回4的。\n\n```\n//可线性化和可串行化的对比\n#### 可线性化\n对寄存器（单个对象）的最新值保证。他不要求将操作组合到事务中，可能会出现写倾斜的问题（如果不采取手段去解决的问题）\n#### 可串行化\n是事务的隔离属性。每个事务可以读写多个对象，用于确保事务执行的结果与串行执行相同。即使穿行执行的顺序和实际执行的顺序并不一定相同（可能实际上的执行是并行执行事务，但是对外暴露的结果是一致的就可以）  \n```\n\n### <span class=\"thirdtitle\">需要用到线性化的使用场景</span>\n1. 加锁与主节点选举\n对于主从复制系统的选主问题，可以通过基于Etcd或者ZooKeeper来进行抢锁操作控制选主\n2. 约束与唯一性保证\n应用中对同一个资源（如用户名）的唯一性的约束。（可以延展到数据表的主键约束）\n3. 多信息源的时间依赖\n对于一些异步任务系统虽然采用了最终一致性，但是可能也是会因为实现产生数据的依赖问题。\n\n### 如何实现一个线性化系统\n#### 对比多种可能使用的方案来确定\n在考虑容错的基础上，必须考虑复制的机制。我们可以对比多种复制方案来看看那种可以实现线性化\n1. 主从复制。（部分线性化）\n因为所有写入操作都是从主节点继续，并且把操作同步到从节点上面。但是问题可能出现在实现的问题上：  \n    1. 实时同步可能会出现问题\n    2. 可能会因为快照隔离设计出现问题\n2. 共识算法（可线性化）\n类似于主从复制，但是通过一些手段来防止脑裂和过期的副本\n3. 多主复制（不可线性化）\n当允许并发写入的时候，如果进行异步复制的话，可能会出现数据的冲突。\n4. 无主复制（可能不可线性化）\n类似于Dynamo的机制，即使使用了Quroum机制，但是如果选取的Quroum不一定是满足的情况下，可能会出现非线性化的处理\n\n此处提出一个问题，是否只要有Quroum机制（就必定可以支持线性一致呢？）  \n答： 不一定。用下面的例子进行解释  \n\n![QuroumFail](/assets/img/posts/quroum-fail.png)  \n对于上图中，即使是使用了Quroum，但是没有共识算法的支持，还是可能会出现类似于之前Alice和Bob遇到的情况的问题。但是这个选取的直接是一个Quroum，但是是因为缺少共识，并且网络出现问题才会导致这样的情况出现。\n\n### 线性化的代价\n\n<font color=\"#FF0000\">线性化出现代价的最主要的原因还是因为网络的不确定性。</font>\n\n我们先用主从的架构来讨论这个问题，当网络发生分区的情况，主从不能够继续同步操作，可能会导致从库不可用。\n但是这个是我们需要实现线性化所带来的不可用\n\n先引入一个概念：CAP理论\n```\nCAP : 在同一个时间内，当网络出现分区的情况下，不可能获得兼容可用性和一致性。\n```\nCAP理论的推理：不要求线性化的应用更能够容忍网络分区。\n\n但是为了线性化，我们可能要牺牲性能和延迟。\n那么我们是否有方法可以做到线性化但是减少性能的牺牲呢？\n\n## <a id=\"2.2\"><span class=\"secondtitle\">顺序保证</span></a>\n我们刚刚在讨论线性化的时候使用到了寄存器的概念，那么顺序、可线性化、共识之间是否存在的某种关系呢？\n\n### <a id=\"2.2.1\"><span class=\"thirdtitle\">顺序、因果、全局序号的关系</span>\n#### <span class=\"fourth\">顺序和因果的关系</span>\n\n因果关系对所发生的事件添加了排序， 一件事情会导致另外一件事情，这些的因果关系依赖链条定义了系统中的因果顺序。如果符合因果关系所规定的顺序，我们称之为因果一致性。（快照隔离，在从数据库中读数据的情况下，查询到的诗句，也可以查到这个数据之前发生了什么的操作事件）\n\n#### <span class=\"fourth\">因果顺序并非全序</span>\n\n全序关系是可以支持两个不同的实体直接进行比较（如自然数集5和13的比较）  \n但是部分集合的对比不一定符合全序，集合{a,b} 与 集合{b,c}是无法进行对比的  \n\n因此，提炼到可线性化和因果关系中  \n可线性化是存在全序的操作关系，因为暴露对外的行为是与单副本无异，并且每个操作都是原子的。可以分出先后  \n因果是偏序的操作关系，对于并发的两个操作无法比较的情况下，就会发生冲突，对于可以比较的情况下，与线性无异。    \n那么可以这样说，可线性化一定意味着因果关系，因为可线性化是全序的操作。    \n但是可以这样理解，线性化并非是保证因果关系的唯一的途径。我们可以有其他手段去满足因果一致性而避免线性化所带来的问题。    \n因果一致性是被认为是不会由于网络延迟而显著影响性能，并且可以对网络故障容错提供容错的最强一致性的模型。  \n因为实际上很多的应用所需要的是因果一致性来保证应用的正确性。  \n\n#### <span class=\"fourth\">捕获因果依赖关系</span>\n如果只要解决并发操作的先后依赖关系。这里其实只需要由偏序的关系即可。\n我们常见的数据库的版本技术就是一个解决这个问题的方案之一\n为了确定数据库的因果关系，数据库需要知道应用读取的是哪个版本的数据。\n\n#### <span class=\"fourth\">序列号排序</span>\n那么，这样的情况下，我们是否需要显式的跟踪所有的因果关系呢？  \n为了性能的考虑，我们可以通过序列号和时间戳（尽量不使用物理时钟）来进行对事件排序，这样在保证性能的同时，也能够保证所有操作在全局的关系。但是要保证每个序列号必须唯一，并且可以比较。  \n我们可以按照与因果关系一致的顺序来创建序列号： 如果操作A发生B之前，那么A一定在全序顺序中出现在B之前    \n这样的全局排序可以捕获所有的因果信息，并且加强了比因果关系更为严格的顺序性  \n\n那么对于不存在唯一的主节点（多主或者无主），那么我们能怎样生成上面所提及的序列号呢？  \n有实践中可以采用以下方法：  \n    1. 每个节点单独生成自己的一组序列号。假设有两个节点，一个生成奇数，一个生成偶数  \n    2. 把Timestamp添加到操作中（之前生产中有用此种方式）  \n    3. 预先分配序列号的区间范围。（A节点分配1-1000，B节点分配1001-2000）  \n\n但是这三种实际上生成的唯一的，近似增加的序列号。但是实际上序列号和因果一致不是完全因果一致的。  \n为什么不是因果一致呢?  \n对于情况1，每个节点处理的速率是由不一致的，只要两个节点处于处理速率不一致的情况下，分配的ID必然和实际的顺序关系无法对应  \n对于情况2， 墙上时钟发生偏移的情况  \n对于情况3， 如果sharding的路由发生了变化之后，那么之前1-1000的因果关系就不存在了。  \n\n那么我们是否没有办法可以在非强主的情况可以获取一个序列号与因果一致可以对应上的吗？  \n\n我们还有一个方法！！！此处大神来了Leslie Lamport的Lamport TimeStamp可以解决这个问题  \n\n#### <span class=\"fourth\">LamportTimeStamp</span>\n![LamportTimeStamp](/assets/img/posts/LamportTimestamp.png)  \n每个节点一开始的时候都会有一个唯一的标识符（每次初始为0）， 然后每个节点都有一个计数器来记录各自处理的请求总数。到此与之前的时间戳的并无差别，但是Lamport这里处理的亮点出来了，每个节点和每个客户端都会跟踪迄今为止最大的计数器值，并且在每个请求中附带该最大计数器值。当节点收到某个请求的时候，如果发现请求内的最大计数器值大于自身的计数器值，会更新自己的计数器值（Raft中是通过投票和心跳的RPC来同步这个计数器的值，在Raft的概念里面叫做Term，后面讲解Raft的时候会进一步解析，此处只是一个插叙）。\n\nLamportTimeStamp好像是解决了分布式系统顺序号和因果一致的关系，但是是已经足够解决分布式系统中常见的问题了吗？  \n问题如下：  \n    一个系统的用户名只能由唯一的用户持有，两个用户并发地向系统同时进行注册，我们必须要保证一个成功，一个失败    \n虽然看上去我们是可以把两个请求通过编号把两个并发的请求变成了一个有顺序的问题，但是实际上要保证上面的是唯一的有两个前提：  \n    1. 节点收到用户请求的时候需要马上判断请求时成功还是失败  \n    2. 必须要收集系统的所有创建用户的请求，比较序号  \n但是这个显然是不可能的，只要网络出现问题了，我们就无法做到上面的两个问题。\n\n那么我们如果要知道全局关系是否确定，就需要提到后面的一个概念，全序关系广播\n\n### <a id=\"2.2.2\"><span class=\"thirdtitle\">全局关系的广播</span></a>\n继续先从一个主从复制的系统开始说起，主节点接受写请求并且变成顺序的操作。  \n但是在分布式系统领域，如何扩展系统的吞吐量使之突破单一主节点限制以及处理主节点失效时的故障切换。这类的问题被称为全序关系广播或者原子广播。  \n全序关系广播： 通常指节点之间交换信息的某种协议。有两个特性  \n    1. 可靠发送（没有消息丢失，如果消息发送到某一个节点，它一定要发送到其他的节点）  \n    2. 严格有序（消息总是以相同的顺序发送到每个节点）  \n\n#### <span class=\"fourth\">使用全序关系广播</span>\nZookeeper和Etcd的共识服务就实现了全序关系广播。（那么全序关系广播和共识之间的关系？）  \n\n全序关系广播就是数据库所需要，每条消息表达数据库的写请求，而且每个副本段相同的顺序处理这些写请求，那么所有副本可以保持一致。这个也被称为状态机复制。  \n\n全局关系广播的另一个要点，顺序在发送消息时已经是确定的，如果消息发送成功，节点不允许追溯将某条消息插到先前的位置上。只能进行追加，这样全序关系广播比时间戳的排序要求更强  \n应用场景：  \n    1.我们可以使用全序关系广播来实现可串行化的事务。（每个消息表示为一个确定性质的事务，并且作为存储过程来执行）    \n    2.提供Fencing令牌锁的服务（把取锁的请求变成一个消息追加到日志中，序列号直接可以变成令牌返回）  \n\n#### 全序关系广播来实现线性化存储\n全序关系广播是基于异步模型，保证消息以固定顺序的可靠发送，但是不保证消息何时发送成功，但是可线性化更多地强调读取时能看到最新的写入值。  \n我们可以通过追加的日志的方式使得使用全序关系广播在写入的方式上与可线性化做到一致  \n    1. 在接受请求的本地节点中追加一条消息，指明写入的信息  \n    2. 读取日志，广播到其他节点，等待回应  \n    3. 如果回复中有冲突，则失败，返回错误给客户端；否则返回成功给客户端  \n通过日志追加可以把并发有效的转换为多条的日志来保证因果顺序关系。但是读取却还没做到这个语义  \n为了读取可以与可线性化一致，有以下方法可以解决这个问题：\n    1. 把读的请求也变成日志的方式追加到排序广播，通过变成日志的情况下可以确定了顺序的问题。（ETCD采用的是这种方式）  \n    2. 如果可以以可线性化的方式获取最新日志的消息位置，则查询位置，直到该位置之前的所有条目读发送给你，再进行读取（ZooKeeper使用的方式）  \n    3. 可以从同步更新的副本中进行读取，保证每次读的是最新的值。  \n\n所以最终可线性化的原子地对寄存器做CAS的操作与全序关系广播其实等价于共识的问题。\n\n# <a id=\"Capability\"><span class=\"toptitle\">分布式共识的能力边界</span></a>\n共识： 使得分布式系统中就某件事情达成一致  \n共识的使用场景：  \n    1. 主节点选举（防止脑裂问题）  \n    2. 原子事务的提交（跨节点或分区的数据库，事务在部分节点成功，部分节点失败，需要进行回滚）  \n我们先从事务的原子性开始，讨论2PC（2阶段提交），之后再会谈及其他更好的共识算法的实现（ZooKeeper， Raft）  \n\n## <a id=\"3.1\"><span class=\"secondtitle\">分布式事务 </span></a>\n事务原子性的目的：  \n一个多笔写操作的事务在执行过程中出现意外情况，为上层应用提供一个简单的语义，全部成功或者全部失败  \n单机原子提交：  \n数据库把事务写入持久化部分，然后把提交记录追加写入到磁盘的日志文件中。所以在单节点上面，事务提交非常依赖与数据持久写入磁盘的顺序关系  \n    1. 先写入数据，再提交记录  \n    2. 事务提交或者中止的关键点在于磁盘完成日志的时候，在完成写之前崩溃的情况下，事务需要中止；如果日志在完成写入后发生崩溃，事务被安全提交  \n\n但是对于分布式多节点，处理方法有所差别，原因可能是以下这几个问题引起的  \n    1. 某些节点发现不满足要求中止了事务，但是部分节点通过并且提交    \n    2. 部分请求可能在网络不稳定的情况下丢失，超时而中止；但是其他请求可能成功提交  \n    3. 节点可能在写入日志前崩溃，而且在恢复后回滚（原来数据没有成功，回滚可能会出现问题）  \n如果一部分节点提交了事务，但是部分节点放弃了事务，会导致集群中节点信息的不一致，而且事务一旦被提交，即使事后发现其他节点中止，也无法撤销本节点的事务  \n\n事务提交后不能撤销的原因：   \n一旦数据提交，就会被其他事务可见，然后客户端（应用层）就会做出相应的反应，这个是构成读-提交隔离的基础。但是如果允许撤销的话，那么所有之后的读-提交级别的任务，然后会产生多级的级联式追溯和撤销。导致系统压力巨大甚至崩溃。并且不能保证数据是否能够准确落盘。  \n\n因为不允许撤销事务，因为如果一个错误的事务被提交了，必然需要一个新的事务来抵消它的影响，但是这个需要应用层来进行处理，就不符合我们需要给应用层提供的原子性。  \n\n### 2PC \n两阶段提交（2PC）是一种在多个节点上实现事务原子提交的算法。要么全部提交，要么全部不提交。\n\n##### 2PC的流程（为什么可以解决上面单阶段提交的问题）\n1. 应用启动分布式事务的时候，先去像协调者获取事务ID（全局唯一）\n2. 应用程序在每个参与的节点启动单节点事务，并且把事务ID附加到到参与者的事务上。如果这个阶段发生异常，可以协调者和其他参与者可以安全中止\n3. 应用程序准备提交事务时，协调者回向参与者发送携带事务ID准备请求，只要有一个发现失败的情况下，通知全部放弃事务\n4. 参与者收到请求后，确保自己时候可以提交事务（包括硬件故障和软件故障的确认），然后检查是否有冲突或者违规。一旦返回是，节点会承诺提交事务。（保证了参与者不会撤销事务）\n5. 当协调者收到所有的参与者返回后，要决定是否提交事务，并且把此决定写入到硬盘的事务日志（WAL）中，防止掉电后可能出现的异常\n6. 协调者向参与者发送提交/放弃 事物的请求，只要是提交，每个参与者会重试到成功为止(包括了进程崩溃的重试、节点重启等情况)\n\n所以他是在保证了上面的一个重要前提，只要提交了就不能撤回。\n在参与者在返回给协调者的时候保证了单向性\n并且协调者确定提交了之后也是保证了不可逆，因此保证了2pc可以不会出现那些异常的情况。\n\n但是2PC的单点在于协调者的问题（虽然可以采用共识层来写协调者保证高可用）但是整个过程中的热点也会出现在协调者上面。\n\n### 实际生产上面的分布式事务\n### 异构分布式事务\n虽然分布式事务因为这样可能会有阻塞而导致性能和吞吐量的下降，但是是否没有折中的方法来使用类似的语义呢？\n目前更多的是采用了异构的方法（如数据库+MQ）的执行异构的分布式事务\n\n对于异构形式的分布式事务，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息处理完毕。\n但只要其中一个出现失败的情况，两个部分都必须进行中止的操作。\n\n<b>保证消息可以有效处理有且仅有一次</b>\n\n目前有XA的异构的分布式事务的标准。\n\n## <a id=\"3.2\"><span class=\"secondtitle\">支持容错的共识</span></a>\n共识问题的形式化描述： 一个或者多个节点可以提议某些值，由共识算法来决定最终的值。\n\n基于上面的描述共识算法必须满足以下的性质：\n    1. 协商一致性（所有节点都接受相同的决议）\n    2. 诚实性（所有节点不能反悔，对某项提议不能有两次决定）\n    3. 合法性（决定了值V, 那么V肯定是由某个节点提议的）\n    4. 可终止性（如果节点不崩溃最终一定可以达成协议）\n\n协商一致性和诚实的属性定义了共识算法的核心思想：决定一致的结果，并且一旦决定就不能改变。  \n合法性是为了排除一些无意义的方案，  \n可终止性是容错的体现，避免了整个系统的空转  \n根据之前提及的： 可终止性是活性， 其他三个是安全方面的属性。\n\n因为共识算法的目的是解决在大多数节点正常的情况下正确运行才能确保终止性。\n\n### 共识算法和全序广播的关系\n\n共识算法(如Raft、Paxos、Zab)等都不是直接采用上述的形式化模型。而是决定了一系列的值，然后采用全序关系广播算法来进行实现。  \n\n全序关系广播要点： 消息按相同的顺序发送到所有的节点，有且只有一次。  \n这样的方式相当于多轮的共识过程。在每一轮，节点会提出之后需要发出的信息，然后决定下一个顺序。\n\n对于上面的提到的四个性质：\n1. 由于协商的一致性，所有节点决定以相同的顺序发送相同的消息。\n2. 由于诚实性，消息不会重复\n3. 由于合法性， 消息不会被破坏，也不是凭空捏造\n4. 由于可终止性，消息不会丢失\n\n### Epoch 和 Quorum\n\n对于共识算法来说，都采用了一个弱化的保证，定义了一个世代编号（Epoch）来确保每个世代里面，主节点是唯一的。\n如果发现当前主节点失效的情况，节点开始选举新一轮的主节点，Epoch号递增。在主节点做出任何决定的时候，都需要检查是否由比它更高的Epoch号码。\n主节点必须从Quorum中收集投票，并且把提议传送到各个节点中，等待节点的返回，当只要没有更高的Epoch主节点\n时，才会对当前的提议进行投票。\n\n此处其实是由两个操作组成：1. 选举主节点； 2.对主节点的提议进行投票\n\n注意的一点： 参与两轮的Quorum必须要由重合，这样才能保证主节点没有更高的Epoch，保证正确性。\n\n与2PC的差别， 2PC是需要协调者向每个参与者做出“是”的返回才能进行，而共识算法可以通过直接以集群的多数来确定是否通过决议\n\n### 共识算法的局限性\n\n共识算法虽然为分布式系统带来了好处，为一切不确定的系统带来了安全属性和容错性。并且可以通过全序关系广播以容错的方式实现线性化的原子操作。\n\n但是共识也是有代价的：\n1. 节点投票是一个同步复制过程，性能可能需要妥协（但是可以通过减少选举的频率来减少整个开销）\n2. 共识体系需要严格的多数节点才能执行，换句话来说，最少需要3个节点才能运行\n3. 多数的共识算法假定了一组固定的参与投票的节点集（主要是为了理解的方便）\n4. 共识算法需要依靠超时来对节点失败进行检测，但是可能会出现因为网络原因的误判导致经常切主，数据搬移多，对外的性能降低。\n5. 网络的影响较大，如果出现频繁切主的情况，可能会有长时间出现无法正常对外进行服务\n\n### 基于共识算法的成员与协调服务\n\n对于像ZooKeeper、Etcd这些分布式键值对的服务，暴露的API与数据库是十分类似的，但是为什么我们需要在共识层上面去构建这些服务呢？\n\n#### 作用\n这些分布式键值对数据库主要是针对保存少量，可完全载入内存的数据。采用容错的全序广播算法在所有节点上复制数据使得可以实现高可用的目标。\n1. 线性化的原子操作\n多个节点同时去获取锁，只有一个会成功，共识协议会保证操作满足原子性和线性化，即使节点出现部分失败的情况\n2. 操作全序\n之前分布式系统问题的文章有提及过Fencing令牌的问题，\n3. 故障检测\n客户端会与这些服务保持一个长连接，如果长时间重连失败的情况下，会把该客户端拥有的资源全部释放\n4. 更改通知\n客户端可以通过读取服务来发现其他的客户端的行为\n\n#### 对外的功能\n1. 节点任务分配\n计算作业调度系统(Yarn)，分区资源调度（如Multi-Raft中的ShardMaster)\n2. 服务发现\n解决云环境中服务启停而注册到的服务变更(consul提供的服务)\n3. 成员服务\n节点是否可用并且获取主节点\n\n### 如何验证一个线性化系统\n（此部分会结合Mit6.824和PingCap tikv 的线性化验证的代码阅读和文章来描述）\n\n\n# <a id=\"ShareNote\">ShareNote</a>\n1. [Dynamo](https://pdos.csail.mit.edu/6.824/papers/dynamo.pdf)\n2. [Riak](https://github.com/basho/riak_core)\n3. [Cassandra](http://cassandra.apache.org/)\n4. [数据密集型应用系统设计](https://book.douban.com/subject/30329536/)","source":"_posts/distribute-system-consensus.md","raw":"---\ntitle: 分布式系统一致性与共识\ndate: 2019-08-20 11:08:38\ntags: distributed-system\n---\n\n<!-- ---\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 11:08:38 +0800'\ncategory: \nsummary: Distributed System Consistency and Consensus\nthumbnail: distributed-system.png\n--- -->\n\n# 目录\n1. [分布式系统可以提供的若干保证和抽象机制](#PromiseAbstraction)  \n   1.1 [共识算法的意义](#1.1)  \n2. [如何在分布式系统中做到原子性](#atomic)  \n   2.1 [可线性化](#2.1)  \n   2.2 [顺序化](#2.2)  \n        2.2.1 [顺序、因果、全局序号的关系](#2.2.1)  \n        2.2.2 [全局关系的广播](#2.2.2)  \n3. [分布式系统的能力边界](#Capability)  \n   3.1  [分布式事务](#3.1)  \n   3.2  [容错的共识](#3.2)  \n4. [ShareNote](#ShareNote)  \n\n# <a id=\"PromiseAbstraction\"><span class=\"toptitle\">分布式系统可以提供的若干保证和抽象机制</span></a>\n\n## <a id=\"1.1\"><span class=\"secondtitle\">共识(分布式一致性)算法的意义</span></a>\n对于大多数的多副本的数据库（N>=2)的情况下，它至少达到了最终的一致性。但是因为只是最终，但是到达最终的状态的时间是未知的。  \n最终一致性的多副本数据状态（如Aurora、Riak、Cassandra）的不一致对于应用开发者是比较棘手，因为很多底层保证一致的东西需要挪动到应用层上面去添加规则来继续保证。并且导致测试和验证都会变得异常的困难\n\n基于上面的问题，我们可能需要找到一个更加强一致性的模型来进行构建，可以把应用层可能遇到的数据库不一致的问题封装起来。虽然可能会付出其他的代价（如性能下降、容错性差）\n\n### 与事务隔离的级别的差别\n共识与事务隔离都有类似与副本的概念（事务隔离是使用乐观锁（MVCC） 共识是使用多副本）  \n共识：更加强调是针对延时和故障协调副本之间的关系。  \n事务隔离：处理并发事务的各种临界的条件  \n\n# <a id=\"atomic\"><span class=\"toptitle\">如何在分布式系统中做到原子性</span></a>\n## <a id=\"2.1\"><span class=\"secondtitle\">可线性化</span></a>\n（此部分主要是DDIA第9章节的内容）\n定义： 让一个分布式的系统看起来像一个单副本的系统，并且所有的操作都是原子的。  \n### 一个非线性化的例子\n\n![非线性化图片](/assets/img/posts/non-linearized-example.png)  \n\n对于上面这个图的简要描述：  \n因为使用了多节点非强一致性的数据库，当Referee修改数据库的情况下，因为集群内同步的时间不一致，导致可能Alice先查的的Slave-1 已经修改了，但是Bob查询的Slave-2的库上面还没有修改，导致Alice和Bob获取到的结果不一致。这种场景对于一些一致性需求比较强的情况下不能接受。\n\n### <span class=\"thirdtitle\">线性化的例子的直觉表达</span>\n\n<b><font color=\"#FF0000\">线性化的简洁但是事实上的描述： 让分布式系统具有寄存器的语义。</font></b>  \n对于这个部分，我们详细去探讨一下  \n一般我们的对于读写请求并发（在客户端的角度）是这样的:\n定义一个前提， 下图中的一个框是指客户端从发出请求到接收到返回值的整个过程  \n单个框可以理解为 客户端发出请求-> 服务器端接受并且处理请求-> 服务器端返回结果-> 客户端在应用级别收到返回  \n下面可能出现框比较长的情况是在上一篇文章（![分布式系统简介以及其问题](https://ray1888.github.io/distributed-system/2019/08/20/chanllange-of-distributed-system/)）的假设所提及的情况，此处不再复述。  \n\n分布式系统中的寄存器： 线性化数据库中的相同的主键。（此处为X)  \n![粗粒度线性一致](/assets/img/posts/generate-line.png)  \n此处对于寄存器有两类的操作：\n1. read(x)  读取主键为X的值，数据库返回值v\n2. write(x,v) 客户端把X的值更新为V，数据库返回值为r(成功或者失败)\n\n对于上图在read和write重合的过程中，read的结果可能有2种情况：  \n1. read在write完成之前结束(返回0)  \n2. read在write完成之后结束 (返回1)  \n\n但是这个描述的粒度还是比较大，为了把系统线性化的更好的描述，我们添加下面的约束  \n![细粒度线性一致](/assets/img/posts/more-detail-line.png)  \n\n约束为，在写操作的过程中，肯定有某一个时间点，存储上面的x的值会出现冲0到1的跳变。  \n对于上图， 客户端A在某个节点能够读到X的值为1，那么因为客户端B的读操作是晚于客户端A读的发生的，因此  \n客户端B获取到的值也必然是1（如果不是1，则不是可线性化的系统）。  \n![线性一致](/assets/img/posts/line-final.png)\n但是上面的讨论颗粒还是太大了，此处我们加入进去存储，以及存储接收到的操作来整体观察线性一致。\n我们此处引入一个概念\n```\nCAS(compare and swap):一个原子的比较设置操作。编程语言中一般都要实现此概念，此处不详细叙述\n```\n并且添加一个假设：即使客户端可能还没有收到成功的响应，但是分布式的存储已经全部同步成新的值。\n上图中每个操作都有竖线，表示可能的执行的时间点，把这些点连接起来，最终结果必须是一个有效的寄存器读写顺序。  \n可线性化的要求： 按时间箭头向前移动，不能向后移动。\n可以看到上图中，最后客户端A的操作在c的Cas操作完成后，x的值已经变成了4，但是如果发现读的值为2的话，按时间线的理解就是错误了。因为根据可线性化的要求，cas操作已经执行了，并且时间只能向前走的情况下，客户端A的读操作必然是需要返回4的。\n\n```\n//可线性化和可串行化的对比\n#### 可线性化\n对寄存器（单个对象）的最新值保证。他不要求将操作组合到事务中，可能会出现写倾斜的问题（如果不采取手段去解决的问题）\n#### 可串行化\n是事务的隔离属性。每个事务可以读写多个对象，用于确保事务执行的结果与串行执行相同。即使穿行执行的顺序和实际执行的顺序并不一定相同（可能实际上的执行是并行执行事务，但是对外暴露的结果是一致的就可以）  \n```\n\n### <span class=\"thirdtitle\">需要用到线性化的使用场景</span>\n1. 加锁与主节点选举\n对于主从复制系统的选主问题，可以通过基于Etcd或者ZooKeeper来进行抢锁操作控制选主\n2. 约束与唯一性保证\n应用中对同一个资源（如用户名）的唯一性的约束。（可以延展到数据表的主键约束）\n3. 多信息源的时间依赖\n对于一些异步任务系统虽然采用了最终一致性，但是可能也是会因为实现产生数据的依赖问题。\n\n### 如何实现一个线性化系统\n#### 对比多种可能使用的方案来确定\n在考虑容错的基础上，必须考虑复制的机制。我们可以对比多种复制方案来看看那种可以实现线性化\n1. 主从复制。（部分线性化）\n因为所有写入操作都是从主节点继续，并且把操作同步到从节点上面。但是问题可能出现在实现的问题上：  \n    1. 实时同步可能会出现问题\n    2. 可能会因为快照隔离设计出现问题\n2. 共识算法（可线性化）\n类似于主从复制，但是通过一些手段来防止脑裂和过期的副本\n3. 多主复制（不可线性化）\n当允许并发写入的时候，如果进行异步复制的话，可能会出现数据的冲突。\n4. 无主复制（可能不可线性化）\n类似于Dynamo的机制，即使使用了Quroum机制，但是如果选取的Quroum不一定是满足的情况下，可能会出现非线性化的处理\n\n此处提出一个问题，是否只要有Quroum机制（就必定可以支持线性一致呢？）  \n答： 不一定。用下面的例子进行解释  \n\n![QuroumFail](/assets/img/posts/quroum-fail.png)  \n对于上图中，即使是使用了Quroum，但是没有共识算法的支持，还是可能会出现类似于之前Alice和Bob遇到的情况的问题。但是这个选取的直接是一个Quroum，但是是因为缺少共识，并且网络出现问题才会导致这样的情况出现。\n\n### 线性化的代价\n\n<font color=\"#FF0000\">线性化出现代价的最主要的原因还是因为网络的不确定性。</font>\n\n我们先用主从的架构来讨论这个问题，当网络发生分区的情况，主从不能够继续同步操作，可能会导致从库不可用。\n但是这个是我们需要实现线性化所带来的不可用\n\n先引入一个概念：CAP理论\n```\nCAP : 在同一个时间内，当网络出现分区的情况下，不可能获得兼容可用性和一致性。\n```\nCAP理论的推理：不要求线性化的应用更能够容忍网络分区。\n\n但是为了线性化，我们可能要牺牲性能和延迟。\n那么我们是否有方法可以做到线性化但是减少性能的牺牲呢？\n\n## <a id=\"2.2\"><span class=\"secondtitle\">顺序保证</span></a>\n我们刚刚在讨论线性化的时候使用到了寄存器的概念，那么顺序、可线性化、共识之间是否存在的某种关系呢？\n\n### <a id=\"2.2.1\"><span class=\"thirdtitle\">顺序、因果、全局序号的关系</span>\n#### <span class=\"fourth\">顺序和因果的关系</span>\n\n因果关系对所发生的事件添加了排序， 一件事情会导致另外一件事情，这些的因果关系依赖链条定义了系统中的因果顺序。如果符合因果关系所规定的顺序，我们称之为因果一致性。（快照隔离，在从数据库中读数据的情况下，查询到的诗句，也可以查到这个数据之前发生了什么的操作事件）\n\n#### <span class=\"fourth\">因果顺序并非全序</span>\n\n全序关系是可以支持两个不同的实体直接进行比较（如自然数集5和13的比较）  \n但是部分集合的对比不一定符合全序，集合{a,b} 与 集合{b,c}是无法进行对比的  \n\n因此，提炼到可线性化和因果关系中  \n可线性化是存在全序的操作关系，因为暴露对外的行为是与单副本无异，并且每个操作都是原子的。可以分出先后  \n因果是偏序的操作关系，对于并发的两个操作无法比较的情况下，就会发生冲突，对于可以比较的情况下，与线性无异。    \n那么可以这样说，可线性化一定意味着因果关系，因为可线性化是全序的操作。    \n但是可以这样理解，线性化并非是保证因果关系的唯一的途径。我们可以有其他手段去满足因果一致性而避免线性化所带来的问题。    \n因果一致性是被认为是不会由于网络延迟而显著影响性能，并且可以对网络故障容错提供容错的最强一致性的模型。  \n因为实际上很多的应用所需要的是因果一致性来保证应用的正确性。  \n\n#### <span class=\"fourth\">捕获因果依赖关系</span>\n如果只要解决并发操作的先后依赖关系。这里其实只需要由偏序的关系即可。\n我们常见的数据库的版本技术就是一个解决这个问题的方案之一\n为了确定数据库的因果关系，数据库需要知道应用读取的是哪个版本的数据。\n\n#### <span class=\"fourth\">序列号排序</span>\n那么，这样的情况下，我们是否需要显式的跟踪所有的因果关系呢？  \n为了性能的考虑，我们可以通过序列号和时间戳（尽量不使用物理时钟）来进行对事件排序，这样在保证性能的同时，也能够保证所有操作在全局的关系。但是要保证每个序列号必须唯一，并且可以比较。  \n我们可以按照与因果关系一致的顺序来创建序列号： 如果操作A发生B之前，那么A一定在全序顺序中出现在B之前    \n这样的全局排序可以捕获所有的因果信息，并且加强了比因果关系更为严格的顺序性  \n\n那么对于不存在唯一的主节点（多主或者无主），那么我们能怎样生成上面所提及的序列号呢？  \n有实践中可以采用以下方法：  \n    1. 每个节点单独生成自己的一组序列号。假设有两个节点，一个生成奇数，一个生成偶数  \n    2. 把Timestamp添加到操作中（之前生产中有用此种方式）  \n    3. 预先分配序列号的区间范围。（A节点分配1-1000，B节点分配1001-2000）  \n\n但是这三种实际上生成的唯一的，近似增加的序列号。但是实际上序列号和因果一致不是完全因果一致的。  \n为什么不是因果一致呢?  \n对于情况1，每个节点处理的速率是由不一致的，只要两个节点处于处理速率不一致的情况下，分配的ID必然和实际的顺序关系无法对应  \n对于情况2， 墙上时钟发生偏移的情况  \n对于情况3， 如果sharding的路由发生了变化之后，那么之前1-1000的因果关系就不存在了。  \n\n那么我们是否没有办法可以在非强主的情况可以获取一个序列号与因果一致可以对应上的吗？  \n\n我们还有一个方法！！！此处大神来了Leslie Lamport的Lamport TimeStamp可以解决这个问题  \n\n#### <span class=\"fourth\">LamportTimeStamp</span>\n![LamportTimeStamp](/assets/img/posts/LamportTimestamp.png)  \n每个节点一开始的时候都会有一个唯一的标识符（每次初始为0）， 然后每个节点都有一个计数器来记录各自处理的请求总数。到此与之前的时间戳的并无差别，但是Lamport这里处理的亮点出来了，每个节点和每个客户端都会跟踪迄今为止最大的计数器值，并且在每个请求中附带该最大计数器值。当节点收到某个请求的时候，如果发现请求内的最大计数器值大于自身的计数器值，会更新自己的计数器值（Raft中是通过投票和心跳的RPC来同步这个计数器的值，在Raft的概念里面叫做Term，后面讲解Raft的时候会进一步解析，此处只是一个插叙）。\n\nLamportTimeStamp好像是解决了分布式系统顺序号和因果一致的关系，但是是已经足够解决分布式系统中常见的问题了吗？  \n问题如下：  \n    一个系统的用户名只能由唯一的用户持有，两个用户并发地向系统同时进行注册，我们必须要保证一个成功，一个失败    \n虽然看上去我们是可以把两个请求通过编号把两个并发的请求变成了一个有顺序的问题，但是实际上要保证上面的是唯一的有两个前提：  \n    1. 节点收到用户请求的时候需要马上判断请求时成功还是失败  \n    2. 必须要收集系统的所有创建用户的请求，比较序号  \n但是这个显然是不可能的，只要网络出现问题了，我们就无法做到上面的两个问题。\n\n那么我们如果要知道全局关系是否确定，就需要提到后面的一个概念，全序关系广播\n\n### <a id=\"2.2.2\"><span class=\"thirdtitle\">全局关系的广播</span></a>\n继续先从一个主从复制的系统开始说起，主节点接受写请求并且变成顺序的操作。  \n但是在分布式系统领域，如何扩展系统的吞吐量使之突破单一主节点限制以及处理主节点失效时的故障切换。这类的问题被称为全序关系广播或者原子广播。  \n全序关系广播： 通常指节点之间交换信息的某种协议。有两个特性  \n    1. 可靠发送（没有消息丢失，如果消息发送到某一个节点，它一定要发送到其他的节点）  \n    2. 严格有序（消息总是以相同的顺序发送到每个节点）  \n\n#### <span class=\"fourth\">使用全序关系广播</span>\nZookeeper和Etcd的共识服务就实现了全序关系广播。（那么全序关系广播和共识之间的关系？）  \n\n全序关系广播就是数据库所需要，每条消息表达数据库的写请求，而且每个副本段相同的顺序处理这些写请求，那么所有副本可以保持一致。这个也被称为状态机复制。  \n\n全局关系广播的另一个要点，顺序在发送消息时已经是确定的，如果消息发送成功，节点不允许追溯将某条消息插到先前的位置上。只能进行追加，这样全序关系广播比时间戳的排序要求更强  \n应用场景：  \n    1.我们可以使用全序关系广播来实现可串行化的事务。（每个消息表示为一个确定性质的事务，并且作为存储过程来执行）    \n    2.提供Fencing令牌锁的服务（把取锁的请求变成一个消息追加到日志中，序列号直接可以变成令牌返回）  \n\n#### 全序关系广播来实现线性化存储\n全序关系广播是基于异步模型，保证消息以固定顺序的可靠发送，但是不保证消息何时发送成功，但是可线性化更多地强调读取时能看到最新的写入值。  \n我们可以通过追加的日志的方式使得使用全序关系广播在写入的方式上与可线性化做到一致  \n    1. 在接受请求的本地节点中追加一条消息，指明写入的信息  \n    2. 读取日志，广播到其他节点，等待回应  \n    3. 如果回复中有冲突，则失败，返回错误给客户端；否则返回成功给客户端  \n通过日志追加可以把并发有效的转换为多条的日志来保证因果顺序关系。但是读取却还没做到这个语义  \n为了读取可以与可线性化一致，有以下方法可以解决这个问题：\n    1. 把读的请求也变成日志的方式追加到排序广播，通过变成日志的情况下可以确定了顺序的问题。（ETCD采用的是这种方式）  \n    2. 如果可以以可线性化的方式获取最新日志的消息位置，则查询位置，直到该位置之前的所有条目读发送给你，再进行读取（ZooKeeper使用的方式）  \n    3. 可以从同步更新的副本中进行读取，保证每次读的是最新的值。  \n\n所以最终可线性化的原子地对寄存器做CAS的操作与全序关系广播其实等价于共识的问题。\n\n# <a id=\"Capability\"><span class=\"toptitle\">分布式共识的能力边界</span></a>\n共识： 使得分布式系统中就某件事情达成一致  \n共识的使用场景：  \n    1. 主节点选举（防止脑裂问题）  \n    2. 原子事务的提交（跨节点或分区的数据库，事务在部分节点成功，部分节点失败，需要进行回滚）  \n我们先从事务的原子性开始，讨论2PC（2阶段提交），之后再会谈及其他更好的共识算法的实现（ZooKeeper， Raft）  \n\n## <a id=\"3.1\"><span class=\"secondtitle\">分布式事务 </span></a>\n事务原子性的目的：  \n一个多笔写操作的事务在执行过程中出现意外情况，为上层应用提供一个简单的语义，全部成功或者全部失败  \n单机原子提交：  \n数据库把事务写入持久化部分，然后把提交记录追加写入到磁盘的日志文件中。所以在单节点上面，事务提交非常依赖与数据持久写入磁盘的顺序关系  \n    1. 先写入数据，再提交记录  \n    2. 事务提交或者中止的关键点在于磁盘完成日志的时候，在完成写之前崩溃的情况下，事务需要中止；如果日志在完成写入后发生崩溃，事务被安全提交  \n\n但是对于分布式多节点，处理方法有所差别，原因可能是以下这几个问题引起的  \n    1. 某些节点发现不满足要求中止了事务，但是部分节点通过并且提交    \n    2. 部分请求可能在网络不稳定的情况下丢失，超时而中止；但是其他请求可能成功提交  \n    3. 节点可能在写入日志前崩溃，而且在恢复后回滚（原来数据没有成功，回滚可能会出现问题）  \n如果一部分节点提交了事务，但是部分节点放弃了事务，会导致集群中节点信息的不一致，而且事务一旦被提交，即使事后发现其他节点中止，也无法撤销本节点的事务  \n\n事务提交后不能撤销的原因：   \n一旦数据提交，就会被其他事务可见，然后客户端（应用层）就会做出相应的反应，这个是构成读-提交隔离的基础。但是如果允许撤销的话，那么所有之后的读-提交级别的任务，然后会产生多级的级联式追溯和撤销。导致系统压力巨大甚至崩溃。并且不能保证数据是否能够准确落盘。  \n\n因为不允许撤销事务，因为如果一个错误的事务被提交了，必然需要一个新的事务来抵消它的影响，但是这个需要应用层来进行处理，就不符合我们需要给应用层提供的原子性。  \n\n### 2PC \n两阶段提交（2PC）是一种在多个节点上实现事务原子提交的算法。要么全部提交，要么全部不提交。\n\n##### 2PC的流程（为什么可以解决上面单阶段提交的问题）\n1. 应用启动分布式事务的时候，先去像协调者获取事务ID（全局唯一）\n2. 应用程序在每个参与的节点启动单节点事务，并且把事务ID附加到到参与者的事务上。如果这个阶段发生异常，可以协调者和其他参与者可以安全中止\n3. 应用程序准备提交事务时，协调者回向参与者发送携带事务ID准备请求，只要有一个发现失败的情况下，通知全部放弃事务\n4. 参与者收到请求后，确保自己时候可以提交事务（包括硬件故障和软件故障的确认），然后检查是否有冲突或者违规。一旦返回是，节点会承诺提交事务。（保证了参与者不会撤销事务）\n5. 当协调者收到所有的参与者返回后，要决定是否提交事务，并且把此决定写入到硬盘的事务日志（WAL）中，防止掉电后可能出现的异常\n6. 协调者向参与者发送提交/放弃 事物的请求，只要是提交，每个参与者会重试到成功为止(包括了进程崩溃的重试、节点重启等情况)\n\n所以他是在保证了上面的一个重要前提，只要提交了就不能撤回。\n在参与者在返回给协调者的时候保证了单向性\n并且协调者确定提交了之后也是保证了不可逆，因此保证了2pc可以不会出现那些异常的情况。\n\n但是2PC的单点在于协调者的问题（虽然可以采用共识层来写协调者保证高可用）但是整个过程中的热点也会出现在协调者上面。\n\n### 实际生产上面的分布式事务\n### 异构分布式事务\n虽然分布式事务因为这样可能会有阻塞而导致性能和吞吐量的下降，但是是否没有折中的方法来使用类似的语义呢？\n目前更多的是采用了异构的方法（如数据库+MQ）的执行异构的分布式事务\n\n对于异构形式的分布式事务，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息处理完毕。\n但只要其中一个出现失败的情况，两个部分都必须进行中止的操作。\n\n<b>保证消息可以有效处理有且仅有一次</b>\n\n目前有XA的异构的分布式事务的标准。\n\n## <a id=\"3.2\"><span class=\"secondtitle\">支持容错的共识</span></a>\n共识问题的形式化描述： 一个或者多个节点可以提议某些值，由共识算法来决定最终的值。\n\n基于上面的描述共识算法必须满足以下的性质：\n    1. 协商一致性（所有节点都接受相同的决议）\n    2. 诚实性（所有节点不能反悔，对某项提议不能有两次决定）\n    3. 合法性（决定了值V, 那么V肯定是由某个节点提议的）\n    4. 可终止性（如果节点不崩溃最终一定可以达成协议）\n\n协商一致性和诚实的属性定义了共识算法的核心思想：决定一致的结果，并且一旦决定就不能改变。  \n合法性是为了排除一些无意义的方案，  \n可终止性是容错的体现，避免了整个系统的空转  \n根据之前提及的： 可终止性是活性， 其他三个是安全方面的属性。\n\n因为共识算法的目的是解决在大多数节点正常的情况下正确运行才能确保终止性。\n\n### 共识算法和全序广播的关系\n\n共识算法(如Raft、Paxos、Zab)等都不是直接采用上述的形式化模型。而是决定了一系列的值，然后采用全序关系广播算法来进行实现。  \n\n全序关系广播要点： 消息按相同的顺序发送到所有的节点，有且只有一次。  \n这样的方式相当于多轮的共识过程。在每一轮，节点会提出之后需要发出的信息，然后决定下一个顺序。\n\n对于上面的提到的四个性质：\n1. 由于协商的一致性，所有节点决定以相同的顺序发送相同的消息。\n2. 由于诚实性，消息不会重复\n3. 由于合法性， 消息不会被破坏，也不是凭空捏造\n4. 由于可终止性，消息不会丢失\n\n### Epoch 和 Quorum\n\n对于共识算法来说，都采用了一个弱化的保证，定义了一个世代编号（Epoch）来确保每个世代里面，主节点是唯一的。\n如果发现当前主节点失效的情况，节点开始选举新一轮的主节点，Epoch号递增。在主节点做出任何决定的时候，都需要检查是否由比它更高的Epoch号码。\n主节点必须从Quorum中收集投票，并且把提议传送到各个节点中，等待节点的返回，当只要没有更高的Epoch主节点\n时，才会对当前的提议进行投票。\n\n此处其实是由两个操作组成：1. 选举主节点； 2.对主节点的提议进行投票\n\n注意的一点： 参与两轮的Quorum必须要由重合，这样才能保证主节点没有更高的Epoch，保证正确性。\n\n与2PC的差别， 2PC是需要协调者向每个参与者做出“是”的返回才能进行，而共识算法可以通过直接以集群的多数来确定是否通过决议\n\n### 共识算法的局限性\n\n共识算法虽然为分布式系统带来了好处，为一切不确定的系统带来了安全属性和容错性。并且可以通过全序关系广播以容错的方式实现线性化的原子操作。\n\n但是共识也是有代价的：\n1. 节点投票是一个同步复制过程，性能可能需要妥协（但是可以通过减少选举的频率来减少整个开销）\n2. 共识体系需要严格的多数节点才能执行，换句话来说，最少需要3个节点才能运行\n3. 多数的共识算法假定了一组固定的参与投票的节点集（主要是为了理解的方便）\n4. 共识算法需要依靠超时来对节点失败进行检测，但是可能会出现因为网络原因的误判导致经常切主，数据搬移多，对外的性能降低。\n5. 网络的影响较大，如果出现频繁切主的情况，可能会有长时间出现无法正常对外进行服务\n\n### 基于共识算法的成员与协调服务\n\n对于像ZooKeeper、Etcd这些分布式键值对的服务，暴露的API与数据库是十分类似的，但是为什么我们需要在共识层上面去构建这些服务呢？\n\n#### 作用\n这些分布式键值对数据库主要是针对保存少量，可完全载入内存的数据。采用容错的全序广播算法在所有节点上复制数据使得可以实现高可用的目标。\n1. 线性化的原子操作\n多个节点同时去获取锁，只有一个会成功，共识协议会保证操作满足原子性和线性化，即使节点出现部分失败的情况\n2. 操作全序\n之前分布式系统问题的文章有提及过Fencing令牌的问题，\n3. 故障检测\n客户端会与这些服务保持一个长连接，如果长时间重连失败的情况下，会把该客户端拥有的资源全部释放\n4. 更改通知\n客户端可以通过读取服务来发现其他的客户端的行为\n\n#### 对外的功能\n1. 节点任务分配\n计算作业调度系统(Yarn)，分区资源调度（如Multi-Raft中的ShardMaster)\n2. 服务发现\n解决云环境中服务启停而注册到的服务变更(consul提供的服务)\n3. 成员服务\n节点是否可用并且获取主节点\n\n### 如何验证一个线性化系统\n（此部分会结合Mit6.824和PingCap tikv 的线性化验证的代码阅读和文章来描述）\n\n\n# <a id=\"ShareNote\">ShareNote</a>\n1. [Dynamo](https://pdos.csail.mit.edu/6.824/papers/dynamo.pdf)\n2. [Riak](https://github.com/basho/riak_core)\n3. [Cassandra](http://cassandra.apache.org/)\n4. [数据密集型应用系统设计](https://book.douban.com/subject/30329536/)","slug":"distribute-system-consensus","published":1,"updated":"2021-01-21T06:13:40.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6h2epk0003eci51vj6gdyl","content":"<!-- ---\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 11:08:38 +0800'\ncategory: \nsummary: Distributed System Consistency and Consensus\nthumbnail: distributed-system.png\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#PromiseAbstraction\">分布式系统可以提供的若干保证和抽象机制</a><br>1.1 <a href=\"#1.1\">共识算法的意义</a>  </li>\n<li><a href=\"#atomic\">如何在分布式系统中做到原子性</a><br>2.1 <a href=\"#2.1\">可线性化</a><br>2.2 <a href=\"#2.2\">顺序化</a>  <pre><code> 2.2.1 [顺序、因果、全局序号的关系](#2.2.1)  \n 2.2.2 [全局关系的广播](#2.2.2)  </code></pre>\n</li>\n<li><a href=\"#Capability\">分布式系统的能力边界</a><br>3.1  <a href=\"#3.1\">分布式事务</a><br>3.2  <a href=\"#3.2\">容错的共识</a>  </li>\n<li><a href=\"#ShareNote\">ShareNote</a>  </li>\n</ol>\n\n        <h1 id=\"分布式系统可以提供的若干保证和抽象机制\"   >\n          <a href=\"#分布式系统可以提供的若干保证和抽象机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统可以提供的若干保证和抽象机制</h1>\n      \n        <h2 id=\"共识-分布式一致性-算法的意义\"   >\n          <a href=\"#共识-分布式一致性-算法的意义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识(分布式一致性)算法的意义</h2>\n      <p>对于大多数的多副本的数据库（N&gt;=2)的情况下，它至少达到了最终的一致性。但是因为只是最终，但是到达最终的状态的时间是未知的。<br>最终一致性的多副本数据状态（如Aurora、Riak、Cassandra）的不一致对于应用开发者是比较棘手，因为很多底层保证一致的东西需要挪动到应用层上面去添加规则来继续保证。并且导致测试和验证都会变得异常的困难</p>\n<p>基于上面的问题，我们可能需要找到一个更加强一致性的模型来进行构建，可以把应用层可能遇到的数据库不一致的问题封装起来。虽然可能会付出其他的代价（如性能下降、容错性差）</p>\n\n        <h3 id=\"与事务隔离的级别的差别\"   >\n          <a href=\"#与事务隔离的级别的差别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>与事务隔离的级别的差别</h3>\n      <p>共识与事务隔离都有类似与副本的概念（事务隔离是使用乐观锁（MVCC） 共识是使用多副本）<br>共识：更加强调是针对延时和故障协调副本之间的关系。<br>事务隔离：处理并发事务的各种临界的条件  </p>\n\n        <h1 id=\"如何在分布式系统中做到原子性\"   >\n          <a href=\"#如何在分布式系统中做到原子性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何在分布式系统中做到原子性</h1>\n      \n        <h2 id=\"可线性化\"   >\n          <a href=\"#可线性化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>可线性化</h2>\n      <p>（此部分主要是DDIA第9章节的内容）<br>定义： 让一个分布式的系统看起来像一个单副本的系统，并且所有的操作都是原子的。  </p>\n\n        <h3 id=\"一个非线性化的例子\"   >\n          <a href=\"#一个非线性化的例子\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>一个非线性化的例子</h3>\n      <p><img src=\"/assets/img/posts/non-linearized-example.png\" alt=\"非线性化图片\">  </p>\n<p>对于上面这个图的简要描述：<br>因为使用了多节点非强一致性的数据库，当Referee修改数据库的情况下，因为集群内同步的时间不一致，导致可能Alice先查的的Slave-1 已经修改了，但是Bob查询的Slave-2的库上面还没有修改，导致Alice和Bob获取到的结果不一致。这种场景对于一些一致性需求比较强的情况下不能接受。</p>\n\n        <h3 id=\"线性化的例子的直觉表达\"   >\n          <a href=\"#线性化的例子的直觉表达\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>线性化的例子的直觉表达</h3>\n      <p><b><font color=\"#FF0000\">线性化的简洁但是事实上的描述： 让分布式系统具有寄存器的语义。</font></b><br>对于这个部分，我们详细去探讨一下<br>一般我们的对于读写请求并发（在客户端的角度）是这样的:<br>定义一个前提， 下图中的一个框是指客户端从发出请求到接收到返回值的整个过程<br>单个框可以理解为 客户端发出请求-&gt; 服务器端接受并且处理请求-&gt; 服务器端返回结果-&gt; 客户端在应用级别收到返回<br>下面可能出现框比较长的情况是在上一篇文章（<img src=\"https://ray1888.github.io/distributed-system/2019/08/20/chanllange-of-distributed-system/\" alt=\"分布式系统简介以及其问题\">）的假设所提及的情况，此处不再复述。  </p>\n<p>分布式系统中的寄存器： 线性化数据库中的相同的主键。（此处为X)<br><img src=\"/assets/img/posts/generate-line.png\" alt=\"粗粒度线性一致\"><br>此处对于寄存器有两类的操作：</p>\n<ol>\n<li>read(x)  读取主键为X的值，数据库返回值v</li>\n<li>write(x,v) 客户端把X的值更新为V，数据库返回值为r(成功或者失败)</li>\n</ol>\n<p>对于上图在read和write重合的过程中，read的结果可能有2种情况：  </p>\n<ol>\n<li>read在write完成之前结束(返回0)  </li>\n<li>read在write完成之后结束 (返回1)  </li>\n</ol>\n<p>但是这个描述的粒度还是比较大，为了把系统线性化的更好的描述，我们添加下面的约束<br><img src=\"/assets/img/posts/more-detail-line.png\" alt=\"细粒度线性一致\">  </p>\n<p>约束为，在写操作的过程中，肯定有某一个时间点，存储上面的x的值会出现冲0到1的跳变。<br>对于上图， 客户端A在某个节点能够读到X的值为1，那么因为客户端B的读操作是晚于客户端A读的发生的，因此<br>客户端B获取到的值也必然是1（如果不是1，则不是可线性化的系统）。<br><img src=\"/assets/img/posts/line-final.png\" alt=\"线性一致\"><br>但是上面的讨论颗粒还是太大了，此处我们加入进去存储，以及存储接收到的操作来整体观察线性一致。<br>我们此处引入一个概念</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAS(compare and swap):一个原子的比较设置操作。编程语言中一般都要实现此概念，此处不详细叙述</span><br></pre></td></tr></table></div></figure>\n<p>并且添加一个假设：即使客户端可能还没有收到成功的响应，但是分布式的存储已经全部同步成新的值。<br>上图中每个操作都有竖线，表示可能的执行的时间点，把这些点连接起来，最终结果必须是一个有效的寄存器读写顺序。<br>可线性化的要求： 按时间箭头向前移动，不能向后移动。<br>可以看到上图中，最后客户端A的操作在c的Cas操作完成后，x的值已经变成了4，但是如果发现读的值为2的话，按时间线的理解就是错误了。因为根据可线性化的要求，cas操作已经执行了，并且时间只能向前走的情况下，客户端A的读操作必然是需要返回4的。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;可线性化和可串行化的对比</span><br><span class=\"line\">#### 可线性化</span><br><span class=\"line\">对寄存器（单个对象）的最新值保证。他不要求将操作组合到事务中，可能会出现写倾斜的问题（如果不采取手段去解决的问题）</span><br><span class=\"line\">#### 可串行化</span><br><span class=\"line\">是事务的隔离属性。每个事务可以读写多个对象，用于确保事务执行的结果与串行执行相同。即使穿行执行的顺序和实际执行的顺序并不一定相同（可能实际上的执行是并行执行事务，但是对外暴露的结果是一致的就可以）  </span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"需要用到线性化的使用场景\"   >\n          <a href=\"#需要用到线性化的使用场景\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>需要用到线性化的使用场景</h3>\n      <ol>\n<li>加锁与主节点选举<br>对于主从复制系统的选主问题，可以通过基于Etcd或者ZooKeeper来进行抢锁操作控制选主</li>\n<li>约束与唯一性保证<br>应用中对同一个资源（如用户名）的唯一性的约束。（可以延展到数据表的主键约束）</li>\n<li>多信息源的时间依赖<br>对于一些异步任务系统虽然采用了最终一致性，但是可能也是会因为实现产生数据的依赖问题。</li>\n</ol>\n\n        <h3 id=\"如何实现一个线性化系统\"   >\n          <a href=\"#如何实现一个线性化系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何实现一个线性化系统</h3>\n      \n        <h4 id=\"对比多种可能使用的方案来确定\"   >\n          <a href=\"#对比多种可能使用的方案来确定\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对比多种可能使用的方案来确定</h4>\n      <p>在考虑容错的基础上，必须考虑复制的机制。我们可以对比多种复制方案来看看那种可以实现线性化</p>\n<ol>\n<li>主从复制。（部分线性化）<br>因为所有写入操作都是从主节点继续，并且把操作同步到从节点上面。但是问题可能出现在实现的问题上：  <ol>\n<li>实时同步可能会出现问题</li>\n<li>可能会因为快照隔离设计出现问题</li>\n</ol>\n</li>\n<li>共识算法（可线性化）<br>类似于主从复制，但是通过一些手段来防止脑裂和过期的副本</li>\n<li>多主复制（不可线性化）<br>当允许并发写入的时候，如果进行异步复制的话，可能会出现数据的冲突。</li>\n<li>无主复制（可能不可线性化）<br>类似于Dynamo的机制，即使使用了Quroum机制，但是如果选取的Quroum不一定是满足的情况下，可能会出现非线性化的处理</li>\n</ol>\n<p>此处提出一个问题，是否只要有Quroum机制（就必定可以支持线性一致呢？）<br>答： 不一定。用下面的例子进行解释  </p>\n<p><img src=\"/assets/img/posts/quroum-fail.png\" alt=\"QuroumFail\"><br>对于上图中，即使是使用了Quroum，但是没有共识算法的支持，还是可能会出现类似于之前Alice和Bob遇到的情况的问题。但是这个选取的直接是一个Quroum，但是是因为缺少共识，并且网络出现问题才会导致这样的情况出现。</p>\n\n        <h3 id=\"线性化的代价\"   >\n          <a href=\"#线性化的代价\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>线性化的代价</h3>\n      <p><font color=\"#FF0000\">线性化出现代价的最主要的原因还是因为网络的不确定性。</font></p>\n<p>我们先用主从的架构来讨论这个问题，当网络发生分区的情况，主从不能够继续同步操作，可能会导致从库不可用。<br>但是这个是我们需要实现线性化所带来的不可用</p>\n<p>先引入一个概念：CAP理论</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAP : 在同一个时间内，当网络出现分区的情况下，不可能获得兼容可用性和一致性。</span><br></pre></td></tr></table></div></figure>\n<p>CAP理论的推理：不要求线性化的应用更能够容忍网络分区。</p>\n<p>但是为了线性化，我们可能要牺牲性能和延迟。<br>那么我们是否有方法可以做到线性化但是减少性能的牺牲呢？</p>\n\n        <h2 id=\"顺序保证\"   >\n          <a href=\"#顺序保证\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序保证</h2>\n      <p>我们刚刚在讨论线性化的时候使用到了寄存器的概念，那么顺序、可线性化、共识之间是否存在的某种关系呢？</p>\n\n        <h3 id=\"顺序、因果、全局序号的关系\"   >\n          <a href=\"#顺序、因果、全局序号的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序、因果、全局序号的关系</h3>\n      \n        <h4 id=\"顺序和因果的关系\"   >\n          <a href=\"#顺序和因果的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序和因果的关系</h4>\n      <p>因果关系对所发生的事件添加了排序， 一件事情会导致另外一件事情，这些的因果关系依赖链条定义了系统中的因果顺序。如果符合因果关系所规定的顺序，我们称之为因果一致性。（快照隔离，在从数据库中读数据的情况下，查询到的诗句，也可以查到这个数据之前发生了什么的操作事件）</p>\n\n        <h4 id=\"因果顺序并非全序\"   >\n          <a href=\"#因果顺序并非全序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>因果顺序并非全序</h4>\n      <p>全序关系是可以支持两个不同的实体直接进行比较（如自然数集5和13的比较）<br>但是部分集合的对比不一定符合全序，集合{a,b} 与 集合{b,c}是无法进行对比的  </p>\n<p>因此，提炼到可线性化和因果关系中<br>可线性化是存在全序的操作关系，因为暴露对外的行为是与单副本无异，并且每个操作都是原子的。可以分出先后<br>因果是偏序的操作关系，对于并发的两个操作无法比较的情况下，就会发生冲突，对于可以比较的情况下，与线性无异。<br>那么可以这样说，可线性化一定意味着因果关系，因为可线性化是全序的操作。<br>但是可以这样理解，线性化并非是保证因果关系的唯一的途径。我们可以有其他手段去满足因果一致性而避免线性化所带来的问题。<br>因果一致性是被认为是不会由于网络延迟而显著影响性能，并且可以对网络故障容错提供容错的最强一致性的模型。<br>因为实际上很多的应用所需要的是因果一致性来保证应用的正确性。  </p>\n\n        <h4 id=\"捕获因果依赖关系\"   >\n          <a href=\"#捕获因果依赖关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>捕获因果依赖关系</h4>\n      <p>如果只要解决并发操作的先后依赖关系。这里其实只需要由偏序的关系即可。<br>我们常见的数据库的版本技术就是一个解决这个问题的方案之一<br>为了确定数据库的因果关系，数据库需要知道应用读取的是哪个版本的数据。</p>\n\n        <h4 id=\"序列号排序\"   >\n          <a href=\"#序列号排序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>序列号排序</h4>\n      <p>那么，这样的情况下，我们是否需要显式的跟踪所有的因果关系呢？<br>为了性能的考虑，我们可以通过序列号和时间戳（尽量不使用物理时钟）来进行对事件排序，这样在保证性能的同时，也能够保证所有操作在全局的关系。但是要保证每个序列号必须唯一，并且可以比较。<br>我们可以按照与因果关系一致的顺序来创建序列号： 如果操作A发生B之前，那么A一定在全序顺序中出现在B之前<br>这样的全局排序可以捕获所有的因果信息，并且加强了比因果关系更为严格的顺序性  </p>\n<p>那么对于不存在唯一的主节点（多主或者无主），那么我们能怎样生成上面所提及的序列号呢？<br>有实践中可以采用以下方法：<br>    1. 每个节点单独生成自己的一组序列号。假设有两个节点，一个生成奇数，一个生成偶数<br>    2. 把Timestamp添加到操作中（之前生产中有用此种方式）<br>    3. 预先分配序列号的区间范围。（A节点分配1-1000，B节点分配1001-2000）  </p>\n<p>但是这三种实际上生成的唯一的，近似增加的序列号。但是实际上序列号和因果一致不是完全因果一致的。<br>为什么不是因果一致呢?<br>对于情况1，每个节点处理的速率是由不一致的，只要两个节点处于处理速率不一致的情况下，分配的ID必然和实际的顺序关系无法对应<br>对于情况2， 墙上时钟发生偏移的情况<br>对于情况3， 如果sharding的路由发生了变化之后，那么之前1-1000的因果关系就不存在了。  </p>\n<p>那么我们是否没有办法可以在非强主的情况可以获取一个序列号与因果一致可以对应上的吗？  </p>\n<p>我们还有一个方法！！！此处大神来了Leslie Lamport的Lamport TimeStamp可以解决这个问题  </p>\n\n        <h4 id=\"LamportTimeStamp\"   >\n          <a href=\"#LamportTimeStamp\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>LamportTimeStamp</h4>\n      <p><img src=\"/assets/img/posts/LamportTimestamp.png\" alt=\"LamportTimeStamp\"><br>每个节点一开始的时候都会有一个唯一的标识符（每次初始为0）， 然后每个节点都有一个计数器来记录各自处理的请求总数。到此与之前的时间戳的并无差别，但是Lamport这里处理的亮点出来了，每个节点和每个客户端都会跟踪迄今为止最大的计数器值，并且在每个请求中附带该最大计数器值。当节点收到某个请求的时候，如果发现请求内的最大计数器值大于自身的计数器值，会更新自己的计数器值（Raft中是通过投票和心跳的RPC来同步这个计数器的值，在Raft的概念里面叫做Term，后面讲解Raft的时候会进一步解析，此处只是一个插叙）。</p>\n<p>LamportTimeStamp好像是解决了分布式系统顺序号和因果一致的关系，但是是已经足够解决分布式系统中常见的问题了吗？<br>问题如下：<br>    一个系统的用户名只能由唯一的用户持有，两个用户并发地向系统同时进行注册，我们必须要保证一个成功，一个失败<br>虽然看上去我们是可以把两个请求通过编号把两个并发的请求变成了一个有顺序的问题，但是实际上要保证上面的是唯一的有两个前提：<br>    1. 节点收到用户请求的时候需要马上判断请求时成功还是失败<br>    2. 必须要收集系统的所有创建用户的请求，比较序号<br>但是这个显然是不可能的，只要网络出现问题了，我们就无法做到上面的两个问题。</p>\n<p>那么我们如果要知道全局关系是否确定，就需要提到后面的一个概念，全序关系广播</p>\n\n        <h3 id=\"全局关系的广播\"   >\n          <a href=\"#全局关系的广播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>全局关系的广播</h3>\n      <p>继续先从一个主从复制的系统开始说起，主节点接受写请求并且变成顺序的操作。<br>但是在分布式系统领域，如何扩展系统的吞吐量使之突破单一主节点限制以及处理主节点失效时的故障切换。这类的问题被称为全序关系广播或者原子广播。<br>全序关系广播： 通常指节点之间交换信息的某种协议。有两个特性<br>    1. 可靠发送（没有消息丢失，如果消息发送到某一个节点，它一定要发送到其他的节点）<br>    2. 严格有序（消息总是以相同的顺序发送到每个节点）  </p>\n\n        <h4 id=\"使用全序关系广播\"   >\n          <a href=\"#使用全序关系广播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用全序关系广播</h4>\n      <p>Zookeeper和Etcd的共识服务就实现了全序关系广播。（那么全序关系广播和共识之间的关系？）  </p>\n<p>全序关系广播就是数据库所需要，每条消息表达数据库的写请求，而且每个副本段相同的顺序处理这些写请求，那么所有副本可以保持一致。这个也被称为状态机复制。  </p>\n<p>全局关系广播的另一个要点，顺序在发送消息时已经是确定的，如果消息发送成功，节点不允许追溯将某条消息插到先前的位置上。只能进行追加，这样全序关系广播比时间戳的排序要求更强<br>应用场景：<br>    1.我们可以使用全序关系广播来实现可串行化的事务。（每个消息表示为一个确定性质的事务，并且作为存储过程来执行）<br>    2.提供Fencing令牌锁的服务（把取锁的请求变成一个消息追加到日志中，序列号直接可以变成令牌返回）  </p>\n\n        <h4 id=\"全序关系广播来实现线性化存储\"   >\n          <a href=\"#全序关系广播来实现线性化存储\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>全序关系广播来实现线性化存储</h4>\n      <p>全序关系广播是基于异步模型，保证消息以固定顺序的可靠发送，但是不保证消息何时发送成功，但是可线性化更多地强调读取时能看到最新的写入值。<br>我们可以通过追加的日志的方式使得使用全序关系广播在写入的方式上与可线性化做到一致<br>    1. 在接受请求的本地节点中追加一条消息，指明写入的信息<br>    2. 读取日志，广播到其他节点，等待回应<br>    3. 如果回复中有冲突，则失败，返回错误给客户端；否则返回成功给客户端<br>通过日志追加可以把并发有效的转换为多条的日志来保证因果顺序关系。但是读取却还没做到这个语义<br>为了读取可以与可线性化一致，有以下方法可以解决这个问题：<br>    1. 把读的请求也变成日志的方式追加到排序广播，通过变成日志的情况下可以确定了顺序的问题。（ETCD采用的是这种方式）<br>    2. 如果可以以可线性化的方式获取最新日志的消息位置，则查询位置，直到该位置之前的所有条目读发送给你，再进行读取（ZooKeeper使用的方式）<br>    3. 可以从同步更新的副本中进行读取，保证每次读的是最新的值。  </p>\n<p>所以最终可线性化的原子地对寄存器做CAS的操作与全序关系广播其实等价于共识的问题。</p>\n\n        <h1 id=\"分布式共识的能力边界\"   >\n          <a href=\"#分布式共识的能力边界\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识的能力边界</h1>\n      <p>共识： 使得分布式系统中就某件事情达成一致<br>共识的使用场景：<br>    1. 主节点选举（防止脑裂问题）<br>    2. 原子事务的提交（跨节点或分区的数据库，事务在部分节点成功，部分节点失败，需要进行回滚）<br>我们先从事务的原子性开始，讨论2PC（2阶段提交），之后再会谈及其他更好的共识算法的实现（ZooKeeper， Raft）  </p>\n\n        <h2 id=\"分布式事务\"   >\n          <a href=\"#分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式事务</h2>\n      <p>事务原子性的目的：<br>一个多笔写操作的事务在执行过程中出现意外情况，为上层应用提供一个简单的语义，全部成功或者全部失败<br>单机原子提交：<br>数据库把事务写入持久化部分，然后把提交记录追加写入到磁盘的日志文件中。所以在单节点上面，事务提交非常依赖与数据持久写入磁盘的顺序关系<br>    1. 先写入数据，再提交记录<br>    2. 事务提交或者中止的关键点在于磁盘完成日志的时候，在完成写之前崩溃的情况下，事务需要中止；如果日志在完成写入后发生崩溃，事务被安全提交  </p>\n<p>但是对于分布式多节点，处理方法有所差别，原因可能是以下这几个问题引起的<br>    1. 某些节点发现不满足要求中止了事务，但是部分节点通过并且提交<br>    2. 部分请求可能在网络不稳定的情况下丢失，超时而中止；但是其他请求可能成功提交<br>    3. 节点可能在写入日志前崩溃，而且在恢复后回滚（原来数据没有成功，回滚可能会出现问题）<br>如果一部分节点提交了事务，但是部分节点放弃了事务，会导致集群中节点信息的不一致，而且事务一旦被提交，即使事后发现其他节点中止，也无法撤销本节点的事务  </p>\n<p>事务提交后不能撤销的原因：<br>一旦数据提交，就会被其他事务可见，然后客户端（应用层）就会做出相应的反应，这个是构成读-提交隔离的基础。但是如果允许撤销的话，那么所有之后的读-提交级别的任务，然后会产生多级的级联式追溯和撤销。导致系统压力巨大甚至崩溃。并且不能保证数据是否能够准确落盘。  </p>\n<p>因为不允许撤销事务，因为如果一个错误的事务被提交了，必然需要一个新的事务来抵消它的影响，但是这个需要应用层来进行处理，就不符合我们需要给应用层提供的原子性。  </p>\n\n        <h3 id=\"2PC\"   >\n          <a href=\"#2PC\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2PC</h3>\n      <p>两阶段提交（2PC）是一种在多个节点上实现事务原子提交的算法。要么全部提交，要么全部不提交。</p>\n\n        <h5 id=\"2PC的流程（为什么可以解决上面单阶段提交的问题）\"   >\n          <a href=\"#2PC的流程（为什么可以解决上面单阶段提交的问题）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2PC的流程（为什么可以解决上面单阶段提交的问题）</h5>\n      <ol>\n<li>应用启动分布式事务的时候，先去像协调者获取事务ID（全局唯一）</li>\n<li>应用程序在每个参与的节点启动单节点事务，并且把事务ID附加到到参与者的事务上。如果这个阶段发生异常，可以协调者和其他参与者可以安全中止</li>\n<li>应用程序准备提交事务时，协调者回向参与者发送携带事务ID准备请求，只要有一个发现失败的情况下，通知全部放弃事务</li>\n<li>参与者收到请求后，确保自己时候可以提交事务（包括硬件故障和软件故障的确认），然后检查是否有冲突或者违规。一旦返回是，节点会承诺提交事务。（保证了参与者不会撤销事务）</li>\n<li>当协调者收到所有的参与者返回后，要决定是否提交事务，并且把此决定写入到硬盘的事务日志（WAL）中，防止掉电后可能出现的异常</li>\n<li>协调者向参与者发送提交/放弃 事物的请求，只要是提交，每个参与者会重试到成功为止(包括了进程崩溃的重试、节点重启等情况)</li>\n</ol>\n<p>所以他是在保证了上面的一个重要前提，只要提交了就不能撤回。<br>在参与者在返回给协调者的时候保证了单向性<br>并且协调者确定提交了之后也是保证了不可逆，因此保证了2pc可以不会出现那些异常的情况。</p>\n<p>但是2PC的单点在于协调者的问题（虽然可以采用共识层来写协调者保证高可用）但是整个过程中的热点也会出现在协调者上面。</p>\n\n        <h3 id=\"实际生产上面的分布式事务\"   >\n          <a href=\"#实际生产上面的分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实际生产上面的分布式事务</h3>\n      \n        <h3 id=\"异构分布式事务\"   >\n          <a href=\"#异构分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>异构分布式事务</h3>\n      <p>虽然分布式事务因为这样可能会有阻塞而导致性能和吞吐量的下降，但是是否没有折中的方法来使用类似的语义呢？<br>目前更多的是采用了异构的方法（如数据库+MQ）的执行异构的分布式事务</p>\n<p>对于异构形式的分布式事务，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息处理完毕。<br>但只要其中一个出现失败的情况，两个部分都必须进行中止的操作。</p>\n<p><b>保证消息可以有效处理有且仅有一次</b></p>\n<p>目前有XA的异构的分布式事务的标准。</p>\n\n        <h2 id=\"支持容错的共识\"   >\n          <a href=\"#支持容错的共识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>支持容错的共识</h2>\n      <p>共识问题的形式化描述： 一个或者多个节点可以提议某些值，由共识算法来决定最终的值。</p>\n<p>基于上面的描述共识算法必须满足以下的性质：<br>    1. 协商一致性（所有节点都接受相同的决议）<br>    2. 诚实性（所有节点不能反悔，对某项提议不能有两次决定）<br>    3. 合法性（决定了值V, 那么V肯定是由某个节点提议的）<br>    4. 可终止性（如果节点不崩溃最终一定可以达成协议）</p>\n<p>协商一致性和诚实的属性定义了共识算法的核心思想：决定一致的结果，并且一旦决定就不能改变。<br>合法性是为了排除一些无意义的方案，<br>可终止性是容错的体现，避免了整个系统的空转<br>根据之前提及的： 可终止性是活性， 其他三个是安全方面的属性。</p>\n<p>因为共识算法的目的是解决在大多数节点正常的情况下正确运行才能确保终止性。</p>\n\n        <h3 id=\"共识算法和全序广播的关系\"   >\n          <a href=\"#共识算法和全序广播的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识算法和全序广播的关系</h3>\n      <p>共识算法(如Raft、Paxos、Zab)等都不是直接采用上述的形式化模型。而是决定了一系列的值，然后采用全序关系广播算法来进行实现。  </p>\n<p>全序关系广播要点： 消息按相同的顺序发送到所有的节点，有且只有一次。<br>这样的方式相当于多轮的共识过程。在每一轮，节点会提出之后需要发出的信息，然后决定下一个顺序。</p>\n<p>对于上面的提到的四个性质：</p>\n<ol>\n<li>由于协商的一致性，所有节点决定以相同的顺序发送相同的消息。</li>\n<li>由于诚实性，消息不会重复</li>\n<li>由于合法性， 消息不会被破坏，也不是凭空捏造</li>\n<li>由于可终止性，消息不会丢失</li>\n</ol>\n\n        <h3 id=\"Epoch-和-Quorum\"   >\n          <a href=\"#Epoch-和-Quorum\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Epoch 和 Quorum</h3>\n      <p>对于共识算法来说，都采用了一个弱化的保证，定义了一个世代编号（Epoch）来确保每个世代里面，主节点是唯一的。<br>如果发现当前主节点失效的情况，节点开始选举新一轮的主节点，Epoch号递增。在主节点做出任何决定的时候，都需要检查是否由比它更高的Epoch号码。<br>主节点必须从Quorum中收集投票，并且把提议传送到各个节点中，等待节点的返回，当只要没有更高的Epoch主节点<br>时，才会对当前的提议进行投票。</p>\n<p>此处其实是由两个操作组成：1. 选举主节点； 2.对主节点的提议进行投票</p>\n<p>注意的一点： 参与两轮的Quorum必须要由重合，这样才能保证主节点没有更高的Epoch，保证正确性。</p>\n<p>与2PC的差别， 2PC是需要协调者向每个参与者做出“是”的返回才能进行，而共识算法可以通过直接以集群的多数来确定是否通过决议</p>\n\n        <h3 id=\"共识算法的局限性\"   >\n          <a href=\"#共识算法的局限性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识算法的局限性</h3>\n      <p>共识算法虽然为分布式系统带来了好处，为一切不确定的系统带来了安全属性和容错性。并且可以通过全序关系广播以容错的方式实现线性化的原子操作。</p>\n<p>但是共识也是有代价的：</p>\n<ol>\n<li>节点投票是一个同步复制过程，性能可能需要妥协（但是可以通过减少选举的频率来减少整个开销）</li>\n<li>共识体系需要严格的多数节点才能执行，换句话来说，最少需要3个节点才能运行</li>\n<li>多数的共识算法假定了一组固定的参与投票的节点集（主要是为了理解的方便）</li>\n<li>共识算法需要依靠超时来对节点失败进行检测，但是可能会出现因为网络原因的误判导致经常切主，数据搬移多，对外的性能降低。</li>\n<li>网络的影响较大，如果出现频繁切主的情况，可能会有长时间出现无法正常对外进行服务</li>\n</ol>\n\n        <h3 id=\"基于共识算法的成员与协调服务\"   >\n          <a href=\"#基于共识算法的成员与协调服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基于共识算法的成员与协调服务</h3>\n      <p>对于像ZooKeeper、Etcd这些分布式键值对的服务，暴露的API与数据库是十分类似的，但是为什么我们需要在共识层上面去构建这些服务呢？</p>\n\n        <h4 id=\"作用\"   >\n          <a href=\"#作用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>作用</h4>\n      <p>这些分布式键值对数据库主要是针对保存少量，可完全载入内存的数据。采用容错的全序广播算法在所有节点上复制数据使得可以实现高可用的目标。</p>\n<ol>\n<li>线性化的原子操作<br>多个节点同时去获取锁，只有一个会成功，共识协议会保证操作满足原子性和线性化，即使节点出现部分失败的情况</li>\n<li>操作全序<br>之前分布式系统问题的文章有提及过Fencing令牌的问题，</li>\n<li>故障检测<br>客户端会与这些服务保持一个长连接，如果长时间重连失败的情况下，会把该客户端拥有的资源全部释放</li>\n<li>更改通知<br>客户端可以通过读取服务来发现其他的客户端的行为</li>\n</ol>\n\n        <h4 id=\"对外的功能\"   >\n          <a href=\"#对外的功能\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对外的功能</h4>\n      <ol>\n<li>节点任务分配<br>计算作业调度系统(Yarn)，分区资源调度（如Multi-Raft中的ShardMaster)</li>\n<li>服务发现<br>解决云环境中服务启停而注册到的服务变更(consul提供的服务)</li>\n<li>成员服务<br>节点是否可用并且获取主节点</li>\n</ol>\n\n        <h3 id=\"如何验证一个线性化系统\"   >\n          <a href=\"#如何验证一个线性化系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何验证一个线性化系统</h3>\n      <p>（此部分会结合Mit6.824和PingCap tikv 的线性化验证的代码阅读和文章来描述）</p>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://pdos.csail.mit.edu/6.824/papers/dynamo.pdf\" >Dynamo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/basho/riak_core\" >Riak</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://cassandra.apache.org/\" >Cassandra</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://book.douban.com/subject/30329536/\" >数据密集型应用系统设计</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<!-- ---\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 11:08:38 +0800'\ncategory: \nsummary: Distributed System Consistency and Consensus\nthumbnail: distributed-system.png\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#PromiseAbstraction\">分布式系统可以提供的若干保证和抽象机制</a><br>1.1 <a href=\"#1.1\">共识算法的意义</a>  </li>\n<li><a href=\"#atomic\">如何在分布式系统中做到原子性</a><br>2.1 <a href=\"#2.1\">可线性化</a><br>2.2 <a href=\"#2.2\">顺序化</a>  <pre><code> 2.2.1 [顺序、因果、全局序号的关系](#2.2.1)  \n 2.2.2 [全局关系的广播](#2.2.2)  </code></pre>\n</li>\n<li><a href=\"#Capability\">分布式系统的能力边界</a><br>3.1  <a href=\"#3.1\">分布式事务</a><br>3.2  <a href=\"#3.2\">容错的共识</a>  </li>\n<li><a href=\"#ShareNote\">ShareNote</a>  </li>\n</ol>\n\n        <h1 id=\"分布式系统可以提供的若干保证和抽象机制\"   >\n          <a href=\"#分布式系统可以提供的若干保证和抽象机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统可以提供的若干保证和抽象机制</h1>\n      \n        <h2 id=\"共识-分布式一致性-算法的意义\"   >\n          <a href=\"#共识-分布式一致性-算法的意义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识(分布式一致性)算法的意义</h2>\n      <p>对于大多数的多副本的数据库（N&gt;=2)的情况下，它至少达到了最终的一致性。但是因为只是最终，但是到达最终的状态的时间是未知的。<br>最终一致性的多副本数据状态（如Aurora、Riak、Cassandra）的不一致对于应用开发者是比较棘手，因为很多底层保证一致的东西需要挪动到应用层上面去添加规则来继续保证。并且导致测试和验证都会变得异常的困难</p>\n<p>基于上面的问题，我们可能需要找到一个更加强一致性的模型来进行构建，可以把应用层可能遇到的数据库不一致的问题封装起来。虽然可能会付出其他的代价（如性能下降、容错性差）</p>\n\n        <h3 id=\"与事务隔离的级别的差别\"   >\n          <a href=\"#与事务隔离的级别的差别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>与事务隔离的级别的差别</h3>\n      <p>共识与事务隔离都有类似与副本的概念（事务隔离是使用乐观锁（MVCC） 共识是使用多副本）<br>共识：更加强调是针对延时和故障协调副本之间的关系。<br>事务隔离：处理并发事务的各种临界的条件  </p>\n\n        <h1 id=\"如何在分布式系统中做到原子性\"   >\n          <a href=\"#如何在分布式系统中做到原子性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何在分布式系统中做到原子性</h1>\n      \n        <h2 id=\"可线性化\"   >\n          <a href=\"#可线性化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>可线性化</h2>\n      <p>（此部分主要是DDIA第9章节的内容）<br>定义： 让一个分布式的系统看起来像一个单副本的系统，并且所有的操作都是原子的。  </p>\n\n        <h3 id=\"一个非线性化的例子\"   >\n          <a href=\"#一个非线性化的例子\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>一个非线性化的例子</h3>\n      <p><img src=\"/assets/img/posts/non-linearized-example.png\" alt=\"非线性化图片\">  </p>\n<p>对于上面这个图的简要描述：<br>因为使用了多节点非强一致性的数据库，当Referee修改数据库的情况下，因为集群内同步的时间不一致，导致可能Alice先查的的Slave-1 已经修改了，但是Bob查询的Slave-2的库上面还没有修改，导致Alice和Bob获取到的结果不一致。这种场景对于一些一致性需求比较强的情况下不能接受。</p>\n\n        <h3 id=\"线性化的例子的直觉表达\"   >\n          <a href=\"#线性化的例子的直觉表达\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>线性化的例子的直觉表达</h3>\n      <p><b><font color=\"#FF0000\">线性化的简洁但是事实上的描述： 让分布式系统具有寄存器的语义。</font></b><br>对于这个部分，我们详细去探讨一下<br>一般我们的对于读写请求并发（在客户端的角度）是这样的:<br>定义一个前提， 下图中的一个框是指客户端从发出请求到接收到返回值的整个过程<br>单个框可以理解为 客户端发出请求-&gt; 服务器端接受并且处理请求-&gt; 服务器端返回结果-&gt; 客户端在应用级别收到返回<br>下面可能出现框比较长的情况是在上一篇文章（<img src=\"https://ray1888.github.io/distributed-system/2019/08/20/chanllange-of-distributed-system/\" alt=\"分布式系统简介以及其问题\">）的假设所提及的情况，此处不再复述。  </p>\n<p>分布式系统中的寄存器： 线性化数据库中的相同的主键。（此处为X)<br><img src=\"/assets/img/posts/generate-line.png\" alt=\"粗粒度线性一致\"><br>此处对于寄存器有两类的操作：</p>\n<ol>\n<li>read(x)  读取主键为X的值，数据库返回值v</li>\n<li>write(x,v) 客户端把X的值更新为V，数据库返回值为r(成功或者失败)</li>\n</ol>\n<p>对于上图在read和write重合的过程中，read的结果可能有2种情况：  </p>\n<ol>\n<li>read在write完成之前结束(返回0)  </li>\n<li>read在write完成之后结束 (返回1)  </li>\n</ol>\n<p>但是这个描述的粒度还是比较大，为了把系统线性化的更好的描述，我们添加下面的约束<br><img src=\"/assets/img/posts/more-detail-line.png\" alt=\"细粒度线性一致\">  </p>\n<p>约束为，在写操作的过程中，肯定有某一个时间点，存储上面的x的值会出现冲0到1的跳变。<br>对于上图， 客户端A在某个节点能够读到X的值为1，那么因为客户端B的读操作是晚于客户端A读的发生的，因此<br>客户端B获取到的值也必然是1（如果不是1，则不是可线性化的系统）。<br><img src=\"/assets/img/posts/line-final.png\" alt=\"线性一致\"><br>但是上面的讨论颗粒还是太大了，此处我们加入进去存储，以及存储接收到的操作来整体观察线性一致。<br>我们此处引入一个概念</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAS(compare and swap):一个原子的比较设置操作。编程语言中一般都要实现此概念，此处不详细叙述</span><br></pre></td></tr></table></div></figure>\n<p>并且添加一个假设：即使客户端可能还没有收到成功的响应，但是分布式的存储已经全部同步成新的值。<br>上图中每个操作都有竖线，表示可能的执行的时间点，把这些点连接起来，最终结果必须是一个有效的寄存器读写顺序。<br>可线性化的要求： 按时间箭头向前移动，不能向后移动。<br>可以看到上图中，最后客户端A的操作在c的Cas操作完成后，x的值已经变成了4，但是如果发现读的值为2的话，按时间线的理解就是错误了。因为根据可线性化的要求，cas操作已经执行了，并且时间只能向前走的情况下，客户端A的读操作必然是需要返回4的。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;可线性化和可串行化的对比</span><br><span class=\"line\">#### 可线性化</span><br><span class=\"line\">对寄存器（单个对象）的最新值保证。他不要求将操作组合到事务中，可能会出现写倾斜的问题（如果不采取手段去解决的问题）</span><br><span class=\"line\">#### 可串行化</span><br><span class=\"line\">是事务的隔离属性。每个事务可以读写多个对象，用于确保事务执行的结果与串行执行相同。即使穿行执行的顺序和实际执行的顺序并不一定相同（可能实际上的执行是并行执行事务，但是对外暴露的结果是一致的就可以）  </span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"需要用到线性化的使用场景\"   >\n          <a href=\"#需要用到线性化的使用场景\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>需要用到线性化的使用场景</h3>\n      <ol>\n<li>加锁与主节点选举<br>对于主从复制系统的选主问题，可以通过基于Etcd或者ZooKeeper来进行抢锁操作控制选主</li>\n<li>约束与唯一性保证<br>应用中对同一个资源（如用户名）的唯一性的约束。（可以延展到数据表的主键约束）</li>\n<li>多信息源的时间依赖<br>对于一些异步任务系统虽然采用了最终一致性，但是可能也是会因为实现产生数据的依赖问题。</li>\n</ol>\n\n        <h3 id=\"如何实现一个线性化系统\"   >\n          <a href=\"#如何实现一个线性化系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何实现一个线性化系统</h3>\n      \n        <h4 id=\"对比多种可能使用的方案来确定\"   >\n          <a href=\"#对比多种可能使用的方案来确定\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对比多种可能使用的方案来确定</h4>\n      <p>在考虑容错的基础上，必须考虑复制的机制。我们可以对比多种复制方案来看看那种可以实现线性化</p>\n<ol>\n<li>主从复制。（部分线性化）<br>因为所有写入操作都是从主节点继续，并且把操作同步到从节点上面。但是问题可能出现在实现的问题上：  <ol>\n<li>实时同步可能会出现问题</li>\n<li>可能会因为快照隔离设计出现问题</li>\n</ol>\n</li>\n<li>共识算法（可线性化）<br>类似于主从复制，但是通过一些手段来防止脑裂和过期的副本</li>\n<li>多主复制（不可线性化）<br>当允许并发写入的时候，如果进行异步复制的话，可能会出现数据的冲突。</li>\n<li>无主复制（可能不可线性化）<br>类似于Dynamo的机制，即使使用了Quroum机制，但是如果选取的Quroum不一定是满足的情况下，可能会出现非线性化的处理</li>\n</ol>\n<p>此处提出一个问题，是否只要有Quroum机制（就必定可以支持线性一致呢？）<br>答： 不一定。用下面的例子进行解释  </p>\n<p><img src=\"/assets/img/posts/quroum-fail.png\" alt=\"QuroumFail\"><br>对于上图中，即使是使用了Quroum，但是没有共识算法的支持，还是可能会出现类似于之前Alice和Bob遇到的情况的问题。但是这个选取的直接是一个Quroum，但是是因为缺少共识，并且网络出现问题才会导致这样的情况出现。</p>\n\n        <h3 id=\"线性化的代价\"   >\n          <a href=\"#线性化的代价\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>线性化的代价</h3>\n      <p><font color=\"#FF0000\">线性化出现代价的最主要的原因还是因为网络的不确定性。</font></p>\n<p>我们先用主从的架构来讨论这个问题，当网络发生分区的情况，主从不能够继续同步操作，可能会导致从库不可用。<br>但是这个是我们需要实现线性化所带来的不可用</p>\n<p>先引入一个概念：CAP理论</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAP : 在同一个时间内，当网络出现分区的情况下，不可能获得兼容可用性和一致性。</span><br></pre></td></tr></table></div></figure>\n<p>CAP理论的推理：不要求线性化的应用更能够容忍网络分区。</p>\n<p>但是为了线性化，我们可能要牺牲性能和延迟。<br>那么我们是否有方法可以做到线性化但是减少性能的牺牲呢？</p>\n\n        <h2 id=\"顺序保证\"   >\n          <a href=\"#顺序保证\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序保证</h2>\n      <p>我们刚刚在讨论线性化的时候使用到了寄存器的概念，那么顺序、可线性化、共识之间是否存在的某种关系呢？</p>\n\n        <h3 id=\"顺序、因果、全局序号的关系\"   >\n          <a href=\"#顺序、因果、全局序号的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序、因果、全局序号的关系</h3>\n      \n        <h4 id=\"顺序和因果的关系\"   >\n          <a href=\"#顺序和因果的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序和因果的关系</h4>\n      <p>因果关系对所发生的事件添加了排序， 一件事情会导致另外一件事情，这些的因果关系依赖链条定义了系统中的因果顺序。如果符合因果关系所规定的顺序，我们称之为因果一致性。（快照隔离，在从数据库中读数据的情况下，查询到的诗句，也可以查到这个数据之前发生了什么的操作事件）</p>\n\n        <h4 id=\"因果顺序并非全序\"   >\n          <a href=\"#因果顺序并非全序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>因果顺序并非全序</h4>\n      <p>全序关系是可以支持两个不同的实体直接进行比较（如自然数集5和13的比较）<br>但是部分集合的对比不一定符合全序，集合{a,b} 与 集合{b,c}是无法进行对比的  </p>\n<p>因此，提炼到可线性化和因果关系中<br>可线性化是存在全序的操作关系，因为暴露对外的行为是与单副本无异，并且每个操作都是原子的。可以分出先后<br>因果是偏序的操作关系，对于并发的两个操作无法比较的情况下，就会发生冲突，对于可以比较的情况下，与线性无异。<br>那么可以这样说，可线性化一定意味着因果关系，因为可线性化是全序的操作。<br>但是可以这样理解，线性化并非是保证因果关系的唯一的途径。我们可以有其他手段去满足因果一致性而避免线性化所带来的问题。<br>因果一致性是被认为是不会由于网络延迟而显著影响性能，并且可以对网络故障容错提供容错的最强一致性的模型。<br>因为实际上很多的应用所需要的是因果一致性来保证应用的正确性。  </p>\n\n        <h4 id=\"捕获因果依赖关系\"   >\n          <a href=\"#捕获因果依赖关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>捕获因果依赖关系</h4>\n      <p>如果只要解决并发操作的先后依赖关系。这里其实只需要由偏序的关系即可。<br>我们常见的数据库的版本技术就是一个解决这个问题的方案之一<br>为了确定数据库的因果关系，数据库需要知道应用读取的是哪个版本的数据。</p>\n\n        <h4 id=\"序列号排序\"   >\n          <a href=\"#序列号排序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>序列号排序</h4>\n      <p>那么，这样的情况下，我们是否需要显式的跟踪所有的因果关系呢？<br>为了性能的考虑，我们可以通过序列号和时间戳（尽量不使用物理时钟）来进行对事件排序，这样在保证性能的同时，也能够保证所有操作在全局的关系。但是要保证每个序列号必须唯一，并且可以比较。<br>我们可以按照与因果关系一致的顺序来创建序列号： 如果操作A发生B之前，那么A一定在全序顺序中出现在B之前<br>这样的全局排序可以捕获所有的因果信息，并且加强了比因果关系更为严格的顺序性  </p>\n<p>那么对于不存在唯一的主节点（多主或者无主），那么我们能怎样生成上面所提及的序列号呢？<br>有实践中可以采用以下方法：<br>    1. 每个节点单独生成自己的一组序列号。假设有两个节点，一个生成奇数，一个生成偶数<br>    2. 把Timestamp添加到操作中（之前生产中有用此种方式）<br>    3. 预先分配序列号的区间范围。（A节点分配1-1000，B节点分配1001-2000）  </p>\n<p>但是这三种实际上生成的唯一的，近似增加的序列号。但是实际上序列号和因果一致不是完全因果一致的。<br>为什么不是因果一致呢?<br>对于情况1，每个节点处理的速率是由不一致的，只要两个节点处于处理速率不一致的情况下，分配的ID必然和实际的顺序关系无法对应<br>对于情况2， 墙上时钟发生偏移的情况<br>对于情况3， 如果sharding的路由发生了变化之后，那么之前1-1000的因果关系就不存在了。  </p>\n<p>那么我们是否没有办法可以在非强主的情况可以获取一个序列号与因果一致可以对应上的吗？  </p>\n<p>我们还有一个方法！！！此处大神来了Leslie Lamport的Lamport TimeStamp可以解决这个问题  </p>\n\n        <h4 id=\"LamportTimeStamp\"   >\n          <a href=\"#LamportTimeStamp\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>LamportTimeStamp</h4>\n      <p><img src=\"/assets/img/posts/LamportTimestamp.png\" alt=\"LamportTimeStamp\"><br>每个节点一开始的时候都会有一个唯一的标识符（每次初始为0）， 然后每个节点都有一个计数器来记录各自处理的请求总数。到此与之前的时间戳的并无差别，但是Lamport这里处理的亮点出来了，每个节点和每个客户端都会跟踪迄今为止最大的计数器值，并且在每个请求中附带该最大计数器值。当节点收到某个请求的时候，如果发现请求内的最大计数器值大于自身的计数器值，会更新自己的计数器值（Raft中是通过投票和心跳的RPC来同步这个计数器的值，在Raft的概念里面叫做Term，后面讲解Raft的时候会进一步解析，此处只是一个插叙）。</p>\n<p>LamportTimeStamp好像是解决了分布式系统顺序号和因果一致的关系，但是是已经足够解决分布式系统中常见的问题了吗？<br>问题如下：<br>    一个系统的用户名只能由唯一的用户持有，两个用户并发地向系统同时进行注册，我们必须要保证一个成功，一个失败<br>虽然看上去我们是可以把两个请求通过编号把两个并发的请求变成了一个有顺序的问题，但是实际上要保证上面的是唯一的有两个前提：<br>    1. 节点收到用户请求的时候需要马上判断请求时成功还是失败<br>    2. 必须要收集系统的所有创建用户的请求，比较序号<br>但是这个显然是不可能的，只要网络出现问题了，我们就无法做到上面的两个问题。</p>\n<p>那么我们如果要知道全局关系是否确定，就需要提到后面的一个概念，全序关系广播</p>\n\n        <h3 id=\"全局关系的广播\"   >\n          <a href=\"#全局关系的广播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>全局关系的广播</h3>\n      <p>继续先从一个主从复制的系统开始说起，主节点接受写请求并且变成顺序的操作。<br>但是在分布式系统领域，如何扩展系统的吞吐量使之突破单一主节点限制以及处理主节点失效时的故障切换。这类的问题被称为全序关系广播或者原子广播。<br>全序关系广播： 通常指节点之间交换信息的某种协议。有两个特性<br>    1. 可靠发送（没有消息丢失，如果消息发送到某一个节点，它一定要发送到其他的节点）<br>    2. 严格有序（消息总是以相同的顺序发送到每个节点）  </p>\n\n        <h4 id=\"使用全序关系广播\"   >\n          <a href=\"#使用全序关系广播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用全序关系广播</h4>\n      <p>Zookeeper和Etcd的共识服务就实现了全序关系广播。（那么全序关系广播和共识之间的关系？）  </p>\n<p>全序关系广播就是数据库所需要，每条消息表达数据库的写请求，而且每个副本段相同的顺序处理这些写请求，那么所有副本可以保持一致。这个也被称为状态机复制。  </p>\n<p>全局关系广播的另一个要点，顺序在发送消息时已经是确定的，如果消息发送成功，节点不允许追溯将某条消息插到先前的位置上。只能进行追加，这样全序关系广播比时间戳的排序要求更强<br>应用场景：<br>    1.我们可以使用全序关系广播来实现可串行化的事务。（每个消息表示为一个确定性质的事务，并且作为存储过程来执行）<br>    2.提供Fencing令牌锁的服务（把取锁的请求变成一个消息追加到日志中，序列号直接可以变成令牌返回）  </p>\n\n        <h4 id=\"全序关系广播来实现线性化存储\"   >\n          <a href=\"#全序关系广播来实现线性化存储\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>全序关系广播来实现线性化存储</h4>\n      <p>全序关系广播是基于异步模型，保证消息以固定顺序的可靠发送，但是不保证消息何时发送成功，但是可线性化更多地强调读取时能看到最新的写入值。<br>我们可以通过追加的日志的方式使得使用全序关系广播在写入的方式上与可线性化做到一致<br>    1. 在接受请求的本地节点中追加一条消息，指明写入的信息<br>    2. 读取日志，广播到其他节点，等待回应<br>    3. 如果回复中有冲突，则失败，返回错误给客户端；否则返回成功给客户端<br>通过日志追加可以把并发有效的转换为多条的日志来保证因果顺序关系。但是读取却还没做到这个语义<br>为了读取可以与可线性化一致，有以下方法可以解决这个问题：<br>    1. 把读的请求也变成日志的方式追加到排序广播，通过变成日志的情况下可以确定了顺序的问题。（ETCD采用的是这种方式）<br>    2. 如果可以以可线性化的方式获取最新日志的消息位置，则查询位置，直到该位置之前的所有条目读发送给你，再进行读取（ZooKeeper使用的方式）<br>    3. 可以从同步更新的副本中进行读取，保证每次读的是最新的值。  </p>\n<p>所以最终可线性化的原子地对寄存器做CAS的操作与全序关系广播其实等价于共识的问题。</p>\n\n        <h1 id=\"分布式共识的能力边界\"   >\n          <a href=\"#分布式共识的能力边界\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识的能力边界</h1>\n      <p>共识： 使得分布式系统中就某件事情达成一致<br>共识的使用场景：<br>    1. 主节点选举（防止脑裂问题）<br>    2. 原子事务的提交（跨节点或分区的数据库，事务在部分节点成功，部分节点失败，需要进行回滚）<br>我们先从事务的原子性开始，讨论2PC（2阶段提交），之后再会谈及其他更好的共识算法的实现（ZooKeeper， Raft）  </p>\n\n        <h2 id=\"分布式事务\"   >\n          <a href=\"#分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式事务</h2>\n      <p>事务原子性的目的：<br>一个多笔写操作的事务在执行过程中出现意外情况，为上层应用提供一个简单的语义，全部成功或者全部失败<br>单机原子提交：<br>数据库把事务写入持久化部分，然后把提交记录追加写入到磁盘的日志文件中。所以在单节点上面，事务提交非常依赖与数据持久写入磁盘的顺序关系<br>    1. 先写入数据，再提交记录<br>    2. 事务提交或者中止的关键点在于磁盘完成日志的时候，在完成写之前崩溃的情况下，事务需要中止；如果日志在完成写入后发生崩溃，事务被安全提交  </p>\n<p>但是对于分布式多节点，处理方法有所差别，原因可能是以下这几个问题引起的<br>    1. 某些节点发现不满足要求中止了事务，但是部分节点通过并且提交<br>    2. 部分请求可能在网络不稳定的情况下丢失，超时而中止；但是其他请求可能成功提交<br>    3. 节点可能在写入日志前崩溃，而且在恢复后回滚（原来数据没有成功，回滚可能会出现问题）<br>如果一部分节点提交了事务，但是部分节点放弃了事务，会导致集群中节点信息的不一致，而且事务一旦被提交，即使事后发现其他节点中止，也无法撤销本节点的事务  </p>\n<p>事务提交后不能撤销的原因：<br>一旦数据提交，就会被其他事务可见，然后客户端（应用层）就会做出相应的反应，这个是构成读-提交隔离的基础。但是如果允许撤销的话，那么所有之后的读-提交级别的任务，然后会产生多级的级联式追溯和撤销。导致系统压力巨大甚至崩溃。并且不能保证数据是否能够准确落盘。  </p>\n<p>因为不允许撤销事务，因为如果一个错误的事务被提交了，必然需要一个新的事务来抵消它的影响，但是这个需要应用层来进行处理，就不符合我们需要给应用层提供的原子性。  </p>\n\n        <h3 id=\"2PC\"   >\n          <a href=\"#2PC\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2PC</h3>\n      <p>两阶段提交（2PC）是一种在多个节点上实现事务原子提交的算法。要么全部提交，要么全部不提交。</p>\n\n        <h5 id=\"2PC的流程（为什么可以解决上面单阶段提交的问题）\"   >\n          <a href=\"#2PC的流程（为什么可以解决上面单阶段提交的问题）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2PC的流程（为什么可以解决上面单阶段提交的问题）</h5>\n      <ol>\n<li>应用启动分布式事务的时候，先去像协调者获取事务ID（全局唯一）</li>\n<li>应用程序在每个参与的节点启动单节点事务，并且把事务ID附加到到参与者的事务上。如果这个阶段发生异常，可以协调者和其他参与者可以安全中止</li>\n<li>应用程序准备提交事务时，协调者回向参与者发送携带事务ID准备请求，只要有一个发现失败的情况下，通知全部放弃事务</li>\n<li>参与者收到请求后，确保自己时候可以提交事务（包括硬件故障和软件故障的确认），然后检查是否有冲突或者违规。一旦返回是，节点会承诺提交事务。（保证了参与者不会撤销事务）</li>\n<li>当协调者收到所有的参与者返回后，要决定是否提交事务，并且把此决定写入到硬盘的事务日志（WAL）中，防止掉电后可能出现的异常</li>\n<li>协调者向参与者发送提交/放弃 事物的请求，只要是提交，每个参与者会重试到成功为止(包括了进程崩溃的重试、节点重启等情况)</li>\n</ol>\n<p>所以他是在保证了上面的一个重要前提，只要提交了就不能撤回。<br>在参与者在返回给协调者的时候保证了单向性<br>并且协调者确定提交了之后也是保证了不可逆，因此保证了2pc可以不会出现那些异常的情况。</p>\n<p>但是2PC的单点在于协调者的问题（虽然可以采用共识层来写协调者保证高可用）但是整个过程中的热点也会出现在协调者上面。</p>\n\n        <h3 id=\"实际生产上面的分布式事务\"   >\n          <a href=\"#实际生产上面的分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实际生产上面的分布式事务</h3>\n      \n        <h3 id=\"异构分布式事务\"   >\n          <a href=\"#异构分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>异构分布式事务</h3>\n      <p>虽然分布式事务因为这样可能会有阻塞而导致性能和吞吐量的下降，但是是否没有折中的方法来使用类似的语义呢？<br>目前更多的是采用了异构的方法（如数据库+MQ）的执行异构的分布式事务</p>\n<p>对于异构形式的分布式事务，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息处理完毕。<br>但只要其中一个出现失败的情况，两个部分都必须进行中止的操作。</p>\n<p><b>保证消息可以有效处理有且仅有一次</b></p>\n<p>目前有XA的异构的分布式事务的标准。</p>\n\n        <h2 id=\"支持容错的共识\"   >\n          <a href=\"#支持容错的共识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>支持容错的共识</h2>\n      <p>共识问题的形式化描述： 一个或者多个节点可以提议某些值，由共识算法来决定最终的值。</p>\n<p>基于上面的描述共识算法必须满足以下的性质：<br>    1. 协商一致性（所有节点都接受相同的决议）<br>    2. 诚实性（所有节点不能反悔，对某项提议不能有两次决定）<br>    3. 合法性（决定了值V, 那么V肯定是由某个节点提议的）<br>    4. 可终止性（如果节点不崩溃最终一定可以达成协议）</p>\n<p>协商一致性和诚实的属性定义了共识算法的核心思想：决定一致的结果，并且一旦决定就不能改变。<br>合法性是为了排除一些无意义的方案，<br>可终止性是容错的体现，避免了整个系统的空转<br>根据之前提及的： 可终止性是活性， 其他三个是安全方面的属性。</p>\n<p>因为共识算法的目的是解决在大多数节点正常的情况下正确运行才能确保终止性。</p>\n\n        <h3 id=\"共识算法和全序广播的关系\"   >\n          <a href=\"#共识算法和全序广播的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识算法和全序广播的关系</h3>\n      <p>共识算法(如Raft、Paxos、Zab)等都不是直接采用上述的形式化模型。而是决定了一系列的值，然后采用全序关系广播算法来进行实现。  </p>\n<p>全序关系广播要点： 消息按相同的顺序发送到所有的节点，有且只有一次。<br>这样的方式相当于多轮的共识过程。在每一轮，节点会提出之后需要发出的信息，然后决定下一个顺序。</p>\n<p>对于上面的提到的四个性质：</p>\n<ol>\n<li>由于协商的一致性，所有节点决定以相同的顺序发送相同的消息。</li>\n<li>由于诚实性，消息不会重复</li>\n<li>由于合法性， 消息不会被破坏，也不是凭空捏造</li>\n<li>由于可终止性，消息不会丢失</li>\n</ol>\n\n        <h3 id=\"Epoch-和-Quorum\"   >\n          <a href=\"#Epoch-和-Quorum\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Epoch 和 Quorum</h3>\n      <p>对于共识算法来说，都采用了一个弱化的保证，定义了一个世代编号（Epoch）来确保每个世代里面，主节点是唯一的。<br>如果发现当前主节点失效的情况，节点开始选举新一轮的主节点，Epoch号递增。在主节点做出任何决定的时候，都需要检查是否由比它更高的Epoch号码。<br>主节点必须从Quorum中收集投票，并且把提议传送到各个节点中，等待节点的返回，当只要没有更高的Epoch主节点<br>时，才会对当前的提议进行投票。</p>\n<p>此处其实是由两个操作组成：1. 选举主节点； 2.对主节点的提议进行投票</p>\n<p>注意的一点： 参与两轮的Quorum必须要由重合，这样才能保证主节点没有更高的Epoch，保证正确性。</p>\n<p>与2PC的差别， 2PC是需要协调者向每个参与者做出“是”的返回才能进行，而共识算法可以通过直接以集群的多数来确定是否通过决议</p>\n\n        <h3 id=\"共识算法的局限性\"   >\n          <a href=\"#共识算法的局限性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识算法的局限性</h3>\n      <p>共识算法虽然为分布式系统带来了好处，为一切不确定的系统带来了安全属性和容错性。并且可以通过全序关系广播以容错的方式实现线性化的原子操作。</p>\n<p>但是共识也是有代价的：</p>\n<ol>\n<li>节点投票是一个同步复制过程，性能可能需要妥协（但是可以通过减少选举的频率来减少整个开销）</li>\n<li>共识体系需要严格的多数节点才能执行，换句话来说，最少需要3个节点才能运行</li>\n<li>多数的共识算法假定了一组固定的参与投票的节点集（主要是为了理解的方便）</li>\n<li>共识算法需要依靠超时来对节点失败进行检测，但是可能会出现因为网络原因的误判导致经常切主，数据搬移多，对外的性能降低。</li>\n<li>网络的影响较大，如果出现频繁切主的情况，可能会有长时间出现无法正常对外进行服务</li>\n</ol>\n\n        <h3 id=\"基于共识算法的成员与协调服务\"   >\n          <a href=\"#基于共识算法的成员与协调服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基于共识算法的成员与协调服务</h3>\n      <p>对于像ZooKeeper、Etcd这些分布式键值对的服务，暴露的API与数据库是十分类似的，但是为什么我们需要在共识层上面去构建这些服务呢？</p>\n\n        <h4 id=\"作用\"   >\n          <a href=\"#作用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>作用</h4>\n      <p>这些分布式键值对数据库主要是针对保存少量，可完全载入内存的数据。采用容错的全序广播算法在所有节点上复制数据使得可以实现高可用的目标。</p>\n<ol>\n<li>线性化的原子操作<br>多个节点同时去获取锁，只有一个会成功，共识协议会保证操作满足原子性和线性化，即使节点出现部分失败的情况</li>\n<li>操作全序<br>之前分布式系统问题的文章有提及过Fencing令牌的问题，</li>\n<li>故障检测<br>客户端会与这些服务保持一个长连接，如果长时间重连失败的情况下，会把该客户端拥有的资源全部释放</li>\n<li>更改通知<br>客户端可以通过读取服务来发现其他的客户端的行为</li>\n</ol>\n\n        <h4 id=\"对外的功能\"   >\n          <a href=\"#对外的功能\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对外的功能</h4>\n      <ol>\n<li>节点任务分配<br>计算作业调度系统(Yarn)，分区资源调度（如Multi-Raft中的ShardMaster)</li>\n<li>服务发现<br>解决云环境中服务启停而注册到的服务变更(consul提供的服务)</li>\n<li>成员服务<br>节点是否可用并且获取主节点</li>\n</ol>\n\n        <h3 id=\"如何验证一个线性化系统\"   >\n          <a href=\"#如何验证一个线性化系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何验证一个线性化系统</h3>\n      <p>（此部分会结合Mit6.824和PingCap tikv 的线性化验证的代码阅读和文章来描述）</p>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://pdos.csail.mit.edu/6.824/papers/dynamo.pdf\" >Dynamo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/basho/riak_core\" >Riak</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://cassandra.apache.org/\" >Cassandra</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://book.douban.com/subject/30329536/\" >数据密集型应用系统设计</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n"},{"title":"分布式系统概念简介及其问题的描述","date":"2019-08-20T03:07:38.000Z","_content":"\n<!-- ---\n\nauthor: Ray Chan(ray1888)\ndate: 2019-08-20 11:07:38\ncategory: \nsummary: introduction of distributed system and its problem\nthumbnail: distributed-system.png\n--- -->\n\n# 目录 \n1. [什么是分布式系统](#Introduction)  \n2. [分布式系统能够解决什么问题](#Purpose)  \n   2.1 [服务器的性能扩展方案](#2.1)  \n   2.2 [分布式系统的特点](#2.2)  \n   2.3 [分布式系统解决的问题](#2.3)  \n3. [分布式系统的问题](#Problem)  \n   3.1 [网络问题](#3.1)  \n   3.2 [时钟问题](#3.2)  \n   3.3 [节点问题](#3.3)  \n4. [在不可靠硬件构建可靠软件需要满足的条件和假设](#ConditionAssumtion)  \n   4.1 [真相由多数决定](#4.1)  \n   4.2 [理论系统模型与现实](#4.2)  \n5. [ShareNote](#ShareNote)  \n\n\n# <a id=\"Introduction\"><span class=\"toptitle\">#什么是分布式系统</span></a>\n\n### 分布式系统\n\n```\n// Definantion from IBM Site \nA distributed computer system consists of multiple software components that are on multiple computers, but run as a single system. The computers that are in a distributed \nsystem can be physically close together and connected by a local network, or they can be geographically distant and connected by a wide area network. A distributed system can consist of any number of possible configurations, such as mainframes, personal computers, workstations, minicomputers, and so on. The goal of distributed computing is to make such a network work as a single computer.\n```\n\n简述：\n分布式的计算机系统是由多台形式的计算机（包括服务器、个人电脑、工作站、嵌入式系统的形式）组成的，但是对外表示成一个完整功能的系统。对于分布式系统的使用者，可以把一个大型的分布式系统看作一个黑盒来进行使用。  \n\n# <a id=\"Purpose\"><span class=\"toptitle\">#分布式系统能够解决什么问题</span></a>\n\n###  <a id=\"2.1\"><span class=\"secondtitle\">2.1. 服务器的性能扩展方案</span></a>\n\n对于一个系统来说，如果当需要计算的问题太过庞大的时候，会有两种思路来进行算力的添加  \n\n1.Scale UP（纵向扩展）  \n纵向扩展:企业后端大型服务器以增加处理器等运算资源进行升级以获得对应用性能的要求。\n这种是比较传统的思路，具有以下特点：  \n    1. 扩容的成本较高。能够支持纵向扩展的系统都需要服务商进行服务的支持，需要购买特殊的硬件。而不是使用能够通用的硬件来进行扩容  \n    2. 延迟低，单点吞吐量大。本质上是单点的系统，可以减少了很多网络上面的开销，所以延迟一般会比分布式系统的延迟更低。而且单节点如果在没有超过负荷的情况下，因为硬件堆积在上面，单节点的性能一般会比分布式的单节点性能更强。  \n    3. 备份成本高，遇到不可恢复的故障时可能要中断一定时间的服务。如果对于纵向扩展的设备需要进行灾备的情况下，可能需要同时购入相同配置的硬件通过配置主备来继续容灾，而不能通过像分布式系统在多个地域继续节点部署和配置添加达到冗余的程度。  \n  实例的系统： 传统的SAN(storage area network)系统  \n\n2.Scale Out(水平扩展)  \n水平扩展：企业可以根据需求增加不同的服务器应用，依靠多部服务器协同运算，借负载平衡及容错等功能来提高运算能力及可靠度。  \n这是从谷歌的三篇经典的分布式论文（bigtable、distributed filesystem、 mapreduce)提炼出来的特点：  \n    1. 成本低，扩展性好。使用的是市面上可以购买的通用的服务器配件，并且可以根据需求进行硬件的升级即可提升整体的性能（如存储服务器上面，把HDD更换为全闪存的NVME SSD，立刻可以在读写的吞吐量和时延上面获得具体的提升）  \n    2. 弹性好。可以通过配置动态的增删服务器，可以动态的对业务使用的服务器资源具有更好的调配，并且可以通过弹性的配置获得根据地理位置的容灾以及数据冗余功能（如金融企业中的两地三中心的需求）  \n    3. 处理单节点无法处理的问题。（最重要）  \n\n### <a id=\"2.2\"><span class=\"secondtitle\">2.2 分布式系统的特点</span></a>\n1. 扩展性强(Scalability)  \n2. 有冗余(Redundancy)  \n\n### <a id=\"2.3\"><span class=\"secondtitle\">2.3 分布式系统解决的问题</span></a>\n分布式系统最重要解决的问题是：  \n1. 处理单机无法计算的问题。  \n因为问题能够被分治成为了更小的问题，使得更弱的节点也可以进行计算  \n2. 同样的工作量下，减少计算使用的时间。  \n因为部分计算是可以并行来继续执行的，只要调度得当的情况下，可以减少单机系统中出现的等待的情况。  \n3. 在有限的成本内，可以通过多区域部署服务来降低该地区的服务的时延。  \n\n\n# <a id=\"Problem\"><span class=\"toptitle\">分布式系统的问题</span></a>\n（此部分有部分会引用到数据密集型应用系统设计（DDIA）的第8章部分的内容）  \n软件工程的世界里面没有银弹，分布式系统并不是所有问题的最优解。它在解决上述问题的情况下也引入了下面的多种问题    \n此处需要引入一个部分失效的概念：  \n```\n部分失效：在分布式系统中，可能会出现系统的一部分工作正常，其他部分出现难以预测的故障。\n```\n\n### 对于互联网服务的分布式系统的假设\n1. 需要7*24的可用状况，所以不能有服务不可用的状态\n2. 采用通用的硬件，故障率会较高，成本较低\n3. 采用IP和以太网的技术，网络可靠性不如专有网络(Fiber Channel等。。。)\n\n因为上面的三个原因可能引申出来的另外的假设  \n\n4. 系统越大，局部组件失效的概率越大。（长时间的运行时间，失效、修复、再失效是正常的状况而不能当为异常的情况去考虑）\n5. 由于局部失效的概率高，因此需要必须容忍部分节点失败，并且能够保持对外提供可用的服务\n\n<b><font color=\"#FF0000\">所以实际上我们目前大部分的分布式的系统是需要在不可靠的硬件上面通过软件容错来构建可靠的系统。</font></b>\n\n### <strong><font color=\"#FF0000\">所以分布式系统遇到的问题可以分为三个大类</font></strong>\n1. 网络类问题  \n2. 时钟问题  \n3. 节点软件和硬件的问题  \n\n## <a id=\"3.1\"><span class=\"secondtitle\">网络问题</span></a>\n对于上面的假设（主要是成本考虑）来说，一般都会采用无共享的方式来构建集群。\n\n由于通常使用的都是以太网来构建，而且以太网是异步的网络。可能会出现下面的这些情况\n1. 请求丢失  \n2. 请求再队列等待，无法发送（网络问题或者接收方繁忙在内核的队列中等待）  \n3. 远程接收节点失效（节点崩溃）  \n4. 远程节点无法响应  \n5. 远程节点有返回，但是返回过程中丢失  \n6. 远程节点处理请求，但是在返回时候被延时处理（优先级问题， 或者网络问题或则和发送方阻塞了）  \n\n\n此处需要多引入一个新概念，网络分区\n```\n网络分区（Network Partition）：当网络的一部分由于网络故障而与其他部分隔开，称之为网络分区或者网络分片\n```\n\n在工程的实践中，网络故障(丢包、链路中断、路由问题、物理设备损坏)的概率是远比想象中高， 因此在基于我们假设的前提的环境下面，必须要把网络分区和网络故障接入到软件中进行容错。\n\n对于如何处理检测是否故障，需要判断的一个问题是，是节点服务上面出现了真实的故障，还是网络的不可靠导致的服务失效的表现。\n```\n在实际生产的实践中有这样的方法来快速的在本应用层（网络正常的情况下）来进行简单的判断\n1. 通过服务注册的心跳来注册自己的服务存活，并且把死亡状态的服务实例剔除出可用服务中\n2. 检测进程是否崩溃，如果崩溃发送一个信号。（或者在我的工作经历中，使用一个进程去定时检测进程是否存活，失败了发送信号使得资源进行重启的尝试，并且上报告警）\n3. 通过交换机去查询网络的状况\n4. 通过中间件的自身监控（如Rabbitmq的web界面）来监控中间件的执行状况\n5. 定期去尝试访问网络是否通达\n```\n但是最终我们唯一能够完全判断故障的方法只有超时，来保证节点是不可用的状态（为了保证网络的不可靠问题）。\n\n### 超时引入的问题\n我们如何能够判断什么时候才是最好的超时的判断间隔呢？\n\n对于上面的这个问题， 我们引入两个问题的前置的讨论  \n1. 是什么导致我们会出现网络的不稳定  \n2. 如果出现超时之后，会有怎样的影响，会导致什么样的后果  \n\n#### 网络不稳定的原因\n根本的原因： 在设计目前的TCP/IP的协议和方法的时候，我们的目的是为了尽可能高的提高资源的利用率  \n设计的思想： 通过动态分配和竞争的机制使得动态决定那个包被发送，但是这样的方法必然会引入排队的机制  \n\n```\n// 出现网络不稳定的原因可能如下\n1. 对于交换机的角度，会有多条等待队列来进行数据报文的转发，如果符合过重，则需要等待轮询机制来等待发送的机会，并且如果数据量过多的情况下，也有可能出现数据报文被丢弃，然后被不断重试的现象\n2. 在服务器的处理中，因为Linux内核处理接收到的报文也是类似于交换机的处理模式，通过队列来对接受到的包进行排序以及复制到用户态，因此也是需要一定的时间需要处理\n3. 在TCP的协议中的重传的机制也会根据返回的报文的控制字段来减小发送窗口的大小来减少对接受方的压力，可能导致排队会提前到发送方的等待队列中。并且重传机制会进行多次的重试，引入了隐形的超时时间\n```\n\n#### 调用超时（网络超时）可能会导致的后果\n主要的影响是发生了责任的转移，可能带来可能的影响  \n1. 命令的重复执行  \n2. 数据迁移  \n3. 当整个系统处于高负荷的状态，可能会把其他正常的部分通过转移职责导致整个系统被拖垮  \n\n因此我们必须很小心调整这个超时的阈值,如果在以前的情况下，可能需要系统管理员对于在生产环境的情况下调整一定的参数来慢慢测试得出一个最优值。\n但是在最近的组建的实现中有两种新的思路\n```\n1. 通过内部的一个故障检测器来计算成功率来进行对超时阈值的控制（Akka， Cassandra， Hytrsix中有使用此种方法）\n2. 通过对数据的采集清洗和分析（AIOPS）（可能是APM(Application Performance Metric)的埋点采集数据以及对监控数据的整体清洗通过一些机器学习的模型来计算出超时的阈值）\n```\n\n## <a id=\"3.2\"><span class=\"secondtitle\">时钟问题</span></a>\n分布式的系统的时钟问题也是一个非常值得重视的问题，后面会有我自己的工作案例来说明可能出现的情况的严重性。\n\n其实对于时间我们一般分为两种的应用方式\n1. 在一段时间内的统计数据（时间段）\n2. 某些时间点是否有指定动作完成或某个历史行为的发生的时间点\n\n### 服务器时间的维护方式以及问题\n每个机器的时间可以通过两种方式来共同维护\n1. 本地时间（通过主板的石英振荡器来维护）\n2. 通过与一个准确的时间获取源来定是同步时间（NTP和Chrony就是服务于方面的协议）\n\n这两种的结合不一定能够保证这样的可信赖的分布式集群中的时间就必然是同步的\n1. 本地时间本来每个节点都可能会出现偏差\n2. 同步时间的时候必须通过网络来进行同步，而在我们上面提及的假设中，网络是不可靠的，因此可能会出现失败的情况。 \n3. NTP如果发现时间差别太大（实际生产中是时间差>=10分钟的情况下）的话会拒绝同步（但是Chrony并没有此问题）\n4. 闰秒的问题\n\n当然可以像Google维护Spanner集群那样采用高精度的原子钟加上GPS定位来保证错误在一定的可接受范围内运行（一般误差的单位为5微妙）。但是不是每个分布式系统都能够有如此之高的维护成本去使用这种方式来\n\n### 时钟的概念\n\n时钟可以分解为两个时钟的概念\n1. 物理时钟\n物理时钟:包括了两种一个是墙上时钟，一个是单调时钟。可以理解为可以通过系统时间相关的API进行获取的时钟。\n2. 逻辑时钟\n逻辑时钟：可以理解为分布式系统中全局的单调递增的事件ID，事件发生顺序与此相同。\n\n#### 物理时钟\n需要先引入一个时间调整的概念：\n<!-- ![时间跳变说明图](/assets/img/posts/TimeJump.png)   -->\n{% asset_img TimeJump.png 时间跳变说明图 %}\n如果把时间以时间轴的方式来进行表达，往时间变大的方向调整为向前调整，往时间变小的方向调整的是向后调整。\n只要发生了时间的变动，我们都可以称之为服务器发生了时间跳变。\n\n<b><font color=\"\">1. 墙上时钟 </font> </b><br>\n根据日历返回当前的时钟，就是我们平时在Linux上直接使用date命令或者语言内置的时间相关的api的输出。\n这种时钟可以与时间同步服务器后同步后进行修改，可能会出现向前调整或者向后调整的可能性\n\n<b><font color=\"\">2. 单调时钟</font></b><br>\n用于： 适合测量持续的时间段    \n单调时钟的特性：    \n    1. 保证只会向前调整    \n    2. 不需要进行同步    \n\n#### 计算和调整的方式\n在一个时间点进行对单调时间的获取，然后完成某项工作后，再去检查时间。但是这段时间的差值并没有太大的意义。\n\n#### 时间与事件的顺序问题\n\n当两个客户端对于一个分布式的数据库（非Raft或者Paxos类型，如Riak）分别进行写入的情况下（此处假设先写入的客户端为A，晚写入的客户端为B）  \n<!-- ![事件与时序冲突](/assets/img/posts/Time&EventMissmatch.png) -->\n{% asset_img Time&EventMissmatch.png 事件与时序冲突 %}\n当B虽然在发生的时间比A要晚，但是B在集群中同步完成的时间比A要早的情况写。即对外部来说A还未写入成功的情况下，先执行了B的操作，可能导致B的操作丢失（如果B的操作是依赖于A先写入的操作）。  \n上面是一个非常经典的关于分布式集群时间与事件的顺序问题。然而这种问题即使在时间同步服务精度再再提高的情况下，也无法保证它的执行的顺序与时间是一致的。  \n\n#### 工作上发生过与物理时间相关的问题\n\n<b>问题1： 发生时间跳变后，导致任务的调度器不再调度任务的情况  </b>  \n<!-- ![调度器时间跳变问题](/assets/img/posts/SchdulerTimeJump.png)   -->\n{% asset_img SchdulerTimeJump.png 调度器时间跳变问题 %}\n    现象的描述： \n    调度器默认应该定时把任务调度到线程上面，但是查看日志后发现任务并没有被调度   \n    原因解释：    \n    时间发生了向后的跳变，但是跳变的幅度大于调度的间隔，导致系统中认为调度成功，之后就没有追踪下面的状态（因为当时那部分代码的实现是再调度的时候修改调度的时间为last调度时间）    \n    解决方法：    \n    把时间从墙上时间更换为单调时间，然后添加检查执行的间隔即可。  \n  \n<b>问题2：同步时间后，由于时间差溢出导致结果溢出的问题  </b><br>\n    现象描述：    \n    从Ceph Mgr获取单个采集数据的情况下，然后发现数据变得异常的大，是一个int64是随机数  \n    原因解释：  \n    因为采用的是墙上的时候，但是发生了时间的向后调变，导致计算出来的值发生异常  \n    解决方法：  \n    把墙上时间更换为单调时间  \n\n#### 逻辑时钟\n做法： 需要一个全局的单调递增的ID。\n但是是否可以使用同步后的时间来做呢？\n答： 不可以。因为还是时间精度的不确定性。\n\n## <a id=\"3.3\"><span class=\"secondtitle\">节点本身的问题（硬件和软件）</span></a>\n比较极端但是可能出现率比较高的场景是进程出现暂停的情况\n\n1. 带GC的编程语言的GC(Garbage collection) halt\n2. 虚拟化环境的虚拟机的暂停\n3. 电脑发生休眠或者断电\n4. 上下文切换的情况下卡住了\n5. 执行同步磁盘的操作的时候（如fsync操作）\n6. 接收到信号导致进程退出的情况下\n\n# <a id=\"ConditionAssumtion\"><span class=\"toptitle\">#在不可靠硬件构建可靠软件需要满足的条件和假设</span></a>\n\n此部分为DDIA第8章的描述总结，可以理解成为读书笔记    \n\n## <a id=\"4.1\"><span class=\"secondtitle\">真相由多数决定（重要的判定条件）</span></a>\n节点不能通过自己的信息来判断自身的状态。因为节点可能出现失效、假死、甚至无法恢复的状况.可能出现的场景如下\n```\n1. 节点成功收到请求，但是因为路由问题，无法进行返回，超时后而被判失效\n2. 半断开的节点发现自己的信息没有被其他节点所确认，意识到自己网络出现问题\n3. GC halt导致无法接受请求，但是对于应用来说，切回到工作状态时候，自身状态没有变化\n```\n以上的多种情景都是实际出现问题，但是自身的状态并不会改变，因为没有收到其他节点的通知，它会一直维持原来的状态。    \n所以分布式的算法依赖节点间的相互投票与最小投票数（使用Quorum机制，m>=(n+1)/2）进行对比来产生结果,由于一个集群不会存在两个多数在同事做出相互冲突的决定，减少对特定节点的依赖。\n\n基于上面所提及节点不能通过自己的信息来判断自己的状态，我们讨论一个比较常见的问题，主节点与锁是比较常见的使用方法\n```\n可能的出现的场景\n1. 只允许一个节点作为数据库分区的主节点（Multi-Raft是其中的一种实现）\n2. 只允许一个事务或者客户端持有特定资源的锁，以防止同时并发写入带来的数据被破坏的问题\n```\n\n### <span class=\"thirdtitle\">如果由自己的状态决定可能会出现的问题</span>\n但是此处我们的假设时在分布式系统中，那么有可能出现节点中间出现了角色的切换，但是如果不加以对状态的判断，可能会出现这样的问题\n问题描述  \n<!-- ![客户端锁问题](/assets/img/posts/lockingproblem.png)   -->\n{% asset_img lockingproblem.png 客户端锁问题 %}\n客户端写入存储的时候需要先从分布式服务中获取锁，有两个客户端在线，客户端A先从服务中获取锁，然后发生了进程halt状态（可能是GC或者其他的原因）\n如果不加判断的情况下，在客户端A halt的状态的情况下，客户端B获得锁并且写入存储成功，然后客户端A从Halt状态中回复正常，客户端A认为锁还在，然后写入存储，\n如果两个客户端写入的是同一个文件的话，数据可能会出现问题。  \n### <span class=\"thirdtitle\">解决上面的问题</span>\n对于上面的问题，我们可以使用一个Fencing令牌来解决这个问题。(此机制到后面的文章还会继续详细讲解)  \n<!-- ![Fencing令牌解决锁问题](/assets/img/posts/lockingproblem2.png)   -->\n{% asset_img lockingproblem2.png Fencing令牌解决锁问题 %}\n我们在客户端A获取锁的时候给令牌赋予一个值，为33。 在客户端B获取锁的时候赋予一个令牌值34。  \n当B写入完成后，存储会把已写入令牌改为34，下一次分发的令牌为35， 这样的话，如果A带上33的令牌写入的时候直接被拒绝，能够保证一致性。  \n实际上上面这种方法不仅加上了一个令牌，而且在服务器端会有一个关于令牌的校验。这种做法非常常见。\n\n\n## <a id=\"4.2\"><span class=\"secondtitle\">理论系统模型与现实</span></a>\n对于一个在现实中能够容错的分布式系统，我们需要对预期的系统错误证明形式化的描述。我们通过定义部分的系统模型来形式化描述算法的前提条件。 \n\n<h3><b><span class=\"thirdtitle\">计时模型</span></b></h3>\n#### 同步模型\n假定有上界网络延迟和上界进程的暂停和上界时钟误差。（但是这个模型一般不存在，因为以太网的不可靠性，除非使用更加稳定的网络介质，并且使用高精度时间设备同步）\n#### 部分同步模型\n大多数情况下像一个同步系统运行，但是会有超出网络延迟，进程暂停和时钟漂移的上界。这个就是比较现实的模型，就是上面我们提到的真实环境可能出现的情况的总和。而且大部分时间比较稳定，小部分时间会有背离，但是发生背离就会出现三者中的组合的情况出现。\n#### 异步模型\n\n\n<h3><b><span class=\"thirdtitle\">节点失效模型</span></b></h3>\n#### 崩溃-中止模型\n节点以一种特定的方式发生故障，故障后，出现系统崩溃，并且节点不会再添加进入集群中，无法恢复\n#### 崩溃-恢复模型\n节点可能会在任何时候发生崩溃，并且会在未知的时间长度来进行恢复。但是节点上只要持久性存储的数据都可以在恢复之后得以保存，内存的状态会消失。\n#### 拜占庭失效\n在非可信任的集群中进行共识的计算，可能会出现作弊、欺诈的操作（区块链上面的假设的环境）  \n所以满足我们实际生产环境（互联网或者企业内部的环境）的是 部分同步模型+ 崩溃恢复模型的组合。\n\n我们目前的分布式的环境是 崩溃-恢复模型+ 部分同步的模型 \n\n### <span class=\"thirdtitle\">分布式共识算法的正确性必须要有以下的性质</span>\n1. 唯一性  \n两个令牌不能获得相同的值  \n2. 单调递增  \n如果请求x返回令牌tx， 请求y返回了令牌ty, 且x在y开始之前先完成，tx < ty  \n3. 可用性  \n请求令牌的节点如果不发生崩溃最终一定能收到响应（无论是对应用来说正确或者错误的回答）  \n\n#### 分布式共识算法的安全性和活性\n在正确性中其实可以再进行细分分为安全性和活性（理解上，并非准确的定义，准确的定义可以查看FLP的理论）：  \n安全性： 没有发生意外  \n活性： 预期的事情一定会发生（最终会发生）  \n\n如果违反了安全的属性，我们可以找到发生特定时间的时间点。但是违反安全属性的事件发生，必定不可逆，数据丢失。  \n活性的话无法明确具体发生的时间点，但是希望再未来某个时间点能够达到要求。  \n\n# <a id=\"ShareNote\"><span class=\"toptitle\">ShareNote</span></a>\nPS: 文章中部分的图来源是来自于《数据密集型应用系统设计》，为PDF翻译的截图，截图的引用在[此处](https://github.com/hyhlinux/DDIA/blob/master/ch8.md)。如果涉及到版权的问题，请通知我，我会使用工具继续重画。\n1. [IBM Defination of Distributed System](https://www.ibm.com/support/knowledgecenter/en/SSAL2T_8.2.0/com.ibm.cics.tx.doc/concepts/c_wht_is_distd_comptg.html)\n2. [数据密集型应用系统设计](https://book.douban.com/subject/30329536/)\n3. [FLP Impossibility](https://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/)\n4. [拜占庭错误](https://en.wikipedia.org/wiki/Byzantine_fault)\n5. [拜占庭容错](https://www.usenix.org/legacy/events/osdi99/full_papers/castro/castro_html/castro.html)\n6. [Riak](https://github.com/basho/riak_core)","source":"_posts/intro-distributed-system.md","raw":"---\ntitle: 分布式系统概念简介及其问题的描述\ndate: 2019-08-20 11:07:38\ntags: distributed-system\n---\n\n<!-- ---\n\nauthor: Ray Chan(ray1888)\ndate: 2019-08-20 11:07:38\ncategory: \nsummary: introduction of distributed system and its problem\nthumbnail: distributed-system.png\n--- -->\n\n# 目录 \n1. [什么是分布式系统](#Introduction)  \n2. [分布式系统能够解决什么问题](#Purpose)  \n   2.1 [服务器的性能扩展方案](#2.1)  \n   2.2 [分布式系统的特点](#2.2)  \n   2.3 [分布式系统解决的问题](#2.3)  \n3. [分布式系统的问题](#Problem)  \n   3.1 [网络问题](#3.1)  \n   3.2 [时钟问题](#3.2)  \n   3.3 [节点问题](#3.3)  \n4. [在不可靠硬件构建可靠软件需要满足的条件和假设](#ConditionAssumtion)  \n   4.1 [真相由多数决定](#4.1)  \n   4.2 [理论系统模型与现实](#4.2)  \n5. [ShareNote](#ShareNote)  \n\n\n# <a id=\"Introduction\"><span class=\"toptitle\">#什么是分布式系统</span></a>\n\n### 分布式系统\n\n```\n// Definantion from IBM Site \nA distributed computer system consists of multiple software components that are on multiple computers, but run as a single system. The computers that are in a distributed \nsystem can be physically close together and connected by a local network, or they can be geographically distant and connected by a wide area network. A distributed system can consist of any number of possible configurations, such as mainframes, personal computers, workstations, minicomputers, and so on. The goal of distributed computing is to make such a network work as a single computer.\n```\n\n简述：\n分布式的计算机系统是由多台形式的计算机（包括服务器、个人电脑、工作站、嵌入式系统的形式）组成的，但是对外表示成一个完整功能的系统。对于分布式系统的使用者，可以把一个大型的分布式系统看作一个黑盒来进行使用。  \n\n# <a id=\"Purpose\"><span class=\"toptitle\">#分布式系统能够解决什么问题</span></a>\n\n###  <a id=\"2.1\"><span class=\"secondtitle\">2.1. 服务器的性能扩展方案</span></a>\n\n对于一个系统来说，如果当需要计算的问题太过庞大的时候，会有两种思路来进行算力的添加  \n\n1.Scale UP（纵向扩展）  \n纵向扩展:企业后端大型服务器以增加处理器等运算资源进行升级以获得对应用性能的要求。\n这种是比较传统的思路，具有以下特点：  \n    1. 扩容的成本较高。能够支持纵向扩展的系统都需要服务商进行服务的支持，需要购买特殊的硬件。而不是使用能够通用的硬件来进行扩容  \n    2. 延迟低，单点吞吐量大。本质上是单点的系统，可以减少了很多网络上面的开销，所以延迟一般会比分布式系统的延迟更低。而且单节点如果在没有超过负荷的情况下，因为硬件堆积在上面，单节点的性能一般会比分布式的单节点性能更强。  \n    3. 备份成本高，遇到不可恢复的故障时可能要中断一定时间的服务。如果对于纵向扩展的设备需要进行灾备的情况下，可能需要同时购入相同配置的硬件通过配置主备来继续容灾，而不能通过像分布式系统在多个地域继续节点部署和配置添加达到冗余的程度。  \n  实例的系统： 传统的SAN(storage area network)系统  \n\n2.Scale Out(水平扩展)  \n水平扩展：企业可以根据需求增加不同的服务器应用，依靠多部服务器协同运算，借负载平衡及容错等功能来提高运算能力及可靠度。  \n这是从谷歌的三篇经典的分布式论文（bigtable、distributed filesystem、 mapreduce)提炼出来的特点：  \n    1. 成本低，扩展性好。使用的是市面上可以购买的通用的服务器配件，并且可以根据需求进行硬件的升级即可提升整体的性能（如存储服务器上面，把HDD更换为全闪存的NVME SSD，立刻可以在读写的吞吐量和时延上面获得具体的提升）  \n    2. 弹性好。可以通过配置动态的增删服务器，可以动态的对业务使用的服务器资源具有更好的调配，并且可以通过弹性的配置获得根据地理位置的容灾以及数据冗余功能（如金融企业中的两地三中心的需求）  \n    3. 处理单节点无法处理的问题。（最重要）  \n\n### <a id=\"2.2\"><span class=\"secondtitle\">2.2 分布式系统的特点</span></a>\n1. 扩展性强(Scalability)  \n2. 有冗余(Redundancy)  \n\n### <a id=\"2.3\"><span class=\"secondtitle\">2.3 分布式系统解决的问题</span></a>\n分布式系统最重要解决的问题是：  \n1. 处理单机无法计算的问题。  \n因为问题能够被分治成为了更小的问题，使得更弱的节点也可以进行计算  \n2. 同样的工作量下，减少计算使用的时间。  \n因为部分计算是可以并行来继续执行的，只要调度得当的情况下，可以减少单机系统中出现的等待的情况。  \n3. 在有限的成本内，可以通过多区域部署服务来降低该地区的服务的时延。  \n\n\n# <a id=\"Problem\"><span class=\"toptitle\">分布式系统的问题</span></a>\n（此部分有部分会引用到数据密集型应用系统设计（DDIA）的第8章部分的内容）  \n软件工程的世界里面没有银弹，分布式系统并不是所有问题的最优解。它在解决上述问题的情况下也引入了下面的多种问题    \n此处需要引入一个部分失效的概念：  \n```\n部分失效：在分布式系统中，可能会出现系统的一部分工作正常，其他部分出现难以预测的故障。\n```\n\n### 对于互联网服务的分布式系统的假设\n1. 需要7*24的可用状况，所以不能有服务不可用的状态\n2. 采用通用的硬件，故障率会较高，成本较低\n3. 采用IP和以太网的技术，网络可靠性不如专有网络(Fiber Channel等。。。)\n\n因为上面的三个原因可能引申出来的另外的假设  \n\n4. 系统越大，局部组件失效的概率越大。（长时间的运行时间，失效、修复、再失效是正常的状况而不能当为异常的情况去考虑）\n5. 由于局部失效的概率高，因此需要必须容忍部分节点失败，并且能够保持对外提供可用的服务\n\n<b><font color=\"#FF0000\">所以实际上我们目前大部分的分布式的系统是需要在不可靠的硬件上面通过软件容错来构建可靠的系统。</font></b>\n\n### <strong><font color=\"#FF0000\">所以分布式系统遇到的问题可以分为三个大类</font></strong>\n1. 网络类问题  \n2. 时钟问题  \n3. 节点软件和硬件的问题  \n\n## <a id=\"3.1\"><span class=\"secondtitle\">网络问题</span></a>\n对于上面的假设（主要是成本考虑）来说，一般都会采用无共享的方式来构建集群。\n\n由于通常使用的都是以太网来构建，而且以太网是异步的网络。可能会出现下面的这些情况\n1. 请求丢失  \n2. 请求再队列等待，无法发送（网络问题或者接收方繁忙在内核的队列中等待）  \n3. 远程接收节点失效（节点崩溃）  \n4. 远程节点无法响应  \n5. 远程节点有返回，但是返回过程中丢失  \n6. 远程节点处理请求，但是在返回时候被延时处理（优先级问题， 或者网络问题或则和发送方阻塞了）  \n\n\n此处需要多引入一个新概念，网络分区\n```\n网络分区（Network Partition）：当网络的一部分由于网络故障而与其他部分隔开，称之为网络分区或者网络分片\n```\n\n在工程的实践中，网络故障(丢包、链路中断、路由问题、物理设备损坏)的概率是远比想象中高， 因此在基于我们假设的前提的环境下面，必须要把网络分区和网络故障接入到软件中进行容错。\n\n对于如何处理检测是否故障，需要判断的一个问题是，是节点服务上面出现了真实的故障，还是网络的不可靠导致的服务失效的表现。\n```\n在实际生产的实践中有这样的方法来快速的在本应用层（网络正常的情况下）来进行简单的判断\n1. 通过服务注册的心跳来注册自己的服务存活，并且把死亡状态的服务实例剔除出可用服务中\n2. 检测进程是否崩溃，如果崩溃发送一个信号。（或者在我的工作经历中，使用一个进程去定时检测进程是否存活，失败了发送信号使得资源进行重启的尝试，并且上报告警）\n3. 通过交换机去查询网络的状况\n4. 通过中间件的自身监控（如Rabbitmq的web界面）来监控中间件的执行状况\n5. 定期去尝试访问网络是否通达\n```\n但是最终我们唯一能够完全判断故障的方法只有超时，来保证节点是不可用的状态（为了保证网络的不可靠问题）。\n\n### 超时引入的问题\n我们如何能够判断什么时候才是最好的超时的判断间隔呢？\n\n对于上面的这个问题， 我们引入两个问题的前置的讨论  \n1. 是什么导致我们会出现网络的不稳定  \n2. 如果出现超时之后，会有怎样的影响，会导致什么样的后果  \n\n#### 网络不稳定的原因\n根本的原因： 在设计目前的TCP/IP的协议和方法的时候，我们的目的是为了尽可能高的提高资源的利用率  \n设计的思想： 通过动态分配和竞争的机制使得动态决定那个包被发送，但是这样的方法必然会引入排队的机制  \n\n```\n// 出现网络不稳定的原因可能如下\n1. 对于交换机的角度，会有多条等待队列来进行数据报文的转发，如果符合过重，则需要等待轮询机制来等待发送的机会，并且如果数据量过多的情况下，也有可能出现数据报文被丢弃，然后被不断重试的现象\n2. 在服务器的处理中，因为Linux内核处理接收到的报文也是类似于交换机的处理模式，通过队列来对接受到的包进行排序以及复制到用户态，因此也是需要一定的时间需要处理\n3. 在TCP的协议中的重传的机制也会根据返回的报文的控制字段来减小发送窗口的大小来减少对接受方的压力，可能导致排队会提前到发送方的等待队列中。并且重传机制会进行多次的重试，引入了隐形的超时时间\n```\n\n#### 调用超时（网络超时）可能会导致的后果\n主要的影响是发生了责任的转移，可能带来可能的影响  \n1. 命令的重复执行  \n2. 数据迁移  \n3. 当整个系统处于高负荷的状态，可能会把其他正常的部分通过转移职责导致整个系统被拖垮  \n\n因此我们必须很小心调整这个超时的阈值,如果在以前的情况下，可能需要系统管理员对于在生产环境的情况下调整一定的参数来慢慢测试得出一个最优值。\n但是在最近的组建的实现中有两种新的思路\n```\n1. 通过内部的一个故障检测器来计算成功率来进行对超时阈值的控制（Akka， Cassandra， Hytrsix中有使用此种方法）\n2. 通过对数据的采集清洗和分析（AIOPS）（可能是APM(Application Performance Metric)的埋点采集数据以及对监控数据的整体清洗通过一些机器学习的模型来计算出超时的阈值）\n```\n\n## <a id=\"3.2\"><span class=\"secondtitle\">时钟问题</span></a>\n分布式的系统的时钟问题也是一个非常值得重视的问题，后面会有我自己的工作案例来说明可能出现的情况的严重性。\n\n其实对于时间我们一般分为两种的应用方式\n1. 在一段时间内的统计数据（时间段）\n2. 某些时间点是否有指定动作完成或某个历史行为的发生的时间点\n\n### 服务器时间的维护方式以及问题\n每个机器的时间可以通过两种方式来共同维护\n1. 本地时间（通过主板的石英振荡器来维护）\n2. 通过与一个准确的时间获取源来定是同步时间（NTP和Chrony就是服务于方面的协议）\n\n这两种的结合不一定能够保证这样的可信赖的分布式集群中的时间就必然是同步的\n1. 本地时间本来每个节点都可能会出现偏差\n2. 同步时间的时候必须通过网络来进行同步，而在我们上面提及的假设中，网络是不可靠的，因此可能会出现失败的情况。 \n3. NTP如果发现时间差别太大（实际生产中是时间差>=10分钟的情况下）的话会拒绝同步（但是Chrony并没有此问题）\n4. 闰秒的问题\n\n当然可以像Google维护Spanner集群那样采用高精度的原子钟加上GPS定位来保证错误在一定的可接受范围内运行（一般误差的单位为5微妙）。但是不是每个分布式系统都能够有如此之高的维护成本去使用这种方式来\n\n### 时钟的概念\n\n时钟可以分解为两个时钟的概念\n1. 物理时钟\n物理时钟:包括了两种一个是墙上时钟，一个是单调时钟。可以理解为可以通过系统时间相关的API进行获取的时钟。\n2. 逻辑时钟\n逻辑时钟：可以理解为分布式系统中全局的单调递增的事件ID，事件发生顺序与此相同。\n\n#### 物理时钟\n需要先引入一个时间调整的概念：\n<!-- ![时间跳变说明图](/assets/img/posts/TimeJump.png)   -->\n{% asset_img TimeJump.png 时间跳变说明图 %}\n如果把时间以时间轴的方式来进行表达，往时间变大的方向调整为向前调整，往时间变小的方向调整的是向后调整。\n只要发生了时间的变动，我们都可以称之为服务器发生了时间跳变。\n\n<b><font color=\"\">1. 墙上时钟 </font> </b><br>\n根据日历返回当前的时钟，就是我们平时在Linux上直接使用date命令或者语言内置的时间相关的api的输出。\n这种时钟可以与时间同步服务器后同步后进行修改，可能会出现向前调整或者向后调整的可能性\n\n<b><font color=\"\">2. 单调时钟</font></b><br>\n用于： 适合测量持续的时间段    \n单调时钟的特性：    \n    1. 保证只会向前调整    \n    2. 不需要进行同步    \n\n#### 计算和调整的方式\n在一个时间点进行对单调时间的获取，然后完成某项工作后，再去检查时间。但是这段时间的差值并没有太大的意义。\n\n#### 时间与事件的顺序问题\n\n当两个客户端对于一个分布式的数据库（非Raft或者Paxos类型，如Riak）分别进行写入的情况下（此处假设先写入的客户端为A，晚写入的客户端为B）  \n<!-- ![事件与时序冲突](/assets/img/posts/Time&EventMissmatch.png) -->\n{% asset_img Time&EventMissmatch.png 事件与时序冲突 %}\n当B虽然在发生的时间比A要晚，但是B在集群中同步完成的时间比A要早的情况写。即对外部来说A还未写入成功的情况下，先执行了B的操作，可能导致B的操作丢失（如果B的操作是依赖于A先写入的操作）。  \n上面是一个非常经典的关于分布式集群时间与事件的顺序问题。然而这种问题即使在时间同步服务精度再再提高的情况下，也无法保证它的执行的顺序与时间是一致的。  \n\n#### 工作上发生过与物理时间相关的问题\n\n<b>问题1： 发生时间跳变后，导致任务的调度器不再调度任务的情况  </b>  \n<!-- ![调度器时间跳变问题](/assets/img/posts/SchdulerTimeJump.png)   -->\n{% asset_img SchdulerTimeJump.png 调度器时间跳变问题 %}\n    现象的描述： \n    调度器默认应该定时把任务调度到线程上面，但是查看日志后发现任务并没有被调度   \n    原因解释：    \n    时间发生了向后的跳变，但是跳变的幅度大于调度的间隔，导致系统中认为调度成功，之后就没有追踪下面的状态（因为当时那部分代码的实现是再调度的时候修改调度的时间为last调度时间）    \n    解决方法：    \n    把时间从墙上时间更换为单调时间，然后添加检查执行的间隔即可。  \n  \n<b>问题2：同步时间后，由于时间差溢出导致结果溢出的问题  </b><br>\n    现象描述：    \n    从Ceph Mgr获取单个采集数据的情况下，然后发现数据变得异常的大，是一个int64是随机数  \n    原因解释：  \n    因为采用的是墙上的时候，但是发生了时间的向后调变，导致计算出来的值发生异常  \n    解决方法：  \n    把墙上时间更换为单调时间  \n\n#### 逻辑时钟\n做法： 需要一个全局的单调递增的ID。\n但是是否可以使用同步后的时间来做呢？\n答： 不可以。因为还是时间精度的不确定性。\n\n## <a id=\"3.3\"><span class=\"secondtitle\">节点本身的问题（硬件和软件）</span></a>\n比较极端但是可能出现率比较高的场景是进程出现暂停的情况\n\n1. 带GC的编程语言的GC(Garbage collection) halt\n2. 虚拟化环境的虚拟机的暂停\n3. 电脑发生休眠或者断电\n4. 上下文切换的情况下卡住了\n5. 执行同步磁盘的操作的时候（如fsync操作）\n6. 接收到信号导致进程退出的情况下\n\n# <a id=\"ConditionAssumtion\"><span class=\"toptitle\">#在不可靠硬件构建可靠软件需要满足的条件和假设</span></a>\n\n此部分为DDIA第8章的描述总结，可以理解成为读书笔记    \n\n## <a id=\"4.1\"><span class=\"secondtitle\">真相由多数决定（重要的判定条件）</span></a>\n节点不能通过自己的信息来判断自身的状态。因为节点可能出现失效、假死、甚至无法恢复的状况.可能出现的场景如下\n```\n1. 节点成功收到请求，但是因为路由问题，无法进行返回，超时后而被判失效\n2. 半断开的节点发现自己的信息没有被其他节点所确认，意识到自己网络出现问题\n3. GC halt导致无法接受请求，但是对于应用来说，切回到工作状态时候，自身状态没有变化\n```\n以上的多种情景都是实际出现问题，但是自身的状态并不会改变，因为没有收到其他节点的通知，它会一直维持原来的状态。    \n所以分布式的算法依赖节点间的相互投票与最小投票数（使用Quorum机制，m>=(n+1)/2）进行对比来产生结果,由于一个集群不会存在两个多数在同事做出相互冲突的决定，减少对特定节点的依赖。\n\n基于上面所提及节点不能通过自己的信息来判断自己的状态，我们讨论一个比较常见的问题，主节点与锁是比较常见的使用方法\n```\n可能的出现的场景\n1. 只允许一个节点作为数据库分区的主节点（Multi-Raft是其中的一种实现）\n2. 只允许一个事务或者客户端持有特定资源的锁，以防止同时并发写入带来的数据被破坏的问题\n```\n\n### <span class=\"thirdtitle\">如果由自己的状态决定可能会出现的问题</span>\n但是此处我们的假设时在分布式系统中，那么有可能出现节点中间出现了角色的切换，但是如果不加以对状态的判断，可能会出现这样的问题\n问题描述  \n<!-- ![客户端锁问题](/assets/img/posts/lockingproblem.png)   -->\n{% asset_img lockingproblem.png 客户端锁问题 %}\n客户端写入存储的时候需要先从分布式服务中获取锁，有两个客户端在线，客户端A先从服务中获取锁，然后发生了进程halt状态（可能是GC或者其他的原因）\n如果不加判断的情况下，在客户端A halt的状态的情况下，客户端B获得锁并且写入存储成功，然后客户端A从Halt状态中回复正常，客户端A认为锁还在，然后写入存储，\n如果两个客户端写入的是同一个文件的话，数据可能会出现问题。  \n### <span class=\"thirdtitle\">解决上面的问题</span>\n对于上面的问题，我们可以使用一个Fencing令牌来解决这个问题。(此机制到后面的文章还会继续详细讲解)  \n<!-- ![Fencing令牌解决锁问题](/assets/img/posts/lockingproblem2.png)   -->\n{% asset_img lockingproblem2.png Fencing令牌解决锁问题 %}\n我们在客户端A获取锁的时候给令牌赋予一个值，为33。 在客户端B获取锁的时候赋予一个令牌值34。  \n当B写入完成后，存储会把已写入令牌改为34，下一次分发的令牌为35， 这样的话，如果A带上33的令牌写入的时候直接被拒绝，能够保证一致性。  \n实际上上面这种方法不仅加上了一个令牌，而且在服务器端会有一个关于令牌的校验。这种做法非常常见。\n\n\n## <a id=\"4.2\"><span class=\"secondtitle\">理论系统模型与现实</span></a>\n对于一个在现实中能够容错的分布式系统，我们需要对预期的系统错误证明形式化的描述。我们通过定义部分的系统模型来形式化描述算法的前提条件。 \n\n<h3><b><span class=\"thirdtitle\">计时模型</span></b></h3>\n#### 同步模型\n假定有上界网络延迟和上界进程的暂停和上界时钟误差。（但是这个模型一般不存在，因为以太网的不可靠性，除非使用更加稳定的网络介质，并且使用高精度时间设备同步）\n#### 部分同步模型\n大多数情况下像一个同步系统运行，但是会有超出网络延迟，进程暂停和时钟漂移的上界。这个就是比较现实的模型，就是上面我们提到的真实环境可能出现的情况的总和。而且大部分时间比较稳定，小部分时间会有背离，但是发生背离就会出现三者中的组合的情况出现。\n#### 异步模型\n\n\n<h3><b><span class=\"thirdtitle\">节点失效模型</span></b></h3>\n#### 崩溃-中止模型\n节点以一种特定的方式发生故障，故障后，出现系统崩溃，并且节点不会再添加进入集群中，无法恢复\n#### 崩溃-恢复模型\n节点可能会在任何时候发生崩溃，并且会在未知的时间长度来进行恢复。但是节点上只要持久性存储的数据都可以在恢复之后得以保存，内存的状态会消失。\n#### 拜占庭失效\n在非可信任的集群中进行共识的计算，可能会出现作弊、欺诈的操作（区块链上面的假设的环境）  \n所以满足我们实际生产环境（互联网或者企业内部的环境）的是 部分同步模型+ 崩溃恢复模型的组合。\n\n我们目前的分布式的环境是 崩溃-恢复模型+ 部分同步的模型 \n\n### <span class=\"thirdtitle\">分布式共识算法的正确性必须要有以下的性质</span>\n1. 唯一性  \n两个令牌不能获得相同的值  \n2. 单调递增  \n如果请求x返回令牌tx， 请求y返回了令牌ty, 且x在y开始之前先完成，tx < ty  \n3. 可用性  \n请求令牌的节点如果不发生崩溃最终一定能收到响应（无论是对应用来说正确或者错误的回答）  \n\n#### 分布式共识算法的安全性和活性\n在正确性中其实可以再进行细分分为安全性和活性（理解上，并非准确的定义，准确的定义可以查看FLP的理论）：  \n安全性： 没有发生意外  \n活性： 预期的事情一定会发生（最终会发生）  \n\n如果违反了安全的属性，我们可以找到发生特定时间的时间点。但是违反安全属性的事件发生，必定不可逆，数据丢失。  \n活性的话无法明确具体发生的时间点，但是希望再未来某个时间点能够达到要求。  \n\n# <a id=\"ShareNote\"><span class=\"toptitle\">ShareNote</span></a>\nPS: 文章中部分的图来源是来自于《数据密集型应用系统设计》，为PDF翻译的截图，截图的引用在[此处](https://github.com/hyhlinux/DDIA/blob/master/ch8.md)。如果涉及到版权的问题，请通知我，我会使用工具继续重画。\n1. [IBM Defination of Distributed System](https://www.ibm.com/support/knowledgecenter/en/SSAL2T_8.2.0/com.ibm.cics.tx.doc/concepts/c_wht_is_distd_comptg.html)\n2. [数据密集型应用系统设计](https://book.douban.com/subject/30329536/)\n3. [FLP Impossibility](https://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/)\n4. [拜占庭错误](https://en.wikipedia.org/wiki/Byzantine_fault)\n5. [拜占庭容错](https://www.usenix.org/legacy/events/osdi99/full_papers/castro/castro_html/castro.html)\n6. [Riak](https://github.com/basho/riak_core)","slug":"intro-distributed-system","published":1,"updated":"2021-01-21T06:26:17.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6h2epk0004eci5cgca101l","content":"<!-- ---\n\nauthor: Ray Chan(ray1888)\ndate: 2019-08-20 11:07:38\ncategory: \nsummary: introduction of distributed system and its problem\nthumbnail: distributed-system.png\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#Introduction\">什么是分布式系统</a>  </li>\n<li><a href=\"#Purpose\">分布式系统能够解决什么问题</a><br>2.1 <a href=\"#2.1\">服务器的性能扩展方案</a><br>2.2 <a href=\"#2.2\">分布式系统的特点</a><br>2.3 <a href=\"#2.3\">分布式系统解决的问题</a>  </li>\n<li><a href=\"#Problem\">分布式系统的问题</a><br>3.1 <a href=\"#3.1\">网络问题</a><br>3.2 <a href=\"#3.2\">时钟问题</a><br>3.3 <a href=\"#3.3\">节点问题</a>  </li>\n<li><a href=\"#ConditionAssumtion\">在不可靠硬件构建可靠软件需要满足的条件和假设</a><br>4.1 <a href=\"#4.1\">真相由多数决定</a><br>4.2 <a href=\"#4.2\">理论系统模型与现实</a>  </li>\n<li><a href=\"#ShareNote\">ShareNote</a>  </li>\n</ol>\n\n        <h1 id=\"什么是分布式系统\"   >\n          <a href=\"#什么是分布式系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#什么是分布式系统</h1>\n      \n        <h3 id=\"分布式系统\"   >\n          <a href=\"#分布式系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Definantion from IBM Site </span><br><span class=\"line\">A distributed computer system consists of multiple software components that are on multiple computers, but run as a single system. The computers that are in a distributed </span><br><span class=\"line\">system can be physically close together and connected by a local network, or they can be geographically distant and connected by a wide area network. A distributed system can consist of any number of possible configurations, such as mainframes, personal computers, workstations, minicomputers, and so on. The goal of distributed computing is to make such a network work as a single computer.</span><br></pre></td></tr></table></div></figure>\n<p>简述：<br>分布式的计算机系统是由多台形式的计算机（包括服务器、个人电脑、工作站、嵌入式系统的形式）组成的，但是对外表示成一个完整功能的系统。对于分布式系统的使用者，可以把一个大型的分布式系统看作一个黑盒来进行使用。  </p>\n\n        <h1 id=\"分布式系统能够解决什么问题\"   >\n          <a href=\"#分布式系统能够解决什么问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#分布式系统能够解决什么问题</h1>\n      \n        <h3 id=\"2-1-服务器的性能扩展方案\"   >\n          <a href=\"#2-1-服务器的性能扩展方案\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.1. 服务器的性能扩展方案</h3>\n      <p>对于一个系统来说，如果当需要计算的问题太过庞大的时候，会有两种思路来进行算力的添加  </p>\n<p>1.Scale UP（纵向扩展）<br>纵向扩展:企业后端大型服务器以增加处理器等运算资源进行升级以获得对应用性能的要求。<br>这种是比较传统的思路，具有以下特点：<br>    1. 扩容的成本较高。能够支持纵向扩展的系统都需要服务商进行服务的支持，需要购买特殊的硬件。而不是使用能够通用的硬件来进行扩容<br>    2. 延迟低，单点吞吐量大。本质上是单点的系统，可以减少了很多网络上面的开销，所以延迟一般会比分布式系统的延迟更低。而且单节点如果在没有超过负荷的情况下，因为硬件堆积在上面，单节点的性能一般会比分布式的单节点性能更强。<br>    3. 备份成本高，遇到不可恢复的故障时可能要中断一定时间的服务。如果对于纵向扩展的设备需要进行灾备的情况下，可能需要同时购入相同配置的硬件通过配置主备来继续容灾，而不能通过像分布式系统在多个地域继续节点部署和配置添加达到冗余的程度。<br>  实例的系统： 传统的SAN(storage area network)系统  </p>\n<p>2.Scale Out(水平扩展)<br>水平扩展：企业可以根据需求增加不同的服务器应用，依靠多部服务器协同运算，借负载平衡及容错等功能来提高运算能力及可靠度。<br>这是从谷歌的三篇经典的分布式论文（bigtable、distributed filesystem、 mapreduce)提炼出来的特点：<br>    1. 成本低，扩展性好。使用的是市面上可以购买的通用的服务器配件，并且可以根据需求进行硬件的升级即可提升整体的性能（如存储服务器上面，把HDD更换为全闪存的NVME SSD，立刻可以在读写的吞吐量和时延上面获得具体的提升）<br>    2. 弹性好。可以通过配置动态的增删服务器，可以动态的对业务使用的服务器资源具有更好的调配，并且可以通过弹性的配置获得根据地理位置的容灾以及数据冗余功能（如金融企业中的两地三中心的需求）<br>    3. 处理单节点无法处理的问题。（最重要）  </p>\n\n        <h3 id=\"2-2-分布式系统的特点\"   >\n          <a href=\"#2-2-分布式系统的特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.2 分布式系统的特点</h3>\n      <ol>\n<li>扩展性强(Scalability)  </li>\n<li>有冗余(Redundancy)  </li>\n</ol>\n\n        <h3 id=\"2-3-分布式系统解决的问题\"   >\n          <a href=\"#2-3-分布式系统解决的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.3 分布式系统解决的问题</h3>\n      <p>分布式系统最重要解决的问题是：  </p>\n<ol>\n<li>处理单机无法计算的问题。<br>因为问题能够被分治成为了更小的问题，使得更弱的节点也可以进行计算  </li>\n<li>同样的工作量下，减少计算使用的时间。<br>因为部分计算是可以并行来继续执行的，只要调度得当的情况下，可以减少单机系统中出现的等待的情况。  </li>\n<li>在有限的成本内，可以通过多区域部署服务来降低该地区的服务的时延。  </li>\n</ol>\n\n        <h1 id=\"分布式系统的问题\"   >\n          <a href=\"#分布式系统的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统的问题</h1>\n      <p>（此部分有部分会引用到数据密集型应用系统设计（DDIA）的第8章部分的内容）<br>软件工程的世界里面没有银弹，分布式系统并不是所有问题的最优解。它在解决上述问题的情况下也引入了下面的多种问题<br>此处需要引入一个部分失效的概念：  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">部分失效：在分布式系统中，可能会出现系统的一部分工作正常，其他部分出现难以预测的故障。</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"对于互联网服务的分布式系统的假设\"   >\n          <a href=\"#对于互联网服务的分布式系统的假设\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对于互联网服务的分布式系统的假设</h3>\n      <ol>\n<li>需要7*24的可用状况，所以不能有服务不可用的状态</li>\n<li>采用通用的硬件，故障率会较高，成本较低</li>\n<li>采用IP和以太网的技术，网络可靠性不如专有网络(Fiber Channel等。。。)</li>\n</ol>\n<p>因为上面的三个原因可能引申出来的另外的假设  </p>\n<ol start=\"4\">\n<li>系统越大，局部组件失效的概率越大。（长时间的运行时间，失效、修复、再失效是正常的状况而不能当为异常的情况去考虑）</li>\n<li>由于局部失效的概率高，因此需要必须容忍部分节点失败，并且能够保持对外提供可用的服务</li>\n</ol>\n<p><b><font color=\"#FF0000\">所以实际上我们目前大部分的分布式的系统是需要在不可靠的硬件上面通过软件容错来构建可靠的系统。</font></b></p>\n\n        <h3 id=\"所以分布式系统遇到的问题可以分为三个大类\"   >\n          <a href=\"#所以分布式系统遇到的问题可以分为三个大类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>所以分布式系统遇到的问题可以分为三个大类</h3>\n      <ol>\n<li>网络类问题  </li>\n<li>时钟问题  </li>\n<li>节点软件和硬件的问题  </li>\n</ol>\n\n        <h2 id=\"网络问题\"   >\n          <a href=\"#网络问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>网络问题</h2>\n      <p>对于上面的假设（主要是成本考虑）来说，一般都会采用无共享的方式来构建集群。</p>\n<p>由于通常使用的都是以太网来构建，而且以太网是异步的网络。可能会出现下面的这些情况</p>\n<ol>\n<li>请求丢失  </li>\n<li>请求再队列等待，无法发送（网络问题或者接收方繁忙在内核的队列中等待）  </li>\n<li>远程接收节点失效（节点崩溃）  </li>\n<li>远程节点无法响应  </li>\n<li>远程节点有返回，但是返回过程中丢失  </li>\n<li>远程节点处理请求，但是在返回时候被延时处理（优先级问题， 或者网络问题或则和发送方阻塞了）  </li>\n</ol>\n<p>此处需要多引入一个新概念，网络分区</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网络分区（Network Partition）：当网络的一部分由于网络故障而与其他部分隔开，称之为网络分区或者网络分片</span><br></pre></td></tr></table></div></figure>\n<p>在工程的实践中，网络故障(丢包、链路中断、路由问题、物理设备损坏)的概率是远比想象中高， 因此在基于我们假设的前提的环境下面，必须要把网络分区和网络故障接入到软件中进行容错。</p>\n<p>对于如何处理检测是否故障，需要判断的一个问题是，是节点服务上面出现了真实的故障，还是网络的不可靠导致的服务失效的表现。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在实际生产的实践中有这样的方法来快速的在本应用层（网络正常的情况下）来进行简单的判断</span><br><span class=\"line\">1. 通过服务注册的心跳来注册自己的服务存活，并且把死亡状态的服务实例剔除出可用服务中</span><br><span class=\"line\">2. 检测进程是否崩溃，如果崩溃发送一个信号。（或者在我的工作经历中，使用一个进程去定时检测进程是否存活，失败了发送信号使得资源进行重启的尝试，并且上报告警）</span><br><span class=\"line\">3. 通过交换机去查询网络的状况</span><br><span class=\"line\">4. 通过中间件的自身监控（如Rabbitmq的web界面）来监控中间件的执行状况</span><br><span class=\"line\">5. 定期去尝试访问网络是否通达</span><br></pre></td></tr></table></div></figure>\n<p>但是最终我们唯一能够完全判断故障的方法只有超时，来保证节点是不可用的状态（为了保证网络的不可靠问题）。</p>\n\n        <h3 id=\"超时引入的问题\"   >\n          <a href=\"#超时引入的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>超时引入的问题</h3>\n      <p>我们如何能够判断什么时候才是最好的超时的判断间隔呢？</p>\n<p>对于上面的这个问题， 我们引入两个问题的前置的讨论  </p>\n<ol>\n<li>是什么导致我们会出现网络的不稳定  </li>\n<li>如果出现超时之后，会有怎样的影响，会导致什么样的后果  </li>\n</ol>\n\n        <h4 id=\"网络不稳定的原因\"   >\n          <a href=\"#网络不稳定的原因\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>网络不稳定的原因</h4>\n      <p>根本的原因： 在设计目前的TCP/IP的协议和方法的时候，我们的目的是为了尽可能高的提高资源的利用率<br>设计的思想： 通过动态分配和竞争的机制使得动态决定那个包被发送，但是这样的方法必然会引入排队的机制  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 出现网络不稳定的原因可能如下</span><br><span class=\"line\">1. 对于交换机的角度，会有多条等待队列来进行数据报文的转发，如果符合过重，则需要等待轮询机制来等待发送的机会，并且如果数据量过多的情况下，也有可能出现数据报文被丢弃，然后被不断重试的现象</span><br><span class=\"line\">2. 在服务器的处理中，因为Linux内核处理接收到的报文也是类似于交换机的处理模式，通过队列来对接受到的包进行排序以及复制到用户态，因此也是需要一定的时间需要处理</span><br><span class=\"line\">3. 在TCP的协议中的重传的机制也会根据返回的报文的控制字段来减小发送窗口的大小来减少对接受方的压力，可能导致排队会提前到发送方的等待队列中。并且重传机制会进行多次的重试，引入了隐形的超时时间</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"调用超时（网络超时）可能会导致的后果\"   >\n          <a href=\"#调用超时（网络超时）可能会导致的后果\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>调用超时（网络超时）可能会导致的后果</h4>\n      <p>主要的影响是发生了责任的转移，可能带来可能的影响  </p>\n<ol>\n<li>命令的重复执行  </li>\n<li>数据迁移  </li>\n<li>当整个系统处于高负荷的状态，可能会把其他正常的部分通过转移职责导致整个系统被拖垮  </li>\n</ol>\n<p>因此我们必须很小心调整这个超时的阈值,如果在以前的情况下，可能需要系统管理员对于在生产环境的情况下调整一定的参数来慢慢测试得出一个最优值。<br>但是在最近的组建的实现中有两种新的思路</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 通过内部的一个故障检测器来计算成功率来进行对超时阈值的控制（Akka， Cassandra， Hytrsix中有使用此种方法）</span><br><span class=\"line\">2. 通过对数据的采集清洗和分析（AIOPS）（可能是APM(Application Performance Metric)的埋点采集数据以及对监控数据的整体清洗通过一些机器学习的模型来计算出超时的阈值）</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"时钟问题\"   >\n          <a href=\"#时钟问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时钟问题</h2>\n      <p>分布式的系统的时钟问题也是一个非常值得重视的问题，后面会有我自己的工作案例来说明可能出现的情况的严重性。</p>\n<p>其实对于时间我们一般分为两种的应用方式</p>\n<ol>\n<li>在一段时间内的统计数据（时间段）</li>\n<li>某些时间点是否有指定动作完成或某个历史行为的发生的时间点</li>\n</ol>\n\n        <h3 id=\"服务器时间的维护方式以及问题\"   >\n          <a href=\"#服务器时间的维护方式以及问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>服务器时间的维护方式以及问题</h3>\n      <p>每个机器的时间可以通过两种方式来共同维护</p>\n<ol>\n<li>本地时间（通过主板的石英振荡器来维护）</li>\n<li>通过与一个准确的时间获取源来定是同步时间（NTP和Chrony就是服务于方面的协议）</li>\n</ol>\n<p>这两种的结合不一定能够保证这样的可信赖的分布式集群中的时间就必然是同步的</p>\n<ol>\n<li>本地时间本来每个节点都可能会出现偏差</li>\n<li>同步时间的时候必须通过网络来进行同步，而在我们上面提及的假设中，网络是不可靠的，因此可能会出现失败的情况。 </li>\n<li>NTP如果发现时间差别太大（实际生产中是时间差&gt;=10分钟的情况下）的话会拒绝同步（但是Chrony并没有此问题）</li>\n<li>闰秒的问题</li>\n</ol>\n<p>当然可以像Google维护Spanner集群那样采用高精度的原子钟加上GPS定位来保证错误在一定的可接受范围内运行（一般误差的单位为5微妙）。但是不是每个分布式系统都能够有如此之高的维护成本去使用这种方式来</p>\n\n        <h3 id=\"时钟的概念\"   >\n          <a href=\"#时钟的概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时钟的概念</h3>\n      <p>时钟可以分解为两个时钟的概念</p>\n<ol>\n<li>物理时钟<br>物理时钟:包括了两种一个是墙上时钟，一个是单调时钟。可以理解为可以通过系统时间相关的API进行获取的时钟。</li>\n<li>逻辑时钟<br>逻辑时钟：可以理解为分布式系统中全局的单调递增的事件ID，事件发生顺序与此相同。</li>\n</ol>\n\n        <h4 id=\"物理时钟\"   >\n          <a href=\"#物理时钟\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>物理时钟</h4>\n      <p>需要先引入一个时间调整的概念：</p>\n<!-- ![时间跳变说明图](/assets/img/posts/TimeJump.png)   -->\n<img src=\"/2019/08/20/intro-distributed-system/TimeJump.png\" class=\"\" title=\"时间跳变说明图\">\n<p>如果把时间以时间轴的方式来进行表达，往时间变大的方向调整为向前调整，往时间变小的方向调整的是向后调整。<br>只要发生了时间的变动，我们都可以称之为服务器发生了时间跳变。</p>\n<p><b><font color=\"\">1. 墙上时钟 </font> </b><br><br>根据日历返回当前的时钟，就是我们平时在Linux上直接使用date命令或者语言内置的时间相关的api的输出。<br>这种时钟可以与时间同步服务器后同步后进行修改，可能会出现向前调整或者向后调整的可能性</p>\n<p><b><font color=\"\">2. 单调时钟</font></b><br><br>用于： 适合测量持续的时间段<br>单调时钟的特性：<br>    1. 保证只会向前调整<br>    2. 不需要进行同步    </p>\n\n        <h4 id=\"计算和调整的方式\"   >\n          <a href=\"#计算和调整的方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>计算和调整的方式</h4>\n      <p>在一个时间点进行对单调时间的获取，然后完成某项工作后，再去检查时间。但是这段时间的差值并没有太大的意义。</p>\n\n        <h4 id=\"时间与事件的顺序问题\"   >\n          <a href=\"#时间与事件的顺序问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时间与事件的顺序问题</h4>\n      <p>当两个客户端对于一个分布式的数据库（非Raft或者Paxos类型，如Riak）分别进行写入的情况下（此处假设先写入的客户端为A，晚写入的客户端为B）  </p>\n<!-- ![事件与时序冲突](/assets/img/posts/Time&EventMissmatch.png) -->\n<img src=\"/2019/08/20/intro-distributed-system/Time&EventMissmatch.png\" class=\"\" title=\"事件与时序冲突\">\n<p>当B虽然在发生的时间比A要晚，但是B在集群中同步完成的时间比A要早的情况写。即对外部来说A还未写入成功的情况下，先执行了B的操作，可能导致B的操作丢失（如果B的操作是依赖于A先写入的操作）。<br>上面是一个非常经典的关于分布式集群时间与事件的顺序问题。然而这种问题即使在时间同步服务精度再再提高的情况下，也无法保证它的执行的顺序与时间是一致的。  </p>\n\n        <h4 id=\"工作上发生过与物理时间相关的问题\"   >\n          <a href=\"#工作上发生过与物理时间相关的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>工作上发生过与物理时间相关的问题</h4>\n      <p><b>问题1： 发生时间跳变后，导致任务的调度器不再调度任务的情况  </b>  </p>\n<!-- ![调度器时间跳变问题](/assets/img/posts/SchdulerTimeJump.png)   -->\n<img src=\"/2019/08/20/intro-distributed-system/SchdulerTimeJump.png\" class=\"\" title=\"调度器时间跳变问题\">\n<pre><code>现象的描述： \n调度器默认应该定时把任务调度到线程上面，但是查看日志后发现任务并没有被调度   \n原因解释：    \n时间发生了向后的跳变，但是跳变的幅度大于调度的间隔，导致系统中认为调度成功，之后就没有追踪下面的状态（因为当时那部分代码的实现是再调度的时候修改调度的时间为last调度时间）    \n解决方法：    \n把时间从墙上时间更换为单调时间，然后添加检查执行的间隔即可。  </code></pre>\n<p><b>问题2：同步时间后，由于时间差溢出导致结果溢出的问题  </b><br><br>    现象描述：<br>    从Ceph Mgr获取单个采集数据的情况下，然后发现数据变得异常的大，是一个int64是随机数<br>    原因解释：<br>    因为采用的是墙上的时候，但是发生了时间的向后调变，导致计算出来的值发生异常<br>    解决方法：<br>    把墙上时间更换为单调时间  </p>\n\n        <h4 id=\"逻辑时钟\"   >\n          <a href=\"#逻辑时钟\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>逻辑时钟</h4>\n      <p>做法： 需要一个全局的单调递增的ID。<br>但是是否可以使用同步后的时间来做呢？<br>答： 不可以。因为还是时间精度的不确定性。</p>\n\n        <h2 id=\"节点本身的问题（硬件和软件）\"   >\n          <a href=\"#节点本身的问题（硬件和软件）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>节点本身的问题（硬件和软件）</h2>\n      <p>比较极端但是可能出现率比较高的场景是进程出现暂停的情况</p>\n<ol>\n<li>带GC的编程语言的GC(Garbage collection) halt</li>\n<li>虚拟化环境的虚拟机的暂停</li>\n<li>电脑发生休眠或者断电</li>\n<li>上下文切换的情况下卡住了</li>\n<li>执行同步磁盘的操作的时候（如fsync操作）</li>\n<li>接收到信号导致进程退出的情况下</li>\n</ol>\n\n        <h1 id=\"在不可靠硬件构建可靠软件需要满足的条件和假设\"   >\n          <a href=\"#在不可靠硬件构建可靠软件需要满足的条件和假设\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#在不可靠硬件构建可靠软件需要满足的条件和假设</h1>\n      <p>此部分为DDIA第8章的描述总结，可以理解成为读书笔记    </p>\n\n        <h2 id=\"真相由多数决定（重要的判定条件）\"   >\n          <a href=\"#真相由多数决定（重要的判定条件）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>真相由多数决定（重要的判定条件）</h2>\n      <p>节点不能通过自己的信息来判断自身的状态。因为节点可能出现失效、假死、甚至无法恢复的状况.可能出现的场景如下</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 节点成功收到请求，但是因为路由问题，无法进行返回，超时后而被判失效</span><br><span class=\"line\">2. 半断开的节点发现自己的信息没有被其他节点所确认，意识到自己网络出现问题</span><br><span class=\"line\">3. GC halt导致无法接受请求，但是对于应用来说，切回到工作状态时候，自身状态没有变化</span><br></pre></td></tr></table></div></figure>\n<p>以上的多种情景都是实际出现问题，但是自身的状态并不会改变，因为没有收到其他节点的通知，它会一直维持原来的状态。<br>所以分布式的算法依赖节点间的相互投票与最小投票数（使用Quorum机制，m&gt;=(n+1)/2）进行对比来产生结果,由于一个集群不会存在两个多数在同事做出相互冲突的决定，减少对特定节点的依赖。</p>\n<p>基于上面所提及节点不能通过自己的信息来判断自己的状态，我们讨论一个比较常见的问题，主节点与锁是比较常见的使用方法</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可能的出现的场景</span><br><span class=\"line\">1. 只允许一个节点作为数据库分区的主节点（Multi-Raft是其中的一种实现）</span><br><span class=\"line\">2. 只允许一个事务或者客户端持有特定资源的锁，以防止同时并发写入带来的数据被破坏的问题</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"如果由自己的状态决定可能会出现的问题\"   >\n          <a href=\"#如果由自己的状态决定可能会出现的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如果由自己的状态决定可能会出现的问题</h3>\n      <p>但是此处我们的假设时在分布式系统中，那么有可能出现节点中间出现了角色的切换，但是如果不加以对状态的判断，可能会出现这样的问题<br>问题描述  </p>\n<!-- ![客户端锁问题](/assets/img/posts/lockingproblem.png)   -->\n<img src=\"/2019/08/20/intro-distributed-system/lockingproblem.png\" class=\"\" title=\"客户端锁问题\">\n<p>客户端写入存储的时候需要先从分布式服务中获取锁，有两个客户端在线，客户端A先从服务中获取锁，然后发生了进程halt状态（可能是GC或者其他的原因）<br>如果不加判断的情况下，在客户端A halt的状态的情况下，客户端B获得锁并且写入存储成功，然后客户端A从Halt状态中回复正常，客户端A认为锁还在，然后写入存储，<br>如果两个客户端写入的是同一个文件的话，数据可能会出现问题。  </p>\n\n        <h3 id=\"解决上面的问题\"   >\n          <a href=\"#解决上面的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>解决上面的问题</h3>\n      <p>对于上面的问题，我们可以使用一个Fencing令牌来解决这个问题。(此机制到后面的文章还会继续详细讲解)  </p>\n<!-- ![Fencing令牌解决锁问题](/assets/img/posts/lockingproblem2.png)   -->\n<img src=\"/2019/08/20/intro-distributed-system/lockingproblem2.png\" class=\"\" title=\"Fencing令牌解决锁问题\">\n<p>我们在客户端A获取锁的时候给令牌赋予一个值，为33。 在客户端B获取锁的时候赋予一个令牌值34。<br>当B写入完成后，存储会把已写入令牌改为34，下一次分发的令牌为35， 这样的话，如果A带上33的令牌写入的时候直接被拒绝，能够保证一致性。<br>实际上上面这种方法不仅加上了一个令牌，而且在服务器端会有一个关于令牌的校验。这种做法非常常见。</p>\n\n        <h2 id=\"理论系统模型与现实\"   >\n          <a href=\"#理论系统模型与现实\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>理论系统模型与现实</h2>\n      <p>对于一个在现实中能够容错的分布式系统，我们需要对预期的系统错误证明形式化的描述。我们通过定义部分的系统模型来形式化描述算法的前提条件。 </p>\n<h3><b><span class=\"thirdtitle\">计时模型</span></b></h3>\n#### 同步模型\n假定有上界网络延迟和上界进程的暂停和上界时钟误差。（但是这个模型一般不存在，因为以太网的不可靠性，除非使用更加稳定的网络介质，并且使用高精度时间设备同步）\n#### 部分同步模型\n大多数情况下像一个同步系统运行，但是会有超出网络延迟，进程暂停和时钟漂移的上界。这个就是比较现实的模型，就是上面我们提到的真实环境可能出现的情况的总和。而且大部分时间比较稳定，小部分时间会有背离，但是发生背离就会出现三者中的组合的情况出现。\n#### 异步模型\n\n\n<h3><b><span class=\"thirdtitle\">节点失效模型</span></b></h3>\n#### 崩溃-中止模型\n节点以一种特定的方式发生故障，故障后，出现系统崩溃，并且节点不会再添加进入集群中，无法恢复\n#### 崩溃-恢复模型\n节点可能会在任何时候发生崩溃，并且会在未知的时间长度来进行恢复。但是节点上只要持久性存储的数据都可以在恢复之后得以保存，内存的状态会消失。\n#### 拜占庭失效\n在非可信任的集群中进行共识的计算，可能会出现作弊、欺诈的操作（区块链上面的假设的环境）  \n所以满足我们实际生产环境（互联网或者企业内部的环境）的是 部分同步模型+ 崩溃恢复模型的组合。\n\n<p>我们目前的分布式的环境是 崩溃-恢复模型+ 部分同步的模型 </p>\n\n        <h3 id=\"分布式共识算法的正确性必须要有以下的性质\"   >\n          <a href=\"#分布式共识算法的正确性必须要有以下的性质\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识算法的正确性必须要有以下的性质</h3>\n      <ol>\n<li>唯一性<br>两个令牌不能获得相同的值  </li>\n<li>单调递增<br>如果请求x返回令牌tx， 请求y返回了令牌ty, 且x在y开始之前先完成，tx &lt; ty  </li>\n<li>可用性<br>请求令牌的节点如果不发生崩溃最终一定能收到响应（无论是对应用来说正确或者错误的回答）  </li>\n</ol>\n\n        <h4 id=\"分布式共识算法的安全性和活性\"   >\n          <a href=\"#分布式共识算法的安全性和活性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识算法的安全性和活性</h4>\n      <p>在正确性中其实可以再进行细分分为安全性和活性（理解上，并非准确的定义，准确的定义可以查看FLP的理论）：<br>安全性： 没有发生意外<br>活性： 预期的事情一定会发生（最终会发生）  </p>\n<p>如果违反了安全的属性，我们可以找到发生特定时间的时间点。但是违反安全属性的事件发生，必定不可逆，数据丢失。<br>活性的话无法明确具体发生的时间点，但是希望再未来某个时间点能够达到要求。  </p>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <p>PS: 文章中部分的图来源是来自于《数据密集型应用系统设计》，为PDF翻译的截图，截图的引用在<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/hyhlinux/DDIA/blob/master/ch8.md\" >此处</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>。如果涉及到版权的问题，请通知我，我会使用工具继续重画。</p>\n<ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.ibm.com/support/knowledgecenter/en/SSAL2T_8.2.0/com.ibm.cics.tx.doc/concepts/c_wht_is_distd_comptg.html\" >IBM Defination of Distributed System</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://book.douban.com/subject/30329536/\" >数据密集型应用系统设计</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/\" >FLP Impossibility</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://en.wikipedia.org/wiki/Byzantine_fault\" >拜占庭错误</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.usenix.org/legacy/events/osdi99/full_papers/castro/castro_html/castro.html\" >拜占庭容错</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/basho/riak_core\" >Riak</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<!-- ---\n\nauthor: Ray Chan(ray1888)\ndate: 2019-08-20 11:07:38\ncategory: \nsummary: introduction of distributed system and its problem\nthumbnail: distributed-system.png\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#Introduction\">什么是分布式系统</a>  </li>\n<li><a href=\"#Purpose\">分布式系统能够解决什么问题</a><br>2.1 <a href=\"#2.1\">服务器的性能扩展方案</a><br>2.2 <a href=\"#2.2\">分布式系统的特点</a><br>2.3 <a href=\"#2.3\">分布式系统解决的问题</a>  </li>\n<li><a href=\"#Problem\">分布式系统的问题</a><br>3.1 <a href=\"#3.1\">网络问题</a><br>3.2 <a href=\"#3.2\">时钟问题</a><br>3.3 <a href=\"#3.3\">节点问题</a>  </li>\n<li><a href=\"#ConditionAssumtion\">在不可靠硬件构建可靠软件需要满足的条件和假设</a><br>4.1 <a href=\"#4.1\">真相由多数决定</a><br>4.2 <a href=\"#4.2\">理论系统模型与现实</a>  </li>\n<li><a href=\"#ShareNote\">ShareNote</a>  </li>\n</ol>\n\n        <h1 id=\"什么是分布式系统\"   >\n          <a href=\"#什么是分布式系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#什么是分布式系统</h1>\n      \n        <h3 id=\"分布式系统\"   >\n          <a href=\"#分布式系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Definantion from IBM Site </span><br><span class=\"line\">A distributed computer system consists of multiple software components that are on multiple computers, but run as a single system. The computers that are in a distributed </span><br><span class=\"line\">system can be physically close together and connected by a local network, or they can be geographically distant and connected by a wide area network. A distributed system can consist of any number of possible configurations, such as mainframes, personal computers, workstations, minicomputers, and so on. The goal of distributed computing is to make such a network work as a single computer.</span><br></pre></td></tr></table></div></figure>\n<p>简述：<br>分布式的计算机系统是由多台形式的计算机（包括服务器、个人电脑、工作站、嵌入式系统的形式）组成的，但是对外表示成一个完整功能的系统。对于分布式系统的使用者，可以把一个大型的分布式系统看作一个黑盒来进行使用。  </p>\n\n        <h1 id=\"分布式系统能够解决什么问题\"   >\n          <a href=\"#分布式系统能够解决什么问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#分布式系统能够解决什么问题</h1>\n      \n        <h3 id=\"2-1-服务器的性能扩展方案\"   >\n          <a href=\"#2-1-服务器的性能扩展方案\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.1. 服务器的性能扩展方案</h3>\n      <p>对于一个系统来说，如果当需要计算的问题太过庞大的时候，会有两种思路来进行算力的添加  </p>\n<p>1.Scale UP（纵向扩展）<br>纵向扩展:企业后端大型服务器以增加处理器等运算资源进行升级以获得对应用性能的要求。<br>这种是比较传统的思路，具有以下特点：<br>    1. 扩容的成本较高。能够支持纵向扩展的系统都需要服务商进行服务的支持，需要购买特殊的硬件。而不是使用能够通用的硬件来进行扩容<br>    2. 延迟低，单点吞吐量大。本质上是单点的系统，可以减少了很多网络上面的开销，所以延迟一般会比分布式系统的延迟更低。而且单节点如果在没有超过负荷的情况下，因为硬件堆积在上面，单节点的性能一般会比分布式的单节点性能更强。<br>    3. 备份成本高，遇到不可恢复的故障时可能要中断一定时间的服务。如果对于纵向扩展的设备需要进行灾备的情况下，可能需要同时购入相同配置的硬件通过配置主备来继续容灾，而不能通过像分布式系统在多个地域继续节点部署和配置添加达到冗余的程度。<br>  实例的系统： 传统的SAN(storage area network)系统  </p>\n<p>2.Scale Out(水平扩展)<br>水平扩展：企业可以根据需求增加不同的服务器应用，依靠多部服务器协同运算，借负载平衡及容错等功能来提高运算能力及可靠度。<br>这是从谷歌的三篇经典的分布式论文（bigtable、distributed filesystem、 mapreduce)提炼出来的特点：<br>    1. 成本低，扩展性好。使用的是市面上可以购买的通用的服务器配件，并且可以根据需求进行硬件的升级即可提升整体的性能（如存储服务器上面，把HDD更换为全闪存的NVME SSD，立刻可以在读写的吞吐量和时延上面获得具体的提升）<br>    2. 弹性好。可以通过配置动态的增删服务器，可以动态的对业务使用的服务器资源具有更好的调配，并且可以通过弹性的配置获得根据地理位置的容灾以及数据冗余功能（如金融企业中的两地三中心的需求）<br>    3. 处理单节点无法处理的问题。（最重要）  </p>\n\n        <h3 id=\"2-2-分布式系统的特点\"   >\n          <a href=\"#2-2-分布式系统的特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.2 分布式系统的特点</h3>\n      <ol>\n<li>扩展性强(Scalability)  </li>\n<li>有冗余(Redundancy)  </li>\n</ol>\n\n        <h3 id=\"2-3-分布式系统解决的问题\"   >\n          <a href=\"#2-3-分布式系统解决的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.3 分布式系统解决的问题</h3>\n      <p>分布式系统最重要解决的问题是：  </p>\n<ol>\n<li>处理单机无法计算的问题。<br>因为问题能够被分治成为了更小的问题，使得更弱的节点也可以进行计算  </li>\n<li>同样的工作量下，减少计算使用的时间。<br>因为部分计算是可以并行来继续执行的，只要调度得当的情况下，可以减少单机系统中出现的等待的情况。  </li>\n<li>在有限的成本内，可以通过多区域部署服务来降低该地区的服务的时延。  </li>\n</ol>\n\n        <h1 id=\"分布式系统的问题\"   >\n          <a href=\"#分布式系统的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统的问题</h1>\n      <p>（此部分有部分会引用到数据密集型应用系统设计（DDIA）的第8章部分的内容）<br>软件工程的世界里面没有银弹，分布式系统并不是所有问题的最优解。它在解决上述问题的情况下也引入了下面的多种问题<br>此处需要引入一个部分失效的概念：  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">部分失效：在分布式系统中，可能会出现系统的一部分工作正常，其他部分出现难以预测的故障。</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"对于互联网服务的分布式系统的假设\"   >\n          <a href=\"#对于互联网服务的分布式系统的假设\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对于互联网服务的分布式系统的假设</h3>\n      <ol>\n<li>需要7*24的可用状况，所以不能有服务不可用的状态</li>\n<li>采用通用的硬件，故障率会较高，成本较低</li>\n<li>采用IP和以太网的技术，网络可靠性不如专有网络(Fiber Channel等。。。)</li>\n</ol>\n<p>因为上面的三个原因可能引申出来的另外的假设  </p>\n<ol start=\"4\">\n<li>系统越大，局部组件失效的概率越大。（长时间的运行时间，失效、修复、再失效是正常的状况而不能当为异常的情况去考虑）</li>\n<li>由于局部失效的概率高，因此需要必须容忍部分节点失败，并且能够保持对外提供可用的服务</li>\n</ol>\n<p><b><font color=\"#FF0000\">所以实际上我们目前大部分的分布式的系统是需要在不可靠的硬件上面通过软件容错来构建可靠的系统。</font></b></p>\n\n        <h3 id=\"所以分布式系统遇到的问题可以分为三个大类\"   >\n          <a href=\"#所以分布式系统遇到的问题可以分为三个大类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>所以分布式系统遇到的问题可以分为三个大类</h3>\n      <ol>\n<li>网络类问题  </li>\n<li>时钟问题  </li>\n<li>节点软件和硬件的问题  </li>\n</ol>\n\n        <h2 id=\"网络问题\"   >\n          <a href=\"#网络问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>网络问题</h2>\n      <p>对于上面的假设（主要是成本考虑）来说，一般都会采用无共享的方式来构建集群。</p>\n<p>由于通常使用的都是以太网来构建，而且以太网是异步的网络。可能会出现下面的这些情况</p>\n<ol>\n<li>请求丢失  </li>\n<li>请求再队列等待，无法发送（网络问题或者接收方繁忙在内核的队列中等待）  </li>\n<li>远程接收节点失效（节点崩溃）  </li>\n<li>远程节点无法响应  </li>\n<li>远程节点有返回，但是返回过程中丢失  </li>\n<li>远程节点处理请求，但是在返回时候被延时处理（优先级问题， 或者网络问题或则和发送方阻塞了）  </li>\n</ol>\n<p>此处需要多引入一个新概念，网络分区</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网络分区（Network Partition）：当网络的一部分由于网络故障而与其他部分隔开，称之为网络分区或者网络分片</span><br></pre></td></tr></table></div></figure>\n<p>在工程的实践中，网络故障(丢包、链路中断、路由问题、物理设备损坏)的概率是远比想象中高， 因此在基于我们假设的前提的环境下面，必须要把网络分区和网络故障接入到软件中进行容错。</p>\n<p>对于如何处理检测是否故障，需要判断的一个问题是，是节点服务上面出现了真实的故障，还是网络的不可靠导致的服务失效的表现。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在实际生产的实践中有这样的方法来快速的在本应用层（网络正常的情况下）来进行简单的判断</span><br><span class=\"line\">1. 通过服务注册的心跳来注册自己的服务存活，并且把死亡状态的服务实例剔除出可用服务中</span><br><span class=\"line\">2. 检测进程是否崩溃，如果崩溃发送一个信号。（或者在我的工作经历中，使用一个进程去定时检测进程是否存活，失败了发送信号使得资源进行重启的尝试，并且上报告警）</span><br><span class=\"line\">3. 通过交换机去查询网络的状况</span><br><span class=\"line\">4. 通过中间件的自身监控（如Rabbitmq的web界面）来监控中间件的执行状况</span><br><span class=\"line\">5. 定期去尝试访问网络是否通达</span><br></pre></td></tr></table></div></figure>\n<p>但是最终我们唯一能够完全判断故障的方法只有超时，来保证节点是不可用的状态（为了保证网络的不可靠问题）。</p>\n\n        <h3 id=\"超时引入的问题\"   >\n          <a href=\"#超时引入的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>超时引入的问题</h3>\n      <p>我们如何能够判断什么时候才是最好的超时的判断间隔呢？</p>\n<p>对于上面的这个问题， 我们引入两个问题的前置的讨论  </p>\n<ol>\n<li>是什么导致我们会出现网络的不稳定  </li>\n<li>如果出现超时之后，会有怎样的影响，会导致什么样的后果  </li>\n</ol>\n\n        <h4 id=\"网络不稳定的原因\"   >\n          <a href=\"#网络不稳定的原因\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>网络不稳定的原因</h4>\n      <p>根本的原因： 在设计目前的TCP/IP的协议和方法的时候，我们的目的是为了尽可能高的提高资源的利用率<br>设计的思想： 通过动态分配和竞争的机制使得动态决定那个包被发送，但是这样的方法必然会引入排队的机制  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 出现网络不稳定的原因可能如下</span><br><span class=\"line\">1. 对于交换机的角度，会有多条等待队列来进行数据报文的转发，如果符合过重，则需要等待轮询机制来等待发送的机会，并且如果数据量过多的情况下，也有可能出现数据报文被丢弃，然后被不断重试的现象</span><br><span class=\"line\">2. 在服务器的处理中，因为Linux内核处理接收到的报文也是类似于交换机的处理模式，通过队列来对接受到的包进行排序以及复制到用户态，因此也是需要一定的时间需要处理</span><br><span class=\"line\">3. 在TCP的协议中的重传的机制也会根据返回的报文的控制字段来减小发送窗口的大小来减少对接受方的压力，可能导致排队会提前到发送方的等待队列中。并且重传机制会进行多次的重试，引入了隐形的超时时间</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"调用超时（网络超时）可能会导致的后果\"   >\n          <a href=\"#调用超时（网络超时）可能会导致的后果\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>调用超时（网络超时）可能会导致的后果</h4>\n      <p>主要的影响是发生了责任的转移，可能带来可能的影响  </p>\n<ol>\n<li>命令的重复执行  </li>\n<li>数据迁移  </li>\n<li>当整个系统处于高负荷的状态，可能会把其他正常的部分通过转移职责导致整个系统被拖垮  </li>\n</ol>\n<p>因此我们必须很小心调整这个超时的阈值,如果在以前的情况下，可能需要系统管理员对于在生产环境的情况下调整一定的参数来慢慢测试得出一个最优值。<br>但是在最近的组建的实现中有两种新的思路</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 通过内部的一个故障检测器来计算成功率来进行对超时阈值的控制（Akka， Cassandra， Hytrsix中有使用此种方法）</span><br><span class=\"line\">2. 通过对数据的采集清洗和分析（AIOPS）（可能是APM(Application Performance Metric)的埋点采集数据以及对监控数据的整体清洗通过一些机器学习的模型来计算出超时的阈值）</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"时钟问题\"   >\n          <a href=\"#时钟问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时钟问题</h2>\n      <p>分布式的系统的时钟问题也是一个非常值得重视的问题，后面会有我自己的工作案例来说明可能出现的情况的严重性。</p>\n<p>其实对于时间我们一般分为两种的应用方式</p>\n<ol>\n<li>在一段时间内的统计数据（时间段）</li>\n<li>某些时间点是否有指定动作完成或某个历史行为的发生的时间点</li>\n</ol>\n\n        <h3 id=\"服务器时间的维护方式以及问题\"   >\n          <a href=\"#服务器时间的维护方式以及问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>服务器时间的维护方式以及问题</h3>\n      <p>每个机器的时间可以通过两种方式来共同维护</p>\n<ol>\n<li>本地时间（通过主板的石英振荡器来维护）</li>\n<li>通过与一个准确的时间获取源来定是同步时间（NTP和Chrony就是服务于方面的协议）</li>\n</ol>\n<p>这两种的结合不一定能够保证这样的可信赖的分布式集群中的时间就必然是同步的</p>\n<ol>\n<li>本地时间本来每个节点都可能会出现偏差</li>\n<li>同步时间的时候必须通过网络来进行同步，而在我们上面提及的假设中，网络是不可靠的，因此可能会出现失败的情况。 </li>\n<li>NTP如果发现时间差别太大（实际生产中是时间差&gt;=10分钟的情况下）的话会拒绝同步（但是Chrony并没有此问题）</li>\n<li>闰秒的问题</li>\n</ol>\n<p>当然可以像Google维护Spanner集群那样采用高精度的原子钟加上GPS定位来保证错误在一定的可接受范围内运行（一般误差的单位为5微妙）。但是不是每个分布式系统都能够有如此之高的维护成本去使用这种方式来</p>\n\n        <h3 id=\"时钟的概念\"   >\n          <a href=\"#时钟的概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时钟的概念</h3>\n      <p>时钟可以分解为两个时钟的概念</p>\n<ol>\n<li>物理时钟<br>物理时钟:包括了两种一个是墙上时钟，一个是单调时钟。可以理解为可以通过系统时间相关的API进行获取的时钟。</li>\n<li>逻辑时钟<br>逻辑时钟：可以理解为分布式系统中全局的单调递增的事件ID，事件发生顺序与此相同。</li>\n</ol>\n\n        <h4 id=\"物理时钟\"   >\n          <a href=\"#物理时钟\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>物理时钟</h4>\n      <p>需要先引入一个时间调整的概念：</p>\n<!-- ![时间跳变说明图](/assets/img/posts/TimeJump.png)   -->\n<img src=\"/2019/08/20/intro-distributed-system/TimeJump.png\" class=\"\" title=\"时间跳变说明图\">\n<p>如果把时间以时间轴的方式来进行表达，往时间变大的方向调整为向前调整，往时间变小的方向调整的是向后调整。<br>只要发生了时间的变动，我们都可以称之为服务器发生了时间跳变。</p>\n<p><b><font color=\"\">1. 墙上时钟 </font> </b><br><br>根据日历返回当前的时钟，就是我们平时在Linux上直接使用date命令或者语言内置的时间相关的api的输出。<br>这种时钟可以与时间同步服务器后同步后进行修改，可能会出现向前调整或者向后调整的可能性</p>\n<p><b><font color=\"\">2. 单调时钟</font></b><br><br>用于： 适合测量持续的时间段<br>单调时钟的特性：<br>    1. 保证只会向前调整<br>    2. 不需要进行同步    </p>\n\n        <h4 id=\"计算和调整的方式\"   >\n          <a href=\"#计算和调整的方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>计算和调整的方式</h4>\n      <p>在一个时间点进行对单调时间的获取，然后完成某项工作后，再去检查时间。但是这段时间的差值并没有太大的意义。</p>\n\n        <h4 id=\"时间与事件的顺序问题\"   >\n          <a href=\"#时间与事件的顺序问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时间与事件的顺序问题</h4>\n      <p>当两个客户端对于一个分布式的数据库（非Raft或者Paxos类型，如Riak）分别进行写入的情况下（此处假设先写入的客户端为A，晚写入的客户端为B）  </p>\n<!-- ![事件与时序冲突](/assets/img/posts/Time&EventMissmatch.png) -->\n<img src=\"/2019/08/20/intro-distributed-system/Time&EventMissmatch.png\" class=\"\" title=\"事件与时序冲突\">\n<p>当B虽然在发生的时间比A要晚，但是B在集群中同步完成的时间比A要早的情况写。即对外部来说A还未写入成功的情况下，先执行了B的操作，可能导致B的操作丢失（如果B的操作是依赖于A先写入的操作）。<br>上面是一个非常经典的关于分布式集群时间与事件的顺序问题。然而这种问题即使在时间同步服务精度再再提高的情况下，也无法保证它的执行的顺序与时间是一致的。  </p>\n\n        <h4 id=\"工作上发生过与物理时间相关的问题\"   >\n          <a href=\"#工作上发生过与物理时间相关的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>工作上发生过与物理时间相关的问题</h4>\n      <p><b>问题1： 发生时间跳变后，导致任务的调度器不再调度任务的情况  </b>  </p>\n<!-- ![调度器时间跳变问题](/assets/img/posts/SchdulerTimeJump.png)   -->\n<img src=\"/2019/08/20/intro-distributed-system/SchdulerTimeJump.png\" class=\"\" title=\"调度器时间跳变问题\">\n<pre><code>现象的描述： \n调度器默认应该定时把任务调度到线程上面，但是查看日志后发现任务并没有被调度   \n原因解释：    \n时间发生了向后的跳变，但是跳变的幅度大于调度的间隔，导致系统中认为调度成功，之后就没有追踪下面的状态（因为当时那部分代码的实现是再调度的时候修改调度的时间为last调度时间）    \n解决方法：    \n把时间从墙上时间更换为单调时间，然后添加检查执行的间隔即可。  </code></pre>\n<p><b>问题2：同步时间后，由于时间差溢出导致结果溢出的问题  </b><br><br>    现象描述：<br>    从Ceph Mgr获取单个采集数据的情况下，然后发现数据变得异常的大，是一个int64是随机数<br>    原因解释：<br>    因为采用的是墙上的时候，但是发生了时间的向后调变，导致计算出来的值发生异常<br>    解决方法：<br>    把墙上时间更换为单调时间  </p>\n\n        <h4 id=\"逻辑时钟\"   >\n          <a href=\"#逻辑时钟\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>逻辑时钟</h4>\n      <p>做法： 需要一个全局的单调递增的ID。<br>但是是否可以使用同步后的时间来做呢？<br>答： 不可以。因为还是时间精度的不确定性。</p>\n\n        <h2 id=\"节点本身的问题（硬件和软件）\"   >\n          <a href=\"#节点本身的问题（硬件和软件）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>节点本身的问题（硬件和软件）</h2>\n      <p>比较极端但是可能出现率比较高的场景是进程出现暂停的情况</p>\n<ol>\n<li>带GC的编程语言的GC(Garbage collection) halt</li>\n<li>虚拟化环境的虚拟机的暂停</li>\n<li>电脑发生休眠或者断电</li>\n<li>上下文切换的情况下卡住了</li>\n<li>执行同步磁盘的操作的时候（如fsync操作）</li>\n<li>接收到信号导致进程退出的情况下</li>\n</ol>\n\n        <h1 id=\"在不可靠硬件构建可靠软件需要满足的条件和假设\"   >\n          <a href=\"#在不可靠硬件构建可靠软件需要满足的条件和假设\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#在不可靠硬件构建可靠软件需要满足的条件和假设</h1>\n      <p>此部分为DDIA第8章的描述总结，可以理解成为读书笔记    </p>\n\n        <h2 id=\"真相由多数决定（重要的判定条件）\"   >\n          <a href=\"#真相由多数决定（重要的判定条件）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>真相由多数决定（重要的判定条件）</h2>\n      <p>节点不能通过自己的信息来判断自身的状态。因为节点可能出现失效、假死、甚至无法恢复的状况.可能出现的场景如下</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 节点成功收到请求，但是因为路由问题，无法进行返回，超时后而被判失效</span><br><span class=\"line\">2. 半断开的节点发现自己的信息没有被其他节点所确认，意识到自己网络出现问题</span><br><span class=\"line\">3. GC halt导致无法接受请求，但是对于应用来说，切回到工作状态时候，自身状态没有变化</span><br></pre></td></tr></table></div></figure>\n<p>以上的多种情景都是实际出现问题，但是自身的状态并不会改变，因为没有收到其他节点的通知，它会一直维持原来的状态。<br>所以分布式的算法依赖节点间的相互投票与最小投票数（使用Quorum机制，m&gt;=(n+1)/2）进行对比来产生结果,由于一个集群不会存在两个多数在同事做出相互冲突的决定，减少对特定节点的依赖。</p>\n<p>基于上面所提及节点不能通过自己的信息来判断自己的状态，我们讨论一个比较常见的问题，主节点与锁是比较常见的使用方法</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可能的出现的场景</span><br><span class=\"line\">1. 只允许一个节点作为数据库分区的主节点（Multi-Raft是其中的一种实现）</span><br><span class=\"line\">2. 只允许一个事务或者客户端持有特定资源的锁，以防止同时并发写入带来的数据被破坏的问题</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"如果由自己的状态决定可能会出现的问题\"   >\n          <a href=\"#如果由自己的状态决定可能会出现的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如果由自己的状态决定可能会出现的问题</h3>\n      <p>但是此处我们的假设时在分布式系统中，那么有可能出现节点中间出现了角色的切换，但是如果不加以对状态的判断，可能会出现这样的问题<br>问题描述  </p>\n<!-- ![客户端锁问题](/assets/img/posts/lockingproblem.png)   -->\n<img src=\"/2019/08/20/intro-distributed-system/lockingproblem.png\" class=\"\" title=\"客户端锁问题\">\n<p>客户端写入存储的时候需要先从分布式服务中获取锁，有两个客户端在线，客户端A先从服务中获取锁，然后发生了进程halt状态（可能是GC或者其他的原因）<br>如果不加判断的情况下，在客户端A halt的状态的情况下，客户端B获得锁并且写入存储成功，然后客户端A从Halt状态中回复正常，客户端A认为锁还在，然后写入存储，<br>如果两个客户端写入的是同一个文件的话，数据可能会出现问题。  </p>\n\n        <h3 id=\"解决上面的问题\"   >\n          <a href=\"#解决上面的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>解决上面的问题</h3>\n      <p>对于上面的问题，我们可以使用一个Fencing令牌来解决这个问题。(此机制到后面的文章还会继续详细讲解)  </p>\n<!-- ![Fencing令牌解决锁问题](/assets/img/posts/lockingproblem2.png)   -->\n<img src=\"/2019/08/20/intro-distributed-system/lockingproblem2.png\" class=\"\" title=\"Fencing令牌解决锁问题\">\n<p>我们在客户端A获取锁的时候给令牌赋予一个值，为33。 在客户端B获取锁的时候赋予一个令牌值34。<br>当B写入完成后，存储会把已写入令牌改为34，下一次分发的令牌为35， 这样的话，如果A带上33的令牌写入的时候直接被拒绝，能够保证一致性。<br>实际上上面这种方法不仅加上了一个令牌，而且在服务器端会有一个关于令牌的校验。这种做法非常常见。</p>\n\n        <h2 id=\"理论系统模型与现实\"   >\n          <a href=\"#理论系统模型与现实\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>理论系统模型与现实</h2>\n      <p>对于一个在现实中能够容错的分布式系统，我们需要对预期的系统错误证明形式化的描述。我们通过定义部分的系统模型来形式化描述算法的前提条件。 </p>\n<h3><b><span class=\"thirdtitle\">计时模型</span></b></h3>\n#### 同步模型\n假定有上界网络延迟和上界进程的暂停和上界时钟误差。（但是这个模型一般不存在，因为以太网的不可靠性，除非使用更加稳定的网络介质，并且使用高精度时间设备同步）\n#### 部分同步模型\n大多数情况下像一个同步系统运行，但是会有超出网络延迟，进程暂停和时钟漂移的上界。这个就是比较现实的模型，就是上面我们提到的真实环境可能出现的情况的总和。而且大部分时间比较稳定，小部分时间会有背离，但是发生背离就会出现三者中的组合的情况出现。\n#### 异步模型\n\n\n<h3><b><span class=\"thirdtitle\">节点失效模型</span></b></h3>\n#### 崩溃-中止模型\n节点以一种特定的方式发生故障，故障后，出现系统崩溃，并且节点不会再添加进入集群中，无法恢复\n#### 崩溃-恢复模型\n节点可能会在任何时候发生崩溃，并且会在未知的时间长度来进行恢复。但是节点上只要持久性存储的数据都可以在恢复之后得以保存，内存的状态会消失。\n#### 拜占庭失效\n在非可信任的集群中进行共识的计算，可能会出现作弊、欺诈的操作（区块链上面的假设的环境）  \n所以满足我们实际生产环境（互联网或者企业内部的环境）的是 部分同步模型+ 崩溃恢复模型的组合。\n\n<p>我们目前的分布式的环境是 崩溃-恢复模型+ 部分同步的模型 </p>\n\n        <h3 id=\"分布式共识算法的正确性必须要有以下的性质\"   >\n          <a href=\"#分布式共识算法的正确性必须要有以下的性质\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识算法的正确性必须要有以下的性质</h3>\n      <ol>\n<li>唯一性<br>两个令牌不能获得相同的值  </li>\n<li>单调递增<br>如果请求x返回令牌tx， 请求y返回了令牌ty, 且x在y开始之前先完成，tx &lt; ty  </li>\n<li>可用性<br>请求令牌的节点如果不发生崩溃最终一定能收到响应（无论是对应用来说正确或者错误的回答）  </li>\n</ol>\n\n        <h4 id=\"分布式共识算法的安全性和活性\"   >\n          <a href=\"#分布式共识算法的安全性和活性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识算法的安全性和活性</h4>\n      <p>在正确性中其实可以再进行细分分为安全性和活性（理解上，并非准确的定义，准确的定义可以查看FLP的理论）：<br>安全性： 没有发生意外<br>活性： 预期的事情一定会发生（最终会发生）  </p>\n<p>如果违反了安全的属性，我们可以找到发生特定时间的时间点。但是违反安全属性的事件发生，必定不可逆，数据丢失。<br>活性的话无法明确具体发生的时间点，但是希望再未来某个时间点能够达到要求。  </p>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <p>PS: 文章中部分的图来源是来自于《数据密集型应用系统设计》，为PDF翻译的截图，截图的引用在<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/hyhlinux/DDIA/blob/master/ch8.md\" >此处</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>。如果涉及到版权的问题，请通知我，我会使用工具继续重画。</p>\n<ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.ibm.com/support/knowledgecenter/en/SSAL2T_8.2.0/com.ibm.cics.tx.doc/concepts/c_wht_is_distd_comptg.html\" >IBM Defination of Distributed System</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://book.douban.com/subject/30329536/\" >数据密集型应用系统设计</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/\" >FLP Impossibility</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://en.wikipedia.org/wiki/Byzantine_fault\" >拜占庭错误</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.usenix.org/legacy/events/osdi99/full_papers/castro/castro_html/castro.html\" >拜占庭容错</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/basho/riak_core\" >Riak</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n"}],"PostAsset":[{"_id":"source/_posts/intro-distributed-system/SchdulerTimeJump.png","post":"ckk6h2epk0004eci5cgca101l","slug":"SchdulerTimeJump.png","modified":1,"renderable":1},{"_id":"source/_posts/intro-distributed-system/Time&EventMissmatch.png","post":"ckk6h2epk0004eci5cgca101l","slug":"Time&EventMissmatch.png","modified":1,"renderable":1},{"_id":"source/_posts/intro-distributed-system/TimeJump.png","post":"ckk6h2epk0004eci5cgca101l","slug":"TimeJump.png","modified":1,"renderable":1},{"_id":"source/_posts/intro-distributed-system/lockingproblem.png","post":"ckk6h2epk0004eci5cgca101l","slug":"lockingproblem.png","modified":1,"renderable":1},{"_id":"source/_posts/intro-distributed-system/lockingproblem2.png","post":"ckk6h2epk0004eci5cgca101l","slug":"lockingproblem2.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"ckk6h2epb0000eci53tuy7iuk","tag_id":"ckk6h2epf0001eci515jx2v09","_id":"ckk6h2epg0002eci50sji7mbp"},{"post_id":"ckk6h2epk0003eci51vj6gdyl","tag_id":"ckk6h2epf0001eci515jx2v09","_id":"ckk6h2epl0005eci5av1qg3g3"},{"post_id":"ckk6h2epk0004eci5cgca101l","tag_id":"ckk6h2epf0001eci515jx2v09","_id":"ckk6h2epl0006eci5duzvch6d"}],"Tag":[{"name":"distributed-system","_id":"ckk6h2epf0001eci515jx2v09"}]}}