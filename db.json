{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/stun/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/stun/source/images/algolia.svg","path":"images/algolia.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/loading.svg","path":"images/loading.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/js/header.js","path":"js/header.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/scroll.js","path":"js/scroll.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/stun-boot.js","path":"js/stun-boot.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/stun/source/images/icons/favicon-16x16.png","path":"images/icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/stun/source/images/icons/favicon-32x32.png","path":"images/icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/stun/source/images/icons/stun-logo.svg","path":"images/icons/stun-logo.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":1},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":0},{"_id":"source/images/gdut.jpg","path":"images/gdut.jpg","modified":0,"renderable":0},{"_id":"source/images/profile.png","path":"images/profile.png","modified":0,"renderable":0},{"_id":"source/images/programmingebooks.png","path":"images/programmingebooks.png","modified":0,"renderable":0},{"_id":"source/images/sandstone.png","path":"images/sandstone.png","modified":0,"renderable":0},{"_id":"source/images/styleguide.png","path":"images/styleguide.png","modified":0,"renderable":0},{"_id":"source/images/zoom.jpg","path":"images/zoom.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/Prometheus.png","path":"images/posts/Prometheus.png","modified":0,"renderable":0},{"_id":"source/images/posts/deploy-using-github-pages-and-travis.png","path":"images/posts/deploy-using-github-pages-and-travis.png","modified":0,"renderable":0},{"_id":"source/images/posts/devlopr-starter.png","path":"images/posts/devlopr-starter.png","modified":0,"renderable":0},{"_id":"source/images/posts/devlopr.png","path":"images/posts/devlopr.png","modified":0,"renderable":0},{"_id":"source/images/posts/distributed-db.jpg","path":"images/posts/distributed-db.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/distributed-system.png","path":"images/posts/distributed-system.png","modified":0,"renderable":0},{"_id":"source/images/posts/docker.png","path":"images/posts/docker.png","modified":0,"renderable":0},{"_id":"source/images/posts/go.png","path":"images/posts/go.png","modified":0,"renderable":0},{"_id":"source/images/posts/hello.jpg","path":"images/posts/hello.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/siteleaf.jpg","path":"images/posts/siteleaf.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/sql.jfif","path":"images/posts/sql.jfif","modified":0,"renderable":0},{"_id":"source/images/posts/prometheus/DiscoverManager.png","path":"images/posts/prometheus/DiscoverManager.png","modified":0,"renderable":0},{"_id":"source/images/posts/siteleaf/1.png","path":"images/posts/siteleaf/1.png","modified":0,"renderable":0},{"_id":"source/images/posts/siteleaf/2.png","path":"images/posts/siteleaf/2.png","modified":0,"renderable":0},{"_id":"source/images/posts/siteleaf/3.png","path":"images/posts/siteleaf/3.png","modified":0,"renderable":0},{"_id":"source/images/posts/siteleaf/4.png","path":"images/posts/siteleaf/4.png","modified":0,"renderable":0},{"_id":"source/images/posts/siteleaf/5.png","path":"images/posts/siteleaf/5.png","modified":0,"renderable":0},{"_id":"source/images/posts/siteleaf/6.png","path":"images/posts/siteleaf/6.png","modified":0,"renderable":0},{"_id":"source/images/posts/siteleaf/8.png","path":"images/posts/siteleaf/8.png","modified":0,"renderable":0},{"_id":"source/images/posts/siteleaf/9.png","path":"images/posts/siteleaf/9.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1611195039720},{"_id":"themes/stun/.editorconfig","hash":"1ca001b8a7ed235eb9f5c21360b3a11eedb84ae7","modified":1611195879133},{"_id":"themes/stun/.commitlintrc.js","hash":"af8f006fbdfc6a1880605c7a35e63de300d6929b","modified":1611195879133},{"_id":"themes/stun/.cz-config.js","hash":"fbb89df58c60cf4f3827059d0574accc8407e1bb","modified":1611195879133},{"_id":"themes/stun/.eslintrc","hash":"1ba4f0ddd4bef04884c7fda6ef04f9d9697a62b4","modified":1611195879133},{"_id":"themes/stun/.gitignore","hash":"7745f04d70b1ea58b02d68dde999708836343c7a","modified":1611195879133},{"_id":"themes/stun/.prettierrc","hash":"4b6589404c509f4538daf6f3b8b3ee2ec37d2f4c","modified":1611195879133},{"_id":"themes/stun/CHANGELOG.md","hash":"28a248f28bbe27f6ca9234be2026d74dc7bf4387","modified":1611195879133},{"_id":"themes/stun/FAQ.md","hash":"df56d44b1297fe507d8b4edefb303629f4b23c67","modified":1611195879133},{"_id":"themes/stun/.stylintrc","hash":"3305c42a95c986341d7c7dd03ed9f37a42da343c","modified":1611195879133},{"_id":"themes/stun/LICENSE","hash":"c79ab3fe0ee8f2388376574dfe704b3df0c70a69","modified":1611195879133},{"_id":"themes/stun/README.md","hash":"b77f5b18bfe474178fee322ff6065f960f33c96d","modified":1611195879133},{"_id":"themes/stun/README_en-US.md","hash":"5e7bff4bcd02badcd3207379d353c5d1ea403a4f","modified":1611195879133},{"_id":"themes/stun/package.json","hash":"73b9d4773d487897e7c2bc28409771ff553044b6","modified":1611195879137},{"_id":"themes/stun/.github/FUNDING.yml","hash":"963cf7fb304865af888ad4bbb87a0f5991f3790f","modified":1611195879133},{"_id":"themes/stun/languages/en.yml","hash":"e1348852aa00d2d57f5215c83709f6428f8e8a71","modified":1611195879133},{"_id":"themes/stun/_config.yml","hash":"9862b4d55700dd208dd89f2a064ffbb8a4979a97","modified":1611201629087},{"_id":"themes/stun/languages/es.yml","hash":"e150c8a1f56ae9ed065611951aa124fb548577fc","modified":1611195879133},{"_id":"themes/stun/languages/zh-CN.yml","hash":"ef231652f77466527465788089ff91228d6eff54","modified":1611201565966},{"_id":"themes/stun/languages/zh-HK.yml","hash":"aef25f329cc05dbe8e38753fccd98d63c9fcd174","modified":1611195879133},{"_id":"themes/stun/layout/archive.pug","hash":"d45d078ae4196add83e21fcaed3ef168b237af90","modified":1611195879137},{"_id":"themes/stun/layout/_layout.pug","hash":"5052ee5040ae736d78ad208df7352be69b61b0d1","modified":1611195879133},{"_id":"themes/stun/layout/category.pug","hash":"24153408b2971542d177227f09e93da7754bf75e","modified":1611195879137},{"_id":"themes/stun/layout/index.pug","hash":"df40cf1f051fd29f0f51ace74e9f7394f6ea2ab7","modified":1611195879137},{"_id":"themes/stun/layout/page.pug","hash":"22ba5928bd9ae8c56b3242b7caa5fc3ec471b082","modified":1611195879137},{"_id":"themes/stun/layout/post.pug","hash":"a4d16dbb919df5d4ffdb5a1d0114a4e1c8c21197","modified":1611195879137},{"_id":"themes/stun/layout/tag.pug","hash":"46f956ad7e2aed879999ddf5e768d80c4bbe5b5f","modified":1611195879137},{"_id":"themes/stun/scripts/engine.js","hash":"a63a57c9206a77a79f93dbd86e86204447d7d904","modified":1611195879137},{"_id":"themes/stun/scripts/merge-config.js","hash":"bb914100129c5ca2d1a9e087fffd7bedcb6ae6a6","modified":1611195879137},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/feature-request_en.md","hash":"af7175a0d0f7edfbfbeef3eeb949e20d1e41bf38","modified":1611195879133},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/feature-request_zh.md","hash":"1ecd119a1f4c6fbe3886c885b7d13f1fcc048a5b","modified":1611195879133},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/other_en.md","hash":"6b6afbfc66ee51624f7eeaeb5a1fc959e290e06d","modified":1611195879133},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/other_zh.md","hash":"a9f7abd311731c21082fa5e553251f4704e555c5","modified":1611195879133},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/bug-report_zh.md","hash":"0b42693e9577d3203473caa11ceaa9f64096a67c","modified":1611195879133},{"_id":"themes/stun/.github/workflows/files-shaking.yml","hash":"3593429efe2f5b196a44d185e810b226cef26714","modified":1611195879133},{"_id":"themes/stun/layout/_mixins/gallery.pug","hash":"3054e2c09bc205173c517fb1c36321f7c4c0db63","modified":1611195879133},{"_id":"themes/stun/.github/ISSUE_TEMPLATE/bug-report_en.md","hash":"70022617d944b410a21c28d2abafcfe0b2928f01","modified":1611195879133},{"_id":"themes/stun/layout/_mixins/menu-item.pug","hash":"93c4454e48a6f1456c29aeb9d1332be186b49d4f","modified":1611195879133},{"_id":"themes/stun/layout/_mixins/meta-item.pug","hash":"3d74dc8ba8651efd4a605e56a21e314678d04057","modified":1611195879133},{"_id":"themes/stun/layout/_partials/config.pug","hash":"4fb832652485161148ea957067c06d50ed11578b","modified":1611195879133},{"_id":"themes/stun/layout/_scripts/stun.pug","hash":"961554914427578b57ea3912d751d398f4eb381d","modified":1611195879137},{"_id":"themes/stun/layout/_mixins/timeline.pug","hash":"4e19a670f002d3c6bc740a2d6ef03964e6b59c09","modified":1611195879133},{"_id":"themes/stun/layout/_scripts/vendors.pug","hash":"62a6831d3b1d90d6c8335ce3402efc50e141eafb","modified":1611195879137},{"_id":"themes/stun/.github/workflows/codeql-analysis.yml","hash":"7a9d289addb10720f6b666157efe170d47774906","modified":1611195879133},{"_id":"themes/stun/scripts/filters/external-link.js","hash":"f5369becfd8cc6e43d6dc3595b1edbe014d9aa7c","modified":1611195879137},{"_id":"themes/stun/layout/_mixins/post-header.pug","hash":"9486d07e56acf7bcc5d691bef93c19e2e5c98022","modified":1611195879133},{"_id":"themes/stun/scripts/filters/lazyload.js","hash":"d5baf39faeff5368182be1f59fb598d023985cde","modified":1611195879137},{"_id":"themes/stun/scripts/filters/post-heading.js","hash":"6785e981bfcf87ca587bef36231be430bba2254d","modified":1611195879137},{"_id":"themes/stun/scripts/filters/image-setting.js","hash":"412318b6d189d5355dbcc52c9762072f7ecdaad4","modified":1611195879137},{"_id":"themes/stun/scripts/filters/wrap-table.js","hash":"888c9eaaddcdb9b88d07837a9091aa39ed3fe677","modified":1611195879137},{"_id":"themes/stun/scripts/filters/shake-file.js","hash":"159dff6e4f7020545c9b151108398cd383d613e2","modified":1611195879137},{"_id":"themes/stun/scripts/tags/note.js","hash":"b436593a56e3bab8dd59c71e73ac9efbc8fa29d4","modified":1611195879137},{"_id":"themes/stun/scripts/tags/table.js","hash":"177061e1bfb296981a101643f51a27ccc1469307","modified":1611195879137},{"_id":"themes/stun/source/css/index.styl","hash":"8a75ec81fb064b0da2f978a064cc5bec2395f27d","modified":1611195879141},{"_id":"themes/stun/scripts/tags/friends.js","hash":"c2fe1e8e128f464d772bcb7534efef54ad224310","modified":1611195879137},{"_id":"themes/stun/source/images/algolia.svg","hash":"90322f80db6ad0daf26ea3ec71dea6f691a8b2f1","modified":1611195879141},{"_id":"themes/stun/source/images/cc-by-nc-nd.svg","hash":"017ad912874686a982ebceae359299b8f2a492e2","modified":1611195879141},{"_id":"themes/stun/source/images/cc-by-nc.svg","hash":"4608189edbe7636dd651df65473298a3c5afb20d","modified":1611195879141},{"_id":"themes/stun/source/images/cc-by-nc-sa.svg","hash":"71d035c34219f924dbf1bf852166ee8fb58d2f24","modified":1611195879141},{"_id":"themes/stun/layout/_third-party/quicklink.pug","hash":"2bed65ed4d314dc587e2359e20ae099b46181ed5","modified":1611195879137},{"_id":"themes/stun/source/images/cc-by-nd.svg","hash":"20c66ae3c393903e6eab3bc8cf7c3be6d753f9f8","modified":1611195879141},{"_id":"themes/stun/source/images/cc-by.svg","hash":"77f74c241902447424207869c74cb9d9264bdced","modified":1611195879141},{"_id":"themes/stun/source/images/cc-by-sa.svg","hash":"0455a8857ba096925d4145a56e8d10537fccb378","modified":1611195879141},{"_id":"themes/stun/source/images/loading.svg","hash":"32a6e770d217ae6c0cf0f6beef3172f1b5b9a0a2","modified":1611195879141},{"_id":"themes/stun/source/js/scroll.js","hash":"8926ab87181a49c730ce5132518b608c54b8cdb1","modified":1611195879141},{"_id":"themes/stun/source/js/stun-boot.js","hash":"8358ac0d879c0ca340c52e4de606523c2a91e156","modified":1611195879141},{"_id":"themes/stun/source/js/sidebar.js","hash":"20adff7f54bcd8299d32690d41ebc7a4eb7a8728","modified":1611195879141},{"_id":"themes/stun/layout/_partials/analytics/busuanzi.pug","hash":"80d2f4f8706a96b367ac1e89f5b56ada4684d571","modified":1611195879133},{"_id":"themes/stun/source/js/header.js","hash":"63d407ee6f80114e220171ba829b79b28d420fe0","modified":1611195879141},{"_id":"themes/stun/layout/_partials/head/kill-old-ie.pug","hash":"427a95d02844f29e63c5e9f014ede3609aec1a5b","modified":1611195879133},{"_id":"themes/stun/layout/_partials/footer/footer.pug","hash":"9a8e56bcc504f251c13ee3d0d18a08142fb7ee43","modified":1611195879133},{"_id":"themes/stun/layout/_partials/post/post-list.pug","hash":"c049078009aa251fc76cd948837c7a5efdd39cb2","modified":1611195879133},{"_id":"themes/stun/layout/_partials/search/algolia.pug","hash":"61181bece0e27929fe00df5204fefd8dee31a354","modified":1611195879133},{"_id":"themes/stun/layout/_partials/search/assist-btns.pug","hash":"7e6dc0d975ccbe291116487b15277d27a391fb9a","modified":1611195879133},{"_id":"themes/stun/layout/_partials/header/header.pug","hash":"7ecbe18da15d3a52c56f69c542540291b6178763","modified":1611195879133},{"_id":"themes/stun/layout/_partials/search/index.pug","hash":"0f84aa013a96e7eb3bb25b87f20bab9b7ac55538","modified":1611195879133},{"_id":"themes/stun/layout/_partials/head/head.pug","hash":"c7909a6a50c7a76a6c1810b700a5d72bcb1e20c9","modified":1611195879133},{"_id":"themes/stun/layout/_partials/search/localsearch.pug","hash":"4d8e0bc33f92a603e0b2a5f4296af6bcc7cc31b8","modified":1611195879133},{"_id":"themes/stun/layout/_partials/sidebar/sidebar.pug","hash":"18173a2acf99db39748c392f2e669acd805b4090","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/back2top.pug","hash":"48b7fedeb472bd01fd1f3317359a10e83ca919e1","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/loading-bar.pug","hash":"6cda7866f9589c9ffc05ce4a3d7c33b706e70324","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/copyright.pug","hash":"0938c885697f6eb388b28ddbf88f5631d024fe73","modified":1611195879133},{"_id":"themes/stun/source/js/utils.js","hash":"b570eafe77e47d7701348f172a4dbaaba6fa8123","modified":1611195879141},{"_id":"themes/stun/layout/_partials/widgets/comments.pug","hash":"af1b16be74c7e1242e0f57986672dc73e93546e2","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/night-mode.pug","hash":"c7f9bd67cd231b9bd40a84123644e009ac8d8ef3","modified":1611195879133},{"_id":"themes/stun/layout/_third-party/pjax.pug","hash":"4a786459a8e6a4f378a9d834502f8b11aa66f185","modified":1611195879137},{"_id":"themes/stun/layout/_partials/widgets/share.pug","hash":"1bb3d25298b7ee6a28150aa286ed6b0ae42ead4f","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/reward.pug","hash":"c9081c1dcf0ca18df06d23638654d8f43b28d55c","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/sticky-top.pug","hash":"bf86b2f9f4b1471afb8b31965d3230f6088682ae","modified":1611195879133},{"_id":"themes/stun/layout/_partials/widgets/paginator.pug","hash":"b0045dcb9b151ee31f1db5b7d741f10ef3b74be0","modified":1611195879133},{"_id":"themes/stun/layout/_third-party/advertising/google-adsense.pug","hash":"e489020f1130976d3ec2245915ede6319d89b89c","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/advertising/index.pug","hash":"1285cd65a873f688ae3c51846c1284447f502adc","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/analytics/baidu-analytics.pug","hash":"f7300991a29dbe2e8091a588dfa8c65c3dee6302","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/analytics/busuanzi.pug","hash":"78a4fc9c9380e31536f5b500638f2d005accd361","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/analytics/index.pug","hash":"0d72f844bf9532b3be644c27b0af7cb4331fc46c","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/analytics/google-analytics.pug","hash":"4eef66fbb8a8ad55e0868cf4b77a6b7bca0e7f35","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/analytics/tencent-analytics.pug","hash":"f88fb0f085812db6023c30308ba3458da7742993","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/disqus.pug","hash":"57bcbaac3d237d9168dd8f4b682f34351f11d250","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/fbcomments.pug","hash":"fb651812c87dc5e2134d7fb7d8f98d4d4227f1f6","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/gitalk.pug","hash":"c2a90e80c51b5b99e6804dbed5457a071b980bbd","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/index.pug","hash":"bec4d9c8ea360637e7da3314fa987e33facd8071","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/livere.pug","hash":"687f74a998519608944b40a41f3a98ccf4535139","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/minivaline.pug","hash":"5584ade7dd19deca418373115bde9d563d37d826","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/utterances.pug","hash":"6418baeb3aedcddb02a64bd89b26ac12e18551c8","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/math/katex.pug","hash":"345c59fe76a7c83b529328e5144d1036cb14f533","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/valine.pug","hash":"b519a6948d6ef37c037385e3e3f9590c17f7ad62","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/comments/waline.pug","hash":"fd4c958b13777752f176556c7b109b7dede7cc68","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/math/index.pug","hash":"e952be6c736545e73c0e02f833f87a4f8c5a2582","modified":1611195879137},{"_id":"themes/stun/source/css/_common/index.styl","hash":"86057db6cb18263866d62a6669feee8752882398","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/math/mathjax.pug","hash":"72d51538cc85f01c8c64db74b9219ccaf334c9e9","modified":1611195879137},{"_id":"themes/stun/source/css/_common/responsive.styl","hash":"618c6005f1bc7c482fa37ae3ce15729a64044d9d","modified":1611195879137},{"_id":"themes/stun/source/css/_custom/index.styl","hash":"0d1adc70250941074c742f94f7801b3b43a7f1db","modified":1611195879137},{"_id":"themes/stun/source/css/_mixins/index.styl","hash":"f3060519f3acd05cb4b26bb5f6a5c6b857cb0d68","modified":1611195879137},{"_id":"themes/stun/source/css/_variables/index.styl","hash":"c81aac4285eb058026b255e31282d35f55a820ab","modified":1611195879141},{"_id":"themes/stun/source/images/icons/favicon-16x16.png","hash":"7bfd64eac26e17ea162f0c399a4a40164c26b412","modified":1611195879141},{"_id":"themes/stun/source/images/icons/favicon-32x32.png","hash":"02fead07726920400ede57ddfdbf071dd7203fd5","modified":1611195879141},{"_id":"themes/stun/source/images/icons/stun-logo.svg","hash":"069dc7590ad152373f1c346d892e32faa2bbdd87","modified":1611195879141},{"_id":"themes/stun/source/css/_common/components/index.styl","hash":"a54720db94121efd1a34ac88d344197c8206837e","modified":1611195879137},{"_id":"themes/stun/source/css/_common/outline/index.styl","hash":"467d4171c0690a95d40fbecea02e6b212b7c74f1","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/search/localsearch.pug","hash":"d98db7ed7e3e4c574212fa9d75adba681f3d0687","modified":1611195879137},{"_id":"themes/stun/source/css/_common/outline/macro.styl","hash":"13b96f239de15e1cfdc14d9c80e6959506556dd2","modified":1611195879137},{"_id":"themes/stun/source/css/_common/scaffolding/base.styl","hash":"4064a7e2c3f71d2ed72a47edd60e9be01af6c354","modified":1611195879137},{"_id":"themes/stun/source/css/_common/scaffolding/index.styl","hash":"e750f2dae9eb3385039ee018ff8001b0e6ec3b64","modified":1611195879137},{"_id":"themes/stun/source/css/_common/scaffolding/normalize.styl","hash":"c15a9616fddb267431416304d709185aeb3d45f5","modified":1611195879137},{"_id":"themes/stun/source/css/_common/scaffolding/utils.styl","hash":"7e62f34521ea539a25a101f25e1684e3a3ac4be8","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/analytics/busuanzi.styl","hash":"d196c88ea2e9b851e8d8f9c5a315dfc2929eb897","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/analytics/index.styl","hash":"339a43fd5ee97a77775b723118f6ab1af754fed4","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/footer/index.styl","hash":"14464841145cf3ecab66f1094653daa033c261eb","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/header/index.styl","hash":"904af0e73cdf0767ec781271856d7b5b63e043ef","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/highlight/diff.styl","hash":"056e70f6dfe45ec50427d7ab293d33361c9b956f","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/highlight/highlight.styl","hash":"bc0b01021a0d19b2c98f0c5c9fa1af96d67c1099","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/highlight/index.styl","hash":"85848179cbc78152d2521b601ac9f888dea4e255","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/highlight/theme.styl","hash":"dfc99b05302f8203040431e563c9f63d63da46de","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/pages/index.styl","hash":"463a4e6a92ec5f757e167fbeb171e4e92e83a822","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/search/algolia.pug","hash":"54233748e22ceae063f70ee49b44c4bd0a78f391","modified":1611195879137},{"_id":"themes/stun/layout/_third-party/search/index.pug","hash":"0f84aa013a96e7eb3bb25b87f20bab9b7ac55538","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/pages/timeline.styl","hash":"21e9c8def1613030f0927e2ce80f4ecc721f078e","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/pages/page.styl","hash":"df732e267dfd9f1bda6a8cf1ede3198a205925f9","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/plugins/friends.styl","hash":"bdb015173f8e5fa391fc4fb2b2a8d42787022c4b","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/plugins/index.styl","hash":"c35d0cf421c6669ee0458c2f0264dca05769c01d","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/plugins/note.styl","hash":"ae0ad9b44a87839d220792336478a9ae6db11c47","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/plugins/table.styl","hash":"98cacc91e42f5e45279e2174a90ab26171085e2f","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/post/index.styl","hash":"08aad11e329cda0550efef226e0c4d0bb4540454","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/post/post-list.styl","hash":"d0ed844e28533f832cbd9b3f09203d16936628f7","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/post/post.styl","hash":"8b7b22225b40d028efee689d3700a9796291cb8d","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/search/algolia.styl","hash":"fb62e4baf25a66e46c27783be5d79353ec394b44","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/search/common.styl","hash":"1939b7dfbcf557794a188fbf8fec4ef2b5afa437","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/search/index.styl","hash":"1990d2c2a9bfe8e09d656f0c2ae6cf0c9f7f5542","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/search/localsearch.styl","hash":"bf1ac1b8ee8c4daaa7e6b47eec097a176624e6d0","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/copy-button.styl","hash":"378961fa7c986e3313053814806902bf76204a93","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/back2top.styl","hash":"b3da5ea71a9947e781056d1bd7d42e4045fa2aca","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/sidebar/index.styl","hash":"02138647437f7e8ee8927cae225d41072d936bdc","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/comments.styl","hash":"41d229ac4fa02a3a8b46687ccbafa7a608008e2f","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/copyright.styl","hash":"1d28fc8f76f7164a306ed81a9ede21c0a2b0f7cd","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/ending.styl","hash":"63985ca9a3f6c481cc60207966fa1267de14d945","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/fancybox.styl","hash":"3d677c0323d77199bb9fbfefd65e97d8b882d7b3","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/font-icon.styl","hash":"bdda0953611378e93a8d6387cbdc93e1de4f7f0a","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/gallery-image.styl","hash":"99b1cc42f38816083f93233778b299422b6d8f32","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/index.styl","hash":"03ffdc55fd5fb64c3158bc222d0e8e9d7844686b","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/lazyload.styl","hash":"eced96235f0ff5dc6a8fd068d4ed05934a29b430","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/loading-bar.styl","hash":"9f23e8762d01fb4a3cbf5e786fdead2926849e8a","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/night-mode.styl","hash":"9caeef13a913aba38976f082e1f0ca191bffc64e","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/paginator.styl","hash":"71ddb6a1e9664a4fde04a0ce143b8786ba6e0089","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/reward.styl","hash":"de1130ec3765879884cbdc77a15b458da6e37bcc","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/share.styl","hash":"fe32e3434107d92cefd7aacfdcef526a93c4b865","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/sticky-top.styl","hash":"f0e37944168a74a64b18dc54c6fde2308e4bf023","modified":1611195879137},{"_id":"themes/stun/source/css/_common/components/widgets/zoom-image.styl","hash":"40f832a199320642debabe32910c1168e3c6e40c","modified":1611195879137},{"_id":"themes/stun/package-lock.json","hash":"1da56d61e769a1f6d47444631d3ff29aecbf569b","modified":1611195879137},{"_id":"source/categories/index.md","hash":"ccd50c0021343ed02de529105275dad022f9f8d0","modified":1611200958283},{"_id":"source/tags/index.md","hash":"d7b0d8c4c7bb7ce8c8298fcba3cf2ae22f168066","modified":1611197601625},{"_id":"source/pics/background.jpg","hash":"d6e5f05e371fbd474d6d2183485c556c2aa52842","modified":1611197848489},{"_id":"themes/stun/source/images/background.jpg","hash":"d6e5f05e371fbd474d6d2183485c556c2aa52842","modified":1611197848489},{"_id":"public/categories/index.html","hash":"a1c7bc94e425f41d136ba9bcbf1ab1e858c6baa2","modified":1611200509055},{"_id":"public/tags/index.html","hash":"c4f9071dba02fee1923dbd9b4ea758377a7f1475","modified":1611200509055},{"_id":"public/2021/01/21/hello-world/index.html","hash":"8c74a26033fefb9797f280527f9fee6eed70478e","modified":1611200509055},{"_id":"public/archives/index.html","hash":"07fad6332542789a48d4e9b0051a1f4f61e91349","modified":1611200509055},{"_id":"public/archives/2021/index.html","hash":"464b3d51a5aec9707ca583932466345897ed7e25","modified":1611200509055},{"_id":"public/archives/2021/01/index.html","hash":"838f417e0de41d07e1df50c51ed1d338306f762c","modified":1611200509055},{"_id":"public/index.html","hash":"f057d1d93906f928792344d07554bc167fca6f16","modified":1611200509055},{"_id":"public/images/algolia.svg","hash":"90322f80db6ad0daf26ea3ec71dea6f691a8b2f1","modified":1611200509055},{"_id":"public/images/cc-by-nc-nd.svg","hash":"017ad912874686a982ebceae359299b8f2a492e2","modified":1611200509055},{"_id":"public/images/cc-by-nc-sa.svg","hash":"71d035c34219f924dbf1bf852166ee8fb58d2f24","modified":1611200509055},{"_id":"public/images/cc-by-nc.svg","hash":"4608189edbe7636dd651df65473298a3c5afb20d","modified":1611200509055},{"_id":"public/images/cc-by-nd.svg","hash":"20c66ae3c393903e6eab3bc8cf7c3be6d753f9f8","modified":1611200509055},{"_id":"public/images/cc-by-sa.svg","hash":"0455a8857ba096925d4145a56e8d10537fccb378","modified":1611200509055},{"_id":"public/images/cc-by.svg","hash":"77f74c241902447424207869c74cb9d9264bdced","modified":1611200509055},{"_id":"public/images/loading.svg","hash":"32a6e770d217ae6c0cf0f6beef3172f1b5b9a0a2","modified":1611200509055},{"_id":"public/images/icons/favicon-16x16.png","hash":"7bfd64eac26e17ea162f0c399a4a40164c26b412","modified":1611200509055},{"_id":"public/images/icons/favicon-32x32.png","hash":"02fead07726920400ede57ddfdbf071dd7203fd5","modified":1611200509055},{"_id":"public/images/icons/stun-logo.svg","hash":"069dc7590ad152373f1c346d892e32faa2bbdd87","modified":1611200509055},{"_id":"public/js/header.js","hash":"63d407ee6f80114e220171ba829b79b28d420fe0","modified":1611200509055},{"_id":"public/js/scroll.js","hash":"8926ab87181a49c730ce5132518b608c54b8cdb1","modified":1611200509055},{"_id":"public/js/sidebar.js","hash":"20adff7f54bcd8299d32690d41ebc7a4eb7a8728","modified":1611200509055},{"_id":"public/js/stun-boot.js","hash":"8358ac0d879c0ca340c52e4de606523c2a91e156","modified":1611200509055},{"_id":"public/css/index.css","hash":"4e00e962943eb85f788cd779eb26ea96813132fb","modified":1611200509055},{"_id":"public/js/utils.js","hash":"b570eafe77e47d7701348f172a4dbaaba6fa8123","modified":1611200509055},{"_id":"public/images/background.jpg","hash":"d6e5f05e371fbd474d6d2183485c556c2aa52842","modified":1611200509055},{"_id":"source/images/favicon.ico","hash":"bc2865e9aa14213954a065a601068fca82e30e48","modified":1611209774298},{"_id":"source/_posts/raft-lab-2.md","hash":"dcb48d1ca95ead3354b92aae1bd81a7a920885bd","modified":1611214096144},{"_id":"source/images/gdut.jpg","hash":"2a1b444969cd4ea3542c7765667691ede8cb89d4","modified":1611209774446},{"_id":"source/_posts/intro-distributed-system.md","hash":"c61f2a1a5aec392a6826648b8493592bee654147","modified":1611214054188},{"_id":"source/images/profile.png","hash":"24ca9409baced46858ea8a6ace5e4df1e56fab50","modified":1611209774562},{"_id":"source/images/sandstone.png","hash":"d9376295a520b26f3fffcad510d712fb55b4c0aa","modified":1611209774849},{"_id":"source/_posts/intro-distributed-system/SchdulerTimeJump.png","hash":"96bf07ff85553f0488994840d42abeee01b60ff7","modified":1611210290568},{"_id":"source/_posts/intro-distributed-system/TimeJump.png","hash":"06b9f53d7f1de9513ebc82f966da61f8c3245945","modified":1611210159454},{"_id":"source/images/posts/GoSlice.png","hash":"4479fa57bd48c6b5416534c3fd47c70ab1f5cdf0","modified":1611209764955},{"_id":"source/images/posts/Lab3-Process.png","hash":"ae7f4c8dfb423391ad0a308c67f7c53200cc55b1","modified":1611209764955},{"_id":"source/images/posts/GoSliceExtend.png","hash":"775b4081f260a70834ec1a3dfe95df1b3836c8ee","modified":1611209764955},{"_id":"source/images/posts/Prometheus.png","hash":"0506d03706999d9ef6aa1eac1cd6aa38e64481d2","modified":1611209764955},{"_id":"source/images/posts/RaftStateMachine.png","hash":"70b9c110053df72419c3b49b9af9dd0756a6746e","modified":1611209764959},{"_id":"source/images/posts/distributed-system.png","hash":"a8d43e346d395b6b3c821397b243b02269b5465b","modified":1611209764959},{"_id":"source/images/posts/docker.png","hash":"fa387d66e00872926990aeee452d8f4ed27dabf1","modified":1611209764959},{"_id":"source/images/posts/distributed-db.jpg","hash":"d12869dd81ffa87b28edf9ea658adda8c683925a","modified":1611209764959},{"_id":"source/images/posts/lab4.png","hash":"cd009a7990265f919125c0215a60c2c15da1ec88","modified":1611209764959},{"_id":"source/images/posts/go.png","hash":"700cd88adaaa4c83be5580dad2edea8a64779551","modified":1611209764959},{"_id":"source/images/posts/more-detail-line.png","hash":"72f5da21dcf6e130fcf2244d3e19a756f82accb7","modified":1611209764963},{"_id":"source/images/posts/sql.jfif","hash":"2af4d52a366d09c72de7edd73bb0943d26697bde","modified":1611209764963},{"_id":"source/images/posts/prometheus/ScrapeModule.png","hash":"2f5e7b38d366dd450f7c722887f3d7ed2d592bc3","modified":1611209764963},{"_id":"source/images/posts/prometheus/DiscoverManager.png","hash":"a373230ea1eff40b760eefd994f389ed079f5924","modified":1611209764963},{"_id":"source/images/posts/siteleaf/4.png","hash":"aee718d91c1957564223454555708230e193dfd8","modified":1611209764963},{"_id":"source/images/posts/siteleaf/1.png","hash":"2914adca89d0679239e50045f69176b4ed71d75a","modified":1611209764963},{"_id":"source/images/posts/siteleaf/2.png","hash":"705e3e4bfc44a38fcc1e86e3ae02e59d73855c84","modified":1611209764963},{"_id":"source/images/posts/siteleaf/3.png","hash":"ba54eaeab0f941bde9017e742fc434469aa0d22a","modified":1611209764963},{"_id":"source/images/posts/sqlJoin/FULL_OUTER_JOIN.png","hash":"328ffe185f047de564ee058df5782e0ac4d7e288","modified":1611209764963},{"_id":"source/images/posts/sqlJoin/INNER_JOIN.png","hash":"4855ad7e617ff7bd5d50661933f11397e98ead33","modified":1611209764963},{"_id":"source/images/posts/sqlJoin/LEFT_EXCLUDING_JOIN.png","hash":"d8fbfb2ff1f3f7edcf7eb151d004063b64672593","modified":1611209764967},{"_id":"source/images/posts/siteleaf/5.png","hash":"cce46cc1dc0036a3b8b676c690a9a47d1482f5c1","modified":1611209764963},{"_id":"source/images/posts/sqlJoin/LEFT_JOIN.png","hash":"6bebcdbb03998cee42b0eb8796366324937899c1","modified":1611209764967},{"_id":"source/images/posts/sqlJoin/OUTER_EXCLUDING_JOIN.png","hash":"80bfd5ad46985693297d43a9c199a8fa7149caa9","modified":1611209764967},{"_id":"source/images/posts/sqlJoin/RIGHT_EXCLUDING_JOIN.png","hash":"d25f73221c620d82f62519dacd7b826d7fa6ec7b","modified":1611209764967},{"_id":"source/images/posts/siteleaf/8.png","hash":"82ec6fb7698807e6a156c6c9b64c391bc7dbecc4","modified":1611209764963},{"_id":"source/images/posts/sqlJoin/RIGHT_JOIN.png","hash":"9508b89fabef50db34cd895df23e8dfca1f32e55","modified":1611209764967},{"_id":"source/images/posts/sqlPost/Union-1.png","hash":"a0b8d009947052d2860a5bfe38bea6ce2ddd319b","modified":1611209764967},{"_id":"source/images/posts/sqlPost/Union-2.png","hash":"f789f29d1f6499fdab82e0337f5c65827353d781","modified":1611209764967},{"_id":"source/images/posts/sqlPost/Union-3.png","hash":"b92a5c84b769dca861306b8533b90a220e3fec3e","modified":1611209764967},{"_id":"source/_posts/distribute-system-consensus.md","hash":"ba90ffad2d8bf94c4b80bccfd38768b633207602","modified":1611214055444},{"_id":"source/_posts/intro-distributed-system/lockingproblem.png","hash":"fbb0f4ff829fbf4e7efd142690838d7c0ebeea5b","modified":1611210326067},{"_id":"source/images/posts/RaftProcess.png","hash":"e0ba0d2b3bb78cb49e1a925c6f6d39810c6919a4","modified":1611209764955},{"_id":"source/images/posts/deploy-using-github-pages-and-travis.png","hash":"55cb8ef319aa7efa31bf54faab1f7018099fe8be","modified":1611209764959},{"_id":"source/images/posts/devlopr-starter.png","hash":"a111df6ea8403c12b4855d0f105d93b43897084f","modified":1611209764959},{"_id":"source/images/posts/generate-line.png","hash":"af91ca7e6f039d4f2275074b90b2a03a75ff8de3","modified":1611209764959},{"_id":"source/images/posts/hello.jpg","hash":"a704aa62155f81ea564f25b7c936bab812a96bdf","modified":1611209764959},{"_id":"source/images/posts/siteleaf.jpg","hash":"03af20db7719e4f3349754a87ae14e65bcfdb61b","modified":1611209764963},{"_id":"source/images/posts/siteleaf/9.png","hash":"75846cd0289eb17778e9abea0b2a9cd580296738","modified":1611209764963},{"_id":"source/images/posts/siteleaf/6.png","hash":"fa55614cca7f2977f82a90b069afa4e17b4ede5d","modified":1611209764963},{"_id":"source/_posts/intro-distributed-system/Time&EventMissmatch.png","hash":"3c475b8773138ddc1860c09f4dab36da63a600a9","modified":1611210249156},{"_id":"source/_posts/intro-distributed-system/lockingproblem2.png","hash":"1e26a196fc0d38387a04bfca2f72e232494ba5df","modified":1611210326270},{"_id":"source/images/posts/LamportTimestamp.png","hash":"cd9167f36d443923340bc6696f2b2e9451845f54","modified":1611209764955},{"_id":"source/images/posts/sqlJoin/Visual_SQL_JOINS_orig.jpg","hash":"680a869474697bae045105b4ea3fb7db14cbdce9","modified":1611209764967},{"_id":"source/images/zoom.jpg","hash":"9990a9c0a92cc394e8ca19b12f57bfbaf3be875b","modified":1611209775084},{"_id":"source/images/posts/devlopr.png","hash":"a97e9f2070caed1fde9c0f3918f6e475bfa75252","modified":1611209764959},{"_id":"source/images/posts/line-final.png","hash":"b9d5a320acd4afd4bde5ff371d39083ec1d42e27","modified":1611209764959},{"_id":"source/images/posts/quroum-fail.png","hash":"a232d6ebba1f33265a1032cb348637d664f34e2f","modified":1611209764963},{"_id":"source/images/styleguide.png","hash":"c1a26070904f41146df18ce223ecc3f3df4a12d6","modified":1611209774970},{"_id":"source/images/posts/non-linearized-example.png","hash":"aa4ad4b7808ba88b228868f8c193cad6c965048d","modified":1611209764963},{"_id":"source/images/programmingebooks.png","hash":"7037191f871a1b8660268927c5beb259274e57ce","modified":1611209774727},{"_id":"source/_posts/effective-go.md","hash":"716d8adb324d5e00e9ebdc76c253dc34968cb1ee","modified":1611213125053},{"_id":"source/_posts/go-slice.md","hash":"9b1c481ead84a9f2722ee23020cd4bc97a579e6a","modified":1611213135553},{"_id":"source/_posts/golang-sync-map.md","hash":"20988a5e14c5170f555391ad14706763dcc1e03e","modified":1611213119301},{"_id":"source/_posts/mit-6824.md","hash":"f71721aa48210cb44175e141d5960e26b2ca35b0","modified":1611210733007},{"_id":"source/_posts/prometheus-scrape.md","hash":"65481b647c9b4aa790e9471bcb9590bbe1619735","modified":1611212918213},{"_id":"source/_posts/prometheus-service-discovery.md","hash":"e5ffc35bc404edcae5aebf5a492dd10a641fc4d1","modified":1611213015109},{"_id":"source/_posts/raft-lab-3.md","hash":"0612c0d26f0ba261ef27c0100f5360fa4571cdea","modified":1611214052636},{"_id":"source/_posts/raft-lab-4.md","hash":"8a4cb3ce69d04296302a8dc1fe27f7f701e40130","modified":1611214108088},{"_id":"source/_posts/sql-revise.md","hash":"f8d9b9ab0ab61c13616dc9caaae26f1138a59330","modified":1611212506844},{"_id":"source/draft/docker.md","hash":"f8197dccf3a24f24087cfb426a5685575166ce91","modified":1611213188981},{"_id":"source/draft/dp.md","hash":"1bf9b724052baa79ccc10780c335bc332eb3b280","modified":1611213169145},{"_id":"source/draft/mst.md","hash":"0a48be713fe8780386a9fac5239505686d7cf86e","modified":1611213177413},{"_id":"source/_posts/distribute-system-consensus/more-detail-line.png","hash":"72f5da21dcf6e130fcf2244d3e19a756f82accb7","modified":1611211012089},{"_id":"source/_posts/go-slice/GoSlice.png","hash":"4479fa57bd48c6b5416534c3fd47c70ab1f5cdf0","modified":1611212029689},{"_id":"source/_posts/go-slice/GoSliceExtend.png","hash":"775b4081f260a70834ec1a3dfe95df1b3836c8ee","modified":1611212029848},{"_id":"source/_posts/prometheus-scrape/ScrapeModule.png","hash":"2f5e7b38d366dd450f7c722887f3d7ed2d592bc3","modified":1611212884698},{"_id":"source/_posts/raft-lab-2/RaftStateMachine.png","hash":"70b9c110053df72419c3b49b9af9dd0756a6746e","modified":1611211201891},{"_id":"source/_posts/raft-lab-3/Lab3-Process.png","hash":"ae7f4c8dfb423391ad0a308c67f7c53200cc55b1","modified":1611211724159},{"_id":"source/_posts/raft-lab-4/lab4.png","hash":"cd009a7990265f919125c0215a60c2c15da1ec88","modified":1611211792204},{"_id":"source/_posts/sql-revise/FULL_OUTER_JOIN.png","hash":"328ffe185f047de564ee058df5782e0ac4d7e288","modified":1611212186805},{"_id":"source/_posts/sql-revise/INNER_JOIN.png","hash":"4855ad7e617ff7bd5d50661933f11397e98ead33","modified":1611212186616},{"_id":"source/_posts/sql-revise/LEFT_EXCLUDING_JOIN.png","hash":"d8fbfb2ff1f3f7edcf7eb151d004063b64672593","modified":1611212186419},{"_id":"source/_posts/sql-revise/LEFT_JOIN.png","hash":"6bebcdbb03998cee42b0eb8796366324937899c1","modified":1611212186286},{"_id":"source/_posts/sql-revise/OUTER_EXCLUDING_JOIN.png","hash":"80bfd5ad46985693297d43a9c199a8fa7149caa9","modified":1611212186026},{"_id":"source/_posts/sql-revise/RIGHT_EXCLUDING_JOIN.png","hash":"d25f73221c620d82f62519dacd7b826d7fa6ec7b","modified":1611212185695},{"_id":"source/_posts/sql-revise/RIGHT_JOIN.png","hash":"9508b89fabef50db34cd895df23e8dfca1f32e55","modified":1611212185406},{"_id":"source/_posts/sql-revise/Union-1.png","hash":"a0b8d009947052d2860a5bfe38bea6ce2ddd319b","modified":1611212171338},{"_id":"source/_posts/sql-revise/Union-2.png","hash":"f789f29d1f6499fdab82e0337f5c65827353d781","modified":1611212171225},{"_id":"source/_posts/sql-revise/Union-3.png","hash":"b92a5c84b769dca861306b8533b90a220e3fec3e","modified":1611212171033},{"_id":"source/_posts/distribute-system-consensus/generate-line.png","hash":"af91ca7e6f039d4f2275074b90b2a03a75ff8de3","modified":1611210997155},{"_id":"source/_posts/raft-lab-2/RaftProcess.png","hash":"e0ba0d2b3bb78cb49e1a925c6f6d39810c6919a4","modified":1611211201686},{"_id":"source/_posts/distribute-system-consensus/LamportTimestamp.png","hash":"cd9167f36d443923340bc6696f2b2e9451845f54","modified":1611210834129},{"_id":"source/_posts/distribute-system-consensus/line-final.png","hash":"b9d5a320acd4afd4bde5ff371d39083ec1d42e27","modified":1611210962261},{"_id":"source/_posts/sql-revise/Visual_SQL_JOINS_orig.jpg","hash":"680a869474697bae045105b4ea3fb7db14cbdce9","modified":1611212185259},{"_id":"source/_posts/distribute-system-consensus/quroum-fail.png","hash":"a232d6ebba1f33265a1032cb348637d664f34e2f","modified":1611210902828},{"_id":"source/_posts/distribute-system-consensus/non-linearized-example.png","hash":"aa4ad4b7808ba88b228868f8c193cad6c965048d","modified":1611211049907}],"Category":[],"Data":[],"Page":[{"type":"categories","_content":"Golang  \nBackendDevelop\nDevops\nMonitorSystem\n","source":"categories/index.md","raw":"---\ntype: \"categories\"\n---\nGolang  \nBackendDevelop\nDevops\nMonitorSystem\n","date":"2021-01-21T03:49:18.287Z","updated":"2021-01-21T03:49:18.283Z","path":"categories/index.html","_id":"ckk68q9f90000lpi53xl4h3wk","title":"","comments":1,"layout":"page","content":"<p>Golang<br>BackendDevelop<br>Devops<br>MonitorSystem</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Golang<br>BackendDevelop<br>Devops<br>MonitorSystem</p>\n"},{"type":"tags","_content":"","source":"tags/index.md","raw":"---\ntype: \"tags\"\n---\n","date":"2021-01-21T02:53:21.625Z","updated":"2021-01-21T02:53:21.625Z","path":"tags/index.html","_id":"ckk69ad5n0000w1i5dc7d9par","title":"","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"MIT6.824 Lab2 实现及解析","date":"2019-08-28T07:05:38.000Z","_content":"\n<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab2 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n# 目录\n1. [Raft论文阅读](#PaperReading)  \n2. [实现细节](#Detail)    \n        2.1 [Raft整体流程](#2.1)    \n        2.2 [Raft状态机维护](#2.2)  \n        2.3 [Raft代码实现](#2.3)  \n\n# <a id=\"PaperReading\"><span class=\"toptitle\">论文阅读及问题</span></a>\n\n论文各个章节主要解析\n1. 总体介绍，解析创造Raft的原因，并且简单描述Raft与Paxos的不同点\n2. 简单介绍一下副本状态机这个概念\n3. 简单描述Paxos的问题（包括了不好理解以及工业化上面的问题）\n4. 阐述Raft为什么比Paxos好理解\n5. Raft的算法的详细描述以及边界条件\n6. Raft集群出现成员变动的时候如何处理\n7. Raft的日志压缩和快照\n8. Client与Raft集群的交互方式\n\n实现的时候，重点要看Figure2中所提及的条件。\n\n# <a id=\"Detail\"><span class=\"toptitle\">代码实现</span></a>\n## <a id=\"2.1\"><span class=\"secondtitle\"> Raft整体流程</span></a>\n\n<!-- ![Raft整体流程](/assets/img/posts/RaftProcess.png) -->\n{% asset_img RaftProcess.png Raft整体流程 %}\n\n此处只是一个比较简单的忽略具体可能出现错误细节的描述。\n本质上Raft就是一个通过一个维护一个协程里面的状态机，并且通过其他做网络请求的协程达成大部分节点在共识的算法。\n具体可以看这里的![演示动画](https://raft.github.io/)\n\n## <a id=\"2.2\"><span class=\"secondtitle\"> Raft状态机的转换</span></a>\n<!-- ![Raft整体流程](/assets/img/posts/RaftStateMachine.png) -->\n{% asset_img RaftStateMachine.png Raft状态机流程 %}\n\n此处是一个简单状态机的描述，具体转换的原因也已经在图上面有标出来。\n\n\n\n## <a id=\"2.3\"><span class=\"secondtitle\"> Raft代码的实现</span></a>\n代码实现在这个Lab中实际上分为了3part\n1. PartA  完成选举\n2. PartB  完成日志\n3. PartC  完成持久化的工作，并且处理共识的边界条件\n\n\n### PartA 的实现 \n跟随论文中提及的RequestVote RPC 以及 AppendEntries RPC 实现即可\n此处可以只需要完成心跳发送后可以保证非主节点不超时，不会使得Term有变动即可。\n\n一个注意的点，发送这两个RPC的时候，都是需要并行发送的，因此每个请求需要使用一个GoRoutine去进行实现。\n下面代码就是发送AppendEntries的代码的实例\n```\n    logs := make([]Log, 0)\n    tmpIndex := min(max(0, rf.nextIndex[number]-1), rf.logs[rf.getLen()].Index)\n    if tmpIndex < rf.logs[rf.getLen()].Index {\n        logs = rf.logs[tmpIndex+1-firstIndex:]\n        //DPrintf(\"server %d is Leader, tmpIndex is %d, firstIndex is %d, len of log is %d, commited index is %d\",\n        //\trf.me, tmpIndex, firstIndex, len(rf.logs), rf.commitedIndex)\n    }\n    args := AppendEntriesArgs{Term: rf.currentTerm, LeaderId: rf.me,\n        PrevLogTerm: rf.logs[tmpIndex-firstIndex].Term, PrevLogIndex: tmpIndex,\n        Entries: logs, Leadercommited: rf.commitedIndex}\n    //  使用Goroutine来发送请求\n    go func(args AppendEntriesArgs, number int) {\n        reply := AppendEntriesReply{}\n        ok := rf.sendAppendEntires(number, &args, &reply)\n        rf.mu.Lock()\n        defer rf.mu.Unlock()\n        if !ok {\n            DPrintf(\"allAppendEntries server %d call remote %d rpc AppendEntries failed\", rf.me, number)\n        }\n        if args.Term != rf.currentTerm {\n            return\n        }\n        if reply.Term > rf.currentTerm {\n            //rf.mu.Lock()\n            rf.state = Follower\n            rf.currentTerm = reply.Term\n            // TODO why Term voliate needed to persist?\n            rf.persist()\n            //rf.mu.Unlock()\n            return\n        }\n        if reply.Success == true && rf.state == Leader {\n            if len(args.Entries) > 0 {\n                rf.nextIndex[number] = args.Entries[len(args.Entries)-1].Index + 1\n                rf.matchIndex[number] = rf.nextIndex[number] - 1\n                if rf.matchIndex[number] > rf.commitedIndex {\n                    rf.updateCommit()\n                }\n            }\n        } else if rf.state == Leader {\n            if rf.nextIndex[number] > reply.PrevIndex+1 {\n                rf.nextIndex[number] = reply.PrevIndex + 1\n            } else {\n                rf.nextIndex[number] = max(rf.nextIndex[number]-1, 1)\n            }\n        }\n    }(args, number)\n```\n并且注意实现的时候的锁的使用，保证每次使用锁都有加锁和解锁的操作成对出现，否则可能会出现一些比较奇怪的情况。\n\n\n### PartB的实现\n此处需要接受模拟从客户端的请求进来然后把Log先放到本地的Log上面，然后把Log同步到其他的节点上面去进行共识的达成。\n\n首先的条件，需要确保Start函数接受请求的时候必须是Leader的角色，否则不会接收请求。（论文中有提及，此处Raft集群中非Leader节点不会把日志写入的请求转发到Leader节点上，这个是为了维护的方便来做的）\n```\nfunc (rf *Raft) Start(command interface{}) (int, int, bool) {\n\tindex := -1\n\tterm := -1\n\tisLeader := true\n\t// Wanring: do not double add lock for GetState function\n\trf.mu.Lock()\n\tdefer rf.mu.Unlock()\n\tterm, isLeader = rf.GetState()\n\tif isLeader {\n\t\tindex = rf.logs[rf.getLen()].Index + 1\n\t\t//oldLogLen := len(rf.logs)\n\t\trf.logs = append(rf.logs, Log{command, term, index})\n\t\t//DPrintf(\"server %d is Leader. new log has been appended, old length is %d, now is %d.  index number is %d, commitedindex is %d\",\n\t\t//\trf.me, oldLogLen, len(rf.logs), index, rf.commitedIndex)\n\t\tif len(rf.chanNewLog) == 0 {\n\t\t\trf.chanNewLog <- 1\n\t\t}\n\t\trf.persist()\n\t}\n\treturn index, term, isLeader\n}\n```\n重点处理的地方是nextIndex和MatchIndex 的计算以及维护的问题\n#### Apply的实现\n因为对于外部客户端的行为来说，Start函数是一个异步的函数, 所以实际上客户端是通过等待Make函数中输入的ApplyCh来确定能够apply成功，保证对外的原子性\n```\nfunc (rf *Raft) doApply() {\n\tfor {\n\t\trf.mu.Lock()\n\t\tst := rf.state\n\t\trf.mu.Unlock()\n\t\tif st == Killed {\n\t\t\treturn\n\t\t}\n\t\tselect {\n\t\tcase <-rf.chanCommit:\n\t\t\tfor {\n\t\t\t\trf.mu.Lock()\n\t\t\t\tif !(rf.lastApplied < rf.commitedIndex && rf.lastApplied < rf.logs[rf.getLen()].Index) {\n\t\t\t\t\trf.mu.Unlock()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tFirstIndex := rf.logs[0].Index\n\t\t\t\tif rf.lastApplied+1 >= FirstIndex {\n\t\t\t\t\tindex := min(rf.lastApplied+1-FirstIndex, rf.getLen())\n\t\t\t\t\tmsg := ApplyMsg{CommandValid: true, Command: rf.logs[index].Command, CommandIndex: rf.lastApplied + 1}\n\t\t\t\t\trf.lastApplied++\n\t\t\t\t\trf.mu.Unlock()\n\t\t\t\t\t//can't lock when send in channel, dead lock\n\t\t\t\t\t// canApplychan is to block the new\n\t\t\t\t\trf.chanCanApply <- 1\n\t\t\t\t\trf.chanApplyMsg <- msg\n\t\t\t\t\t<-rf.chanCanApply\n\t\t\t\t\trf.mu.Lock()\n\t\t\t\t}\n\t\t\t\trf.mu.Unlock()\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n\n### PartC的实现\n此处首先需要添加状态机的持久化的方法，并且需要在启动的时候添加一个读取旧的持久化状态机的方法。\n```\nfunc (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) {\n\trf.chanCanApply <- 1\n\trf.mu.Lock()\n\treply.Success = false\n\tpersistFlag := 0\n\tif args.Term < rf.currentTerm {\n\t\treply.Term = rf.currentTerm\n\t\trf.mu.Unlock()\n\t\t<-rf.chanCanApply\n\t\treturn\n\t}\n\tif rf.currentTerm < args.Term {\n\t\trf.currentTerm = args.Term\n\t\trf.ClearChan()\n\t\trf.voteFor = -1\n\t\trf.state = Follower\n\t\tpersistFlag = 1\n\t}\n\treply.Term = rf.currentTerm\n\t// similar to appendEntries receive call\n\trf.chanAppendEntries <- 1\n\tfirstIndex := rf.logs[0].Index\n\tnowIndex := args.LastIncludeIndex - firstIndex\n\tif nowIndex < 0 {\n\t\tif persistFlag == 1 {\n\t\t\trf.persist()\n\t\t}\n\t\treply.PrevIndex = firstIndex\n\t\trf.mu.Unlock()\n\t\t<-rf.chanCanApply\n\t\treturn\n\t}\n\trf.logs = args.Logs\n\trf.lastApplied = args.LastIncludeIndex\n\trf.commitedIndex = args.LeaderCommitIndex\n\trf.persister.SaveStateAndSnapshot(rf.getPersistByte(), args.Snapshot)\n\tmsg := ApplyMsg{CommandValid: false, Snapshot: args.Snapshot}\n\trf.mu.Unlock()\n\trf.chanApplyMsg <- msg\n\t<-rf.chanCanApply\n\treply.Success = true\n\n}\n\n```\n\n```\n// 启动的时候添加这个方法把Snapshotload出来\nrf.readPersist(persister.ReadRaftState())\n```\n\n并且需要注意在投票部分需要根据Safty那里提及的一个重要的地方，如果RequestVote RPC里面的日志Term与目前的Term不是一致的情况下，不能通过数票数的方法来进行计算。这个是为了整个集群的正确来考虑的。\n```\nfunc (rf *Raft) updateCommit() {\n\tN := rf.commitedIndex\n\tFirstIndex := rf.logs[0].Index\n\tfor i := max(rf.commitedIndex+1, FirstIndex+1); i <= rf.logs[rf.getLen()].Index; i++ {\n\t\tnum := 1\n\t\tfor j := range rf.peers {\n\t\t\tif j != rf.me {\n\t\t\t\tif rf.matchIndex[j] >= i {\n\t\t\t\t\t/*\n\t\t\t\t\t\tthis part is paper 5.4.2 limit, only can count replicate when log's term\n\t\t\t\t\t\tis equals to currentTerm\n\t\t\t\t\t*/\n\t\t\t\t\tif rf.logs[i-FirstIndex].Term == rf.currentTerm {\n\t\t\t\t\t\tnum++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif num > len(rf.peers)/2 {\n\t\t\tN = i\n\t\t}\n\t}\n\tif N > rf.commitedIndex && rf.state == Leader {\n\t\trf.commitedIndex = min(N, rf.logs[rf.getLen()].Index)\n\t\trf.chanCommit <- 1\n\t}\n}\n```","source":"_posts/raft-lab-2.md","raw":"---\ntitle:  MIT6.824 Lab2 实现及解析\ndate: 2019-08-28 15:05:38\ntags:  distributed-system\n---\n\n<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab2 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n# 目录\n1. [Raft论文阅读](#PaperReading)  \n2. [实现细节](#Detail)    \n        2.1 [Raft整体流程](#2.1)    \n        2.2 [Raft状态机维护](#2.2)  \n        2.3 [Raft代码实现](#2.3)  \n\n# <a id=\"PaperReading\"><span class=\"toptitle\">论文阅读及问题</span></a>\n\n论文各个章节主要解析\n1. 总体介绍，解析创造Raft的原因，并且简单描述Raft与Paxos的不同点\n2. 简单介绍一下副本状态机这个概念\n3. 简单描述Paxos的问题（包括了不好理解以及工业化上面的问题）\n4. 阐述Raft为什么比Paxos好理解\n5. Raft的算法的详细描述以及边界条件\n6. Raft集群出现成员变动的时候如何处理\n7. Raft的日志压缩和快照\n8. Client与Raft集群的交互方式\n\n实现的时候，重点要看Figure2中所提及的条件。\n\n# <a id=\"Detail\"><span class=\"toptitle\">代码实现</span></a>\n## <a id=\"2.1\"><span class=\"secondtitle\"> Raft整体流程</span></a>\n\n<!-- ![Raft整体流程](/assets/img/posts/RaftProcess.png) -->\n{% asset_img RaftProcess.png Raft整体流程 %}\n\n此处只是一个比较简单的忽略具体可能出现错误细节的描述。\n本质上Raft就是一个通过一个维护一个协程里面的状态机，并且通过其他做网络请求的协程达成大部分节点在共识的算法。\n具体可以看这里的![演示动画](https://raft.github.io/)\n\n## <a id=\"2.2\"><span class=\"secondtitle\"> Raft状态机的转换</span></a>\n<!-- ![Raft整体流程](/assets/img/posts/RaftStateMachine.png) -->\n{% asset_img RaftStateMachine.png Raft状态机流程 %}\n\n此处是一个简单状态机的描述，具体转换的原因也已经在图上面有标出来。\n\n\n\n## <a id=\"2.3\"><span class=\"secondtitle\"> Raft代码的实现</span></a>\n代码实现在这个Lab中实际上分为了3part\n1. PartA  完成选举\n2. PartB  完成日志\n3. PartC  完成持久化的工作，并且处理共识的边界条件\n\n\n### PartA 的实现 \n跟随论文中提及的RequestVote RPC 以及 AppendEntries RPC 实现即可\n此处可以只需要完成心跳发送后可以保证非主节点不超时，不会使得Term有变动即可。\n\n一个注意的点，发送这两个RPC的时候，都是需要并行发送的，因此每个请求需要使用一个GoRoutine去进行实现。\n下面代码就是发送AppendEntries的代码的实例\n```\n    logs := make([]Log, 0)\n    tmpIndex := min(max(0, rf.nextIndex[number]-1), rf.logs[rf.getLen()].Index)\n    if tmpIndex < rf.logs[rf.getLen()].Index {\n        logs = rf.logs[tmpIndex+1-firstIndex:]\n        //DPrintf(\"server %d is Leader, tmpIndex is %d, firstIndex is %d, len of log is %d, commited index is %d\",\n        //\trf.me, tmpIndex, firstIndex, len(rf.logs), rf.commitedIndex)\n    }\n    args := AppendEntriesArgs{Term: rf.currentTerm, LeaderId: rf.me,\n        PrevLogTerm: rf.logs[tmpIndex-firstIndex].Term, PrevLogIndex: tmpIndex,\n        Entries: logs, Leadercommited: rf.commitedIndex}\n    //  使用Goroutine来发送请求\n    go func(args AppendEntriesArgs, number int) {\n        reply := AppendEntriesReply{}\n        ok := rf.sendAppendEntires(number, &args, &reply)\n        rf.mu.Lock()\n        defer rf.mu.Unlock()\n        if !ok {\n            DPrintf(\"allAppendEntries server %d call remote %d rpc AppendEntries failed\", rf.me, number)\n        }\n        if args.Term != rf.currentTerm {\n            return\n        }\n        if reply.Term > rf.currentTerm {\n            //rf.mu.Lock()\n            rf.state = Follower\n            rf.currentTerm = reply.Term\n            // TODO why Term voliate needed to persist?\n            rf.persist()\n            //rf.mu.Unlock()\n            return\n        }\n        if reply.Success == true && rf.state == Leader {\n            if len(args.Entries) > 0 {\n                rf.nextIndex[number] = args.Entries[len(args.Entries)-1].Index + 1\n                rf.matchIndex[number] = rf.nextIndex[number] - 1\n                if rf.matchIndex[number] > rf.commitedIndex {\n                    rf.updateCommit()\n                }\n            }\n        } else if rf.state == Leader {\n            if rf.nextIndex[number] > reply.PrevIndex+1 {\n                rf.nextIndex[number] = reply.PrevIndex + 1\n            } else {\n                rf.nextIndex[number] = max(rf.nextIndex[number]-1, 1)\n            }\n        }\n    }(args, number)\n```\n并且注意实现的时候的锁的使用，保证每次使用锁都有加锁和解锁的操作成对出现，否则可能会出现一些比较奇怪的情况。\n\n\n### PartB的实现\n此处需要接受模拟从客户端的请求进来然后把Log先放到本地的Log上面，然后把Log同步到其他的节点上面去进行共识的达成。\n\n首先的条件，需要确保Start函数接受请求的时候必须是Leader的角色，否则不会接收请求。（论文中有提及，此处Raft集群中非Leader节点不会把日志写入的请求转发到Leader节点上，这个是为了维护的方便来做的）\n```\nfunc (rf *Raft) Start(command interface{}) (int, int, bool) {\n\tindex := -1\n\tterm := -1\n\tisLeader := true\n\t// Wanring: do not double add lock for GetState function\n\trf.mu.Lock()\n\tdefer rf.mu.Unlock()\n\tterm, isLeader = rf.GetState()\n\tif isLeader {\n\t\tindex = rf.logs[rf.getLen()].Index + 1\n\t\t//oldLogLen := len(rf.logs)\n\t\trf.logs = append(rf.logs, Log{command, term, index})\n\t\t//DPrintf(\"server %d is Leader. new log has been appended, old length is %d, now is %d.  index number is %d, commitedindex is %d\",\n\t\t//\trf.me, oldLogLen, len(rf.logs), index, rf.commitedIndex)\n\t\tif len(rf.chanNewLog) == 0 {\n\t\t\trf.chanNewLog <- 1\n\t\t}\n\t\trf.persist()\n\t}\n\treturn index, term, isLeader\n}\n```\n重点处理的地方是nextIndex和MatchIndex 的计算以及维护的问题\n#### Apply的实现\n因为对于外部客户端的行为来说，Start函数是一个异步的函数, 所以实际上客户端是通过等待Make函数中输入的ApplyCh来确定能够apply成功，保证对外的原子性\n```\nfunc (rf *Raft) doApply() {\n\tfor {\n\t\trf.mu.Lock()\n\t\tst := rf.state\n\t\trf.mu.Unlock()\n\t\tif st == Killed {\n\t\t\treturn\n\t\t}\n\t\tselect {\n\t\tcase <-rf.chanCommit:\n\t\t\tfor {\n\t\t\t\trf.mu.Lock()\n\t\t\t\tif !(rf.lastApplied < rf.commitedIndex && rf.lastApplied < rf.logs[rf.getLen()].Index) {\n\t\t\t\t\trf.mu.Unlock()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tFirstIndex := rf.logs[0].Index\n\t\t\t\tif rf.lastApplied+1 >= FirstIndex {\n\t\t\t\t\tindex := min(rf.lastApplied+1-FirstIndex, rf.getLen())\n\t\t\t\t\tmsg := ApplyMsg{CommandValid: true, Command: rf.logs[index].Command, CommandIndex: rf.lastApplied + 1}\n\t\t\t\t\trf.lastApplied++\n\t\t\t\t\trf.mu.Unlock()\n\t\t\t\t\t//can't lock when send in channel, dead lock\n\t\t\t\t\t// canApplychan is to block the new\n\t\t\t\t\trf.chanCanApply <- 1\n\t\t\t\t\trf.chanApplyMsg <- msg\n\t\t\t\t\t<-rf.chanCanApply\n\t\t\t\t\trf.mu.Lock()\n\t\t\t\t}\n\t\t\t\trf.mu.Unlock()\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n\n### PartC的实现\n此处首先需要添加状态机的持久化的方法，并且需要在启动的时候添加一个读取旧的持久化状态机的方法。\n```\nfunc (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) {\n\trf.chanCanApply <- 1\n\trf.mu.Lock()\n\treply.Success = false\n\tpersistFlag := 0\n\tif args.Term < rf.currentTerm {\n\t\treply.Term = rf.currentTerm\n\t\trf.mu.Unlock()\n\t\t<-rf.chanCanApply\n\t\treturn\n\t}\n\tif rf.currentTerm < args.Term {\n\t\trf.currentTerm = args.Term\n\t\trf.ClearChan()\n\t\trf.voteFor = -1\n\t\trf.state = Follower\n\t\tpersistFlag = 1\n\t}\n\treply.Term = rf.currentTerm\n\t// similar to appendEntries receive call\n\trf.chanAppendEntries <- 1\n\tfirstIndex := rf.logs[0].Index\n\tnowIndex := args.LastIncludeIndex - firstIndex\n\tif nowIndex < 0 {\n\t\tif persistFlag == 1 {\n\t\t\trf.persist()\n\t\t}\n\t\treply.PrevIndex = firstIndex\n\t\trf.mu.Unlock()\n\t\t<-rf.chanCanApply\n\t\treturn\n\t}\n\trf.logs = args.Logs\n\trf.lastApplied = args.LastIncludeIndex\n\trf.commitedIndex = args.LeaderCommitIndex\n\trf.persister.SaveStateAndSnapshot(rf.getPersistByte(), args.Snapshot)\n\tmsg := ApplyMsg{CommandValid: false, Snapshot: args.Snapshot}\n\trf.mu.Unlock()\n\trf.chanApplyMsg <- msg\n\t<-rf.chanCanApply\n\treply.Success = true\n\n}\n\n```\n\n```\n// 启动的时候添加这个方法把Snapshotload出来\nrf.readPersist(persister.ReadRaftState())\n```\n\n并且需要注意在投票部分需要根据Safty那里提及的一个重要的地方，如果RequestVote RPC里面的日志Term与目前的Term不是一致的情况下，不能通过数票数的方法来进行计算。这个是为了整个集群的正确来考虑的。\n```\nfunc (rf *Raft) updateCommit() {\n\tN := rf.commitedIndex\n\tFirstIndex := rf.logs[0].Index\n\tfor i := max(rf.commitedIndex+1, FirstIndex+1); i <= rf.logs[rf.getLen()].Index; i++ {\n\t\tnum := 1\n\t\tfor j := range rf.peers {\n\t\t\tif j != rf.me {\n\t\t\t\tif rf.matchIndex[j] >= i {\n\t\t\t\t\t/*\n\t\t\t\t\t\tthis part is paper 5.4.2 limit, only can count replicate when log's term\n\t\t\t\t\t\tis equals to currentTerm\n\t\t\t\t\t*/\n\t\t\t\t\tif rf.logs[i-FirstIndex].Term == rf.currentTerm {\n\t\t\t\t\t\tnum++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif num > len(rf.peers)/2 {\n\t\t\tN = i\n\t\t}\n\t}\n\tif N > rf.commitedIndex && rf.state == Leader {\n\t\trf.commitedIndex = min(N, rf.logs[rf.getLen()].Index)\n\t\trf.chanCommit <- 1\n\t}\n}\n```","slug":"raft-lab-2","published":1,"updated":"2021-01-21T07:28:16.144Z","_id":"ckk6h2epb0000eci53tuy7iuk","comments":1,"layout":"post","photos":[],"link":"","content":"<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab2 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#PaperReading\">Raft论文阅读</a>  </li>\n<li><a href=\"#Detail\">实现细节</a>    <pre><code> 2.1 [Raft整体流程](#2.1)    \n 2.2 [Raft状态机维护](#2.2)  \n 2.3 [Raft代码实现](#2.3)  </code></pre>\n</li>\n</ol>\n\n        <h1 id=\"论文阅读及问题\"   >\n          <a href=\"#论文阅读及问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>论文阅读及问题</h1>\n      <p>论文各个章节主要解析</p>\n<ol>\n<li>总体介绍，解析创造Raft的原因，并且简单描述Raft与Paxos的不同点</li>\n<li>简单介绍一下副本状态机这个概念</li>\n<li>简单描述Paxos的问题（包括了不好理解以及工业化上面的问题）</li>\n<li>阐述Raft为什么比Paxos好理解</li>\n<li>Raft的算法的详细描述以及边界条件</li>\n<li>Raft集群出现成员变动的时候如何处理</li>\n<li>Raft的日志压缩和快照</li>\n<li>Client与Raft集群的交互方式</li>\n</ol>\n<p>实现的时候，重点要看Figure2中所提及的条件。</p>\n\n        <h1 id=\"代码实现\"   >\n          <a href=\"#代码实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码实现</h1>\n      \n        <h2 id=\"Raft整体流程\"   >\n          <a href=\"#Raft整体流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft整体流程</h2>\n      <!-- ![Raft整体流程](/assets/img/posts/RaftProcess.png) -->\n<img src=\"/2019/08/28/raft-lab-2/RaftProcess.png\" class=\"\" title=\"Raft整体流程\">\n\n<p>此处只是一个比较简单的忽略具体可能出现错误细节的描述。<br>本质上Raft就是一个通过一个维护一个协程里面的状态机，并且通过其他做网络请求的协程达成大部分节点在共识的算法。<br>具体可以看这里的<img src=\"https://raft.github.io/\" alt=\"演示动画\"></p>\n\n        <h2 id=\"Raft状态机的转换\"   >\n          <a href=\"#Raft状态机的转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft状态机的转换</h2>\n      <!-- ![Raft整体流程](/assets/img/posts/RaftStateMachine.png) -->\n<img src=\"/2019/08/28/raft-lab-2/RaftStateMachine.png\" class=\"\" title=\"Raft状态机流程\">\n\n<p>此处是一个简单状态机的描述，具体转换的原因也已经在图上面有标出来。</p>\n\n        <h2 id=\"Raft代码的实现\"   >\n          <a href=\"#Raft代码的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft代码的实现</h2>\n      <p>代码实现在这个Lab中实际上分为了3part</p>\n<ol>\n<li>PartA  完成选举</li>\n<li>PartB  完成日志</li>\n<li>PartC  完成持久化的工作，并且处理共识的边界条件</li>\n</ol>\n\n        <h3 id=\"PartA-的实现\"   >\n          <a href=\"#PartA-的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartA 的实现</h3>\n      <p>跟随论文中提及的RequestVote RPC 以及 AppendEntries RPC 实现即可<br>此处可以只需要完成心跳发送后可以保证非主节点不超时，不会使得Term有变动即可。</p>\n<p>一个注意的点，发送这两个RPC的时候，都是需要并行发送的，因此每个请求需要使用一个GoRoutine去进行实现。<br>下面代码就是发送AppendEntries的代码的实例</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logs :&#x3D; make([]Log, 0)</span><br><span class=\"line\">tmpIndex :&#x3D; min(max(0, rf.nextIndex[number]-1), rf.logs[rf.getLen()].Index)</span><br><span class=\"line\">if tmpIndex &lt; rf.logs[rf.getLen()].Index &#123;</span><br><span class=\"line\">    logs &#x3D; rf.logs[tmpIndex+1-firstIndex:]</span><br><span class=\"line\">    &#x2F;&#x2F;DPrintf(&quot;server %d is Leader, tmpIndex is %d, firstIndex is %d, len of log is %d, commited index is %d&quot;,</span><br><span class=\"line\">    &#x2F;&#x2F;\trf.me, tmpIndex, firstIndex, len(rf.logs), rf.commitedIndex)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">args :&#x3D; AppendEntriesArgs&#123;Term: rf.currentTerm, LeaderId: rf.me,</span><br><span class=\"line\">    PrevLogTerm: rf.logs[tmpIndex-firstIndex].Term, PrevLogIndex: tmpIndex,</span><br><span class=\"line\">    Entries: logs, Leadercommited: rf.commitedIndex&#125;</span><br><span class=\"line\">&#x2F;&#x2F;  使用Goroutine来发送请求</span><br><span class=\"line\">go func(args AppendEntriesArgs, number int) &#123;</span><br><span class=\"line\">    reply :&#x3D; AppendEntriesReply&#123;&#125;</span><br><span class=\"line\">    ok :&#x3D; rf.sendAppendEntires(number, &amp;args, &amp;reply)</span><br><span class=\"line\">    rf.mu.Lock()</span><br><span class=\"line\">    defer rf.mu.Unlock()</span><br><span class=\"line\">    if !ok &#123;</span><br><span class=\"line\">        DPrintf(&quot;allAppendEntries server %d call remote %d rpc AppendEntries failed&quot;, rf.me, number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if args.Term !&#x3D; rf.currentTerm &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if reply.Term &gt; rf.currentTerm &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;rf.mu.Lock()</span><br><span class=\"line\">        rf.state &#x3D; Follower</span><br><span class=\"line\">        rf.currentTerm &#x3D; reply.Term</span><br><span class=\"line\">        &#x2F;&#x2F; TODO why Term voliate needed to persist?</span><br><span class=\"line\">        rf.persist()</span><br><span class=\"line\">        &#x2F;&#x2F;rf.mu.Unlock()</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if reply.Success &#x3D;&#x3D; true &amp;&amp; rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">        if len(args.Entries) &gt; 0 &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; args.Entries[len(args.Entries)-1].Index + 1</span><br><span class=\"line\">            rf.matchIndex[number] &#x3D; rf.nextIndex[number] - 1</span><br><span class=\"line\">            if rf.matchIndex[number] &gt; rf.commitedIndex &#123;</span><br><span class=\"line\">                rf.updateCommit()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else if rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">        if rf.nextIndex[number] &gt; reply.PrevIndex+1 &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; reply.PrevIndex + 1</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; max(rf.nextIndex[number]-1, 1)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(args, number)</span><br></pre></td></tr></table></div></figure>\n<p>并且注意实现的时候的锁的使用，保证每次使用锁都有加锁和解锁的操作成对出现，否则可能会出现一些比较奇怪的情况。</p>\n\n        <h3 id=\"PartB的实现\"   >\n          <a href=\"#PartB的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartB的实现</h3>\n      <p>此处需要接受模拟从客户端的请求进来然后把Log先放到本地的Log上面，然后把Log同步到其他的节点上面去进行共识的达成。</p>\n<p>首先的条件，需要确保Start函数接受请求的时候必须是Leader的角色，否则不会接收请求。（论文中有提及，此处Raft集群中非Leader节点不会把日志写入的请求转发到Leader节点上，这个是为了维护的方便来做的）</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) Start(command interface&#123;&#125;) (int, int, bool) &#123;</span><br><span class=\"line\">\tindex :&#x3D; -1</span><br><span class=\"line\">\tterm :&#x3D; -1</span><br><span class=\"line\">\tisLeader :&#x3D; true</span><br><span class=\"line\">\t&#x2F;&#x2F; Wanring: do not double add lock for GetState function</span><br><span class=\"line\">\trf.mu.Lock()</span><br><span class=\"line\">\tdefer rf.mu.Unlock()</span><br><span class=\"line\">\tterm, isLeader &#x3D; rf.GetState()</span><br><span class=\"line\">\tif isLeader &#123;</span><br><span class=\"line\">\t\tindex &#x3D; rf.logs[rf.getLen()].Index + 1</span><br><span class=\"line\">\t\t&#x2F;&#x2F;oldLogLen :&#x3D; len(rf.logs)</span><br><span class=\"line\">\t\trf.logs &#x3D; append(rf.logs, Log&#123;command, term, index&#125;)</span><br><span class=\"line\">\t\t&#x2F;&#x2F;DPrintf(&quot;server %d is Leader. new log has been appended, old length is %d, now is %d.  index number is %d, commitedindex is %d&quot;,</span><br><span class=\"line\">\t\t&#x2F;&#x2F;\trf.me, oldLogLen, len(rf.logs), index, rf.commitedIndex)</span><br><span class=\"line\">\t\tif len(rf.chanNewLog) &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\trf.chanNewLog &lt;- 1</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\trf.persist()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn index, term, isLeader</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>重点处理的地方是nextIndex和MatchIndex 的计算以及维护的问题</p>\n\n        <h4 id=\"Apply的实现\"   >\n          <a href=\"#Apply的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Apply的实现</h4>\n      <p>因为对于外部客户端的行为来说，Start函数是一个异步的函数, 所以实际上客户端是通过等待Make函数中输入的ApplyCh来确定能够apply成功，保证对外的原子性</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) doApply() &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\trf.mu.Lock()</span><br><span class=\"line\">\t\tst :&#x3D; rf.state</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\tif st &#x3D;&#x3D; Killed &#123;</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-rf.chanCommit:</span><br><span class=\"line\">\t\t\tfor &#123;</span><br><span class=\"line\">\t\t\t\trf.mu.Lock()</span><br><span class=\"line\">\t\t\t\tif !(rf.lastApplied &lt; rf.commitedIndex &amp;&amp; rf.lastApplied &lt; rf.logs[rf.getLen()].Index) &#123;</span><br><span class=\"line\">\t\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tFirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\t\t\t\tif rf.lastApplied+1 &gt;&#x3D; FirstIndex &#123;</span><br><span class=\"line\">\t\t\t\t\tindex :&#x3D; min(rf.lastApplied+1-FirstIndex, rf.getLen())</span><br><span class=\"line\">\t\t\t\t\tmsg :&#x3D; ApplyMsg&#123;CommandValid: true, Command: rf.logs[index].Command, CommandIndex: rf.lastApplied + 1&#125;</span><br><span class=\"line\">\t\t\t\t\trf.lastApplied++</span><br><span class=\"line\">\t\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F;can&#39;t lock when send in channel, dead lock</span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F; canApplychan is to block the new</span><br><span class=\"line\">\t\t\t\t\trf.chanCanApply &lt;- 1</span><br><span class=\"line\">\t\t\t\t\trf.chanApplyMsg &lt;- msg</span><br><span class=\"line\">\t\t\t\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\t\t\t\trf.mu.Lock()</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"PartC的实现\"   >\n          <a href=\"#PartC的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartC的实现</h3>\n      <p>此处首先需要添加状态机的持久化的方法，并且需要在启动的时候添加一个读取旧的持久化状态机的方法。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class=\"line\">\trf.chanCanApply &lt;- 1</span><br><span class=\"line\">\trf.mu.Lock()</span><br><span class=\"line\">\treply.Success &#x3D; false</span><br><span class=\"line\">\tpersistFlag :&#x3D; 0</span><br><span class=\"line\">\tif args.Term &lt; rf.currentTerm &#123;</span><br><span class=\"line\">\t\treply.Term &#x3D; rf.currentTerm</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif rf.currentTerm &lt; args.Term &#123;</span><br><span class=\"line\">\t\trf.currentTerm &#x3D; args.Term</span><br><span class=\"line\">\t\trf.ClearChan()</span><br><span class=\"line\">\t\trf.voteFor &#x3D; -1</span><br><span class=\"line\">\t\trf.state &#x3D; Follower</span><br><span class=\"line\">\t\tpersistFlag &#x3D; 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treply.Term &#x3D; rf.currentTerm</span><br><span class=\"line\">\t&#x2F;&#x2F; similar to appendEntries receive call</span><br><span class=\"line\">\trf.chanAppendEntries &lt;- 1</span><br><span class=\"line\">\tfirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\tnowIndex :&#x3D; args.LastIncludeIndex - firstIndex</span><br><span class=\"line\">\tif nowIndex &lt; 0 &#123;</span><br><span class=\"line\">\t\tif persistFlag &#x3D;&#x3D; 1 &#123;</span><br><span class=\"line\">\t\t\trf.persist()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treply.PrevIndex &#x3D; firstIndex</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trf.logs &#x3D; args.Logs</span><br><span class=\"line\">\trf.lastApplied &#x3D; args.LastIncludeIndex</span><br><span class=\"line\">\trf.commitedIndex &#x3D; args.LeaderCommitIndex</span><br><span class=\"line\">\trf.persister.SaveStateAndSnapshot(rf.getPersistByte(), args.Snapshot)</span><br><span class=\"line\">\tmsg :&#x3D; ApplyMsg&#123;CommandValid: false, Snapshot: args.Snapshot&#125;</span><br><span class=\"line\">\trf.mu.Unlock()</span><br><span class=\"line\">\trf.chanApplyMsg &lt;- msg</span><br><span class=\"line\">\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\treply.Success &#x3D; true</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 启动的时候添加这个方法把Snapshotload出来</span><br><span class=\"line\">rf.readPersist(persister.ReadRaftState())</span><br></pre></td></tr></table></div></figure>\n<p>并且需要注意在投票部分需要根据Safty那里提及的一个重要的地方，如果RequestVote RPC里面的日志Term与目前的Term不是一致的情况下，不能通过数票数的方法来进行计算。这个是为了整个集群的正确来考虑的。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) updateCommit() &#123;</span><br><span class=\"line\">\tN :&#x3D; rf.commitedIndex</span><br><span class=\"line\">\tFirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\tfor i :&#x3D; max(rf.commitedIndex+1, FirstIndex+1); i &lt;&#x3D; rf.logs[rf.getLen()].Index; i++ &#123;</span><br><span class=\"line\">\t\tnum :&#x3D; 1</span><br><span class=\"line\">\t\tfor j :&#x3D; range rf.peers &#123;</span><br><span class=\"line\">\t\t\tif j !&#x3D; rf.me &#123;</span><br><span class=\"line\">\t\t\t\tif rf.matchIndex[j] &gt;&#x3D; i &#123;</span><br><span class=\"line\">\t\t\t\t\t&#x2F;*</span><br><span class=\"line\">\t\t\t\t\t\tthis part is paper 5.4.2 limit, only can count replicate when log&#39;s term</span><br><span class=\"line\">\t\t\t\t\t\tis equals to currentTerm</span><br><span class=\"line\">\t\t\t\t\t*&#x2F;</span><br><span class=\"line\">\t\t\t\t\tif rf.logs[i-FirstIndex].Term &#x3D;&#x3D; rf.currentTerm &#123;</span><br><span class=\"line\">\t\t\t\t\t\tnum++</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif num &gt; len(rf.peers)&#x2F;2 &#123;</span><br><span class=\"line\">\t\t\tN &#x3D; i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif N &gt; rf.commitedIndex &amp;&amp; rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">\t\trf.commitedIndex &#x3D; min(N, rf.logs[rf.getLen()].Index)</span><br><span class=\"line\">\t\trf.chanCommit &lt;- 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>","site":{"data":{}},"excerpt":"","more":"<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab2 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#PaperReading\">Raft论文阅读</a>  </li>\n<li><a href=\"#Detail\">实现细节</a>    <pre><code> 2.1 [Raft整体流程](#2.1)    \n 2.2 [Raft状态机维护](#2.2)  \n 2.3 [Raft代码实现](#2.3)  </code></pre>\n</li>\n</ol>\n\n        <h1 id=\"论文阅读及问题\"   >\n          <a href=\"#论文阅读及问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>论文阅读及问题</h1>\n      <p>论文各个章节主要解析</p>\n<ol>\n<li>总体介绍，解析创造Raft的原因，并且简单描述Raft与Paxos的不同点</li>\n<li>简单介绍一下副本状态机这个概念</li>\n<li>简单描述Paxos的问题（包括了不好理解以及工业化上面的问题）</li>\n<li>阐述Raft为什么比Paxos好理解</li>\n<li>Raft的算法的详细描述以及边界条件</li>\n<li>Raft集群出现成员变动的时候如何处理</li>\n<li>Raft的日志压缩和快照</li>\n<li>Client与Raft集群的交互方式</li>\n</ol>\n<p>实现的时候，重点要看Figure2中所提及的条件。</p>\n\n        <h1 id=\"代码实现\"   >\n          <a href=\"#代码实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码实现</h1>\n      \n        <h2 id=\"Raft整体流程\"   >\n          <a href=\"#Raft整体流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft整体流程</h2>\n      <!-- ![Raft整体流程](/assets/img/posts/RaftProcess.png) -->\n<img src=\"/2019/08/28/raft-lab-2/RaftProcess.png\" class=\"\" title=\"Raft整体流程\">\n\n<p>此处只是一个比较简单的忽略具体可能出现错误细节的描述。<br>本质上Raft就是一个通过一个维护一个协程里面的状态机，并且通过其他做网络请求的协程达成大部分节点在共识的算法。<br>具体可以看这里的<img src=\"https://raft.github.io/\" alt=\"演示动画\"></p>\n\n        <h2 id=\"Raft状态机的转换\"   >\n          <a href=\"#Raft状态机的转换\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft状态机的转换</h2>\n      <!-- ![Raft整体流程](/assets/img/posts/RaftStateMachine.png) -->\n<img src=\"/2019/08/28/raft-lab-2/RaftStateMachine.png\" class=\"\" title=\"Raft状态机流程\">\n\n<p>此处是一个简单状态机的描述，具体转换的原因也已经在图上面有标出来。</p>\n\n        <h2 id=\"Raft代码的实现\"   >\n          <a href=\"#Raft代码的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Raft代码的实现</h2>\n      <p>代码实现在这个Lab中实际上分为了3part</p>\n<ol>\n<li>PartA  完成选举</li>\n<li>PartB  完成日志</li>\n<li>PartC  完成持久化的工作，并且处理共识的边界条件</li>\n</ol>\n\n        <h3 id=\"PartA-的实现\"   >\n          <a href=\"#PartA-的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartA 的实现</h3>\n      <p>跟随论文中提及的RequestVote RPC 以及 AppendEntries RPC 实现即可<br>此处可以只需要完成心跳发送后可以保证非主节点不超时，不会使得Term有变动即可。</p>\n<p>一个注意的点，发送这两个RPC的时候，都是需要并行发送的，因此每个请求需要使用一个GoRoutine去进行实现。<br>下面代码就是发送AppendEntries的代码的实例</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logs :&#x3D; make([]Log, 0)</span><br><span class=\"line\">tmpIndex :&#x3D; min(max(0, rf.nextIndex[number]-1), rf.logs[rf.getLen()].Index)</span><br><span class=\"line\">if tmpIndex &lt; rf.logs[rf.getLen()].Index &#123;</span><br><span class=\"line\">    logs &#x3D; rf.logs[tmpIndex+1-firstIndex:]</span><br><span class=\"line\">    &#x2F;&#x2F;DPrintf(&quot;server %d is Leader, tmpIndex is %d, firstIndex is %d, len of log is %d, commited index is %d&quot;,</span><br><span class=\"line\">    &#x2F;&#x2F;\trf.me, tmpIndex, firstIndex, len(rf.logs), rf.commitedIndex)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">args :&#x3D; AppendEntriesArgs&#123;Term: rf.currentTerm, LeaderId: rf.me,</span><br><span class=\"line\">    PrevLogTerm: rf.logs[tmpIndex-firstIndex].Term, PrevLogIndex: tmpIndex,</span><br><span class=\"line\">    Entries: logs, Leadercommited: rf.commitedIndex&#125;</span><br><span class=\"line\">&#x2F;&#x2F;  使用Goroutine来发送请求</span><br><span class=\"line\">go func(args AppendEntriesArgs, number int) &#123;</span><br><span class=\"line\">    reply :&#x3D; AppendEntriesReply&#123;&#125;</span><br><span class=\"line\">    ok :&#x3D; rf.sendAppendEntires(number, &amp;args, &amp;reply)</span><br><span class=\"line\">    rf.mu.Lock()</span><br><span class=\"line\">    defer rf.mu.Unlock()</span><br><span class=\"line\">    if !ok &#123;</span><br><span class=\"line\">        DPrintf(&quot;allAppendEntries server %d call remote %d rpc AppendEntries failed&quot;, rf.me, number)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if args.Term !&#x3D; rf.currentTerm &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if reply.Term &gt; rf.currentTerm &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;rf.mu.Lock()</span><br><span class=\"line\">        rf.state &#x3D; Follower</span><br><span class=\"line\">        rf.currentTerm &#x3D; reply.Term</span><br><span class=\"line\">        &#x2F;&#x2F; TODO why Term voliate needed to persist?</span><br><span class=\"line\">        rf.persist()</span><br><span class=\"line\">        &#x2F;&#x2F;rf.mu.Unlock()</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if reply.Success &#x3D;&#x3D; true &amp;&amp; rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">        if len(args.Entries) &gt; 0 &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; args.Entries[len(args.Entries)-1].Index + 1</span><br><span class=\"line\">            rf.matchIndex[number] &#x3D; rf.nextIndex[number] - 1</span><br><span class=\"line\">            if rf.matchIndex[number] &gt; rf.commitedIndex &#123;</span><br><span class=\"line\">                rf.updateCommit()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else if rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">        if rf.nextIndex[number] &gt; reply.PrevIndex+1 &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; reply.PrevIndex + 1</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            rf.nextIndex[number] &#x3D; max(rf.nextIndex[number]-1, 1)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(args, number)</span><br></pre></td></tr></table></div></figure>\n<p>并且注意实现的时候的锁的使用，保证每次使用锁都有加锁和解锁的操作成对出现，否则可能会出现一些比较奇怪的情况。</p>\n\n        <h3 id=\"PartB的实现\"   >\n          <a href=\"#PartB的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartB的实现</h3>\n      <p>此处需要接受模拟从客户端的请求进来然后把Log先放到本地的Log上面，然后把Log同步到其他的节点上面去进行共识的达成。</p>\n<p>首先的条件，需要确保Start函数接受请求的时候必须是Leader的角色，否则不会接收请求。（论文中有提及，此处Raft集群中非Leader节点不会把日志写入的请求转发到Leader节点上，这个是为了维护的方便来做的）</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) Start(command interface&#123;&#125;) (int, int, bool) &#123;</span><br><span class=\"line\">\tindex :&#x3D; -1</span><br><span class=\"line\">\tterm :&#x3D; -1</span><br><span class=\"line\">\tisLeader :&#x3D; true</span><br><span class=\"line\">\t&#x2F;&#x2F; Wanring: do not double add lock for GetState function</span><br><span class=\"line\">\trf.mu.Lock()</span><br><span class=\"line\">\tdefer rf.mu.Unlock()</span><br><span class=\"line\">\tterm, isLeader &#x3D; rf.GetState()</span><br><span class=\"line\">\tif isLeader &#123;</span><br><span class=\"line\">\t\tindex &#x3D; rf.logs[rf.getLen()].Index + 1</span><br><span class=\"line\">\t\t&#x2F;&#x2F;oldLogLen :&#x3D; len(rf.logs)</span><br><span class=\"line\">\t\trf.logs &#x3D; append(rf.logs, Log&#123;command, term, index&#125;)</span><br><span class=\"line\">\t\t&#x2F;&#x2F;DPrintf(&quot;server %d is Leader. new log has been appended, old length is %d, now is %d.  index number is %d, commitedindex is %d&quot;,</span><br><span class=\"line\">\t\t&#x2F;&#x2F;\trf.me, oldLogLen, len(rf.logs), index, rf.commitedIndex)</span><br><span class=\"line\">\t\tif len(rf.chanNewLog) &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\trf.chanNewLog &lt;- 1</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\trf.persist()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn index, term, isLeader</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>重点处理的地方是nextIndex和MatchIndex 的计算以及维护的问题</p>\n\n        <h4 id=\"Apply的实现\"   >\n          <a href=\"#Apply的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Apply的实现</h4>\n      <p>因为对于外部客户端的行为来说，Start函数是一个异步的函数, 所以实际上客户端是通过等待Make函数中输入的ApplyCh来确定能够apply成功，保证对外的原子性</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) doApply() &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\trf.mu.Lock()</span><br><span class=\"line\">\t\tst :&#x3D; rf.state</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\tif st &#x3D;&#x3D; Killed &#123;</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-rf.chanCommit:</span><br><span class=\"line\">\t\t\tfor &#123;</span><br><span class=\"line\">\t\t\t\trf.mu.Lock()</span><br><span class=\"line\">\t\t\t\tif !(rf.lastApplied &lt; rf.commitedIndex &amp;&amp; rf.lastApplied &lt; rf.logs[rf.getLen()].Index) &#123;</span><br><span class=\"line\">\t\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tFirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\t\t\t\tif rf.lastApplied+1 &gt;&#x3D; FirstIndex &#123;</span><br><span class=\"line\">\t\t\t\t\tindex :&#x3D; min(rf.lastApplied+1-FirstIndex, rf.getLen())</span><br><span class=\"line\">\t\t\t\t\tmsg :&#x3D; ApplyMsg&#123;CommandValid: true, Command: rf.logs[index].Command, CommandIndex: rf.lastApplied + 1&#125;</span><br><span class=\"line\">\t\t\t\t\trf.lastApplied++</span><br><span class=\"line\">\t\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F;can&#39;t lock when send in channel, dead lock</span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F; canApplychan is to block the new</span><br><span class=\"line\">\t\t\t\t\trf.chanCanApply &lt;- 1</span><br><span class=\"line\">\t\t\t\t\trf.chanApplyMsg &lt;- msg</span><br><span class=\"line\">\t\t\t\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\t\t\t\trf.mu.Lock()</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"PartC的实现\"   >\n          <a href=\"#PartC的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PartC的实现</h3>\n      <p>此处首先需要添加状态机的持久化的方法，并且需要在启动的时候添加一个读取旧的持久化状态机的方法。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class=\"line\">\trf.chanCanApply &lt;- 1</span><br><span class=\"line\">\trf.mu.Lock()</span><br><span class=\"line\">\treply.Success &#x3D; false</span><br><span class=\"line\">\tpersistFlag :&#x3D; 0</span><br><span class=\"line\">\tif args.Term &lt; rf.currentTerm &#123;</span><br><span class=\"line\">\t\treply.Term &#x3D; rf.currentTerm</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif rf.currentTerm &lt; args.Term &#123;</span><br><span class=\"line\">\t\trf.currentTerm &#x3D; args.Term</span><br><span class=\"line\">\t\trf.ClearChan()</span><br><span class=\"line\">\t\trf.voteFor &#x3D; -1</span><br><span class=\"line\">\t\trf.state &#x3D; Follower</span><br><span class=\"line\">\t\tpersistFlag &#x3D; 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treply.Term &#x3D; rf.currentTerm</span><br><span class=\"line\">\t&#x2F;&#x2F; similar to appendEntries receive call</span><br><span class=\"line\">\trf.chanAppendEntries &lt;- 1</span><br><span class=\"line\">\tfirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\tnowIndex :&#x3D; args.LastIncludeIndex - firstIndex</span><br><span class=\"line\">\tif nowIndex &lt; 0 &#123;</span><br><span class=\"line\">\t\tif persistFlag &#x3D;&#x3D; 1 &#123;</span><br><span class=\"line\">\t\t\trf.persist()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treply.PrevIndex &#x3D; firstIndex</span><br><span class=\"line\">\t\trf.mu.Unlock()</span><br><span class=\"line\">\t\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trf.logs &#x3D; args.Logs</span><br><span class=\"line\">\trf.lastApplied &#x3D; args.LastIncludeIndex</span><br><span class=\"line\">\trf.commitedIndex &#x3D; args.LeaderCommitIndex</span><br><span class=\"line\">\trf.persister.SaveStateAndSnapshot(rf.getPersistByte(), args.Snapshot)</span><br><span class=\"line\">\tmsg :&#x3D; ApplyMsg&#123;CommandValid: false, Snapshot: args.Snapshot&#125;</span><br><span class=\"line\">\trf.mu.Unlock()</span><br><span class=\"line\">\trf.chanApplyMsg &lt;- msg</span><br><span class=\"line\">\t&lt;-rf.chanCanApply</span><br><span class=\"line\">\treply.Success &#x3D; true</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 启动的时候添加这个方法把Snapshotload出来</span><br><span class=\"line\">rf.readPersist(persister.ReadRaftState())</span><br></pre></td></tr></table></div></figure>\n<p>并且需要注意在投票部分需要根据Safty那里提及的一个重要的地方，如果RequestVote RPC里面的日志Term与目前的Term不是一致的情况下，不能通过数票数的方法来进行计算。这个是为了整个集群的正确来考虑的。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (rf *Raft) updateCommit() &#123;</span><br><span class=\"line\">\tN :&#x3D; rf.commitedIndex</span><br><span class=\"line\">\tFirstIndex :&#x3D; rf.logs[0].Index</span><br><span class=\"line\">\tfor i :&#x3D; max(rf.commitedIndex+1, FirstIndex+1); i &lt;&#x3D; rf.logs[rf.getLen()].Index; i++ &#123;</span><br><span class=\"line\">\t\tnum :&#x3D; 1</span><br><span class=\"line\">\t\tfor j :&#x3D; range rf.peers &#123;</span><br><span class=\"line\">\t\t\tif j !&#x3D; rf.me &#123;</span><br><span class=\"line\">\t\t\t\tif rf.matchIndex[j] &gt;&#x3D; i &#123;</span><br><span class=\"line\">\t\t\t\t\t&#x2F;*</span><br><span class=\"line\">\t\t\t\t\t\tthis part is paper 5.4.2 limit, only can count replicate when log&#39;s term</span><br><span class=\"line\">\t\t\t\t\t\tis equals to currentTerm</span><br><span class=\"line\">\t\t\t\t\t*&#x2F;</span><br><span class=\"line\">\t\t\t\t\tif rf.logs[i-FirstIndex].Term &#x3D;&#x3D; rf.currentTerm &#123;</span><br><span class=\"line\">\t\t\t\t\t\tnum++</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif num &gt; len(rf.peers)&#x2F;2 &#123;</span><br><span class=\"line\">\t\t\tN &#x3D; i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif N &gt; rf.commitedIndex &amp;&amp; rf.state &#x3D;&#x3D; Leader &#123;</span><br><span class=\"line\">\t\trf.commitedIndex &#x3D; min(N, rf.logs[rf.getLen()].Index)</span><br><span class=\"line\">\t\trf.chanCommit &lt;- 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>"},{"title":"分布式系统一致性与共识","date":"2019-08-28T13:08:38.000Z","_content":"\n<!-- ---\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 11:08:38 +0800'\ncategory: \nsummary: Distributed System Consistency and Consensus\nthumbnail: distributed-system.png\n--- -->\n\n# 目录\n1. [分布式系统可以提供的若干保证和抽象机制](#PromiseAbstraction)  \n   1.1 [共识算法的意义](#1.1)  \n2. [如何在分布式系统中做到原子性](#atomic)  \n   2.1 [可线性化](#2.1)  \n   2.2 [顺序化](#2.2)  \n        2.2.1 [顺序、因果、全局序号的关系](#2.2.1)  \n        2.2.2 [全局关系的广播](#2.2.2)  \n3. [分布式系统的能力边界](#Capability)  \n   3.1  [分布式事务](#3.1)  \n   3.2  [容错的共识](#3.2)  \n4. [ShareNote](#ShareNote)  \n\n# <a id=\"PromiseAbstraction\"><span class=\"toptitle\">分布式系统可以提供的若干保证和抽象机制</span></a>\n\n## <a id=\"1.1\"><span class=\"secondtitle\">共识(分布式一致性)算法的意义</span></a>\n对于大多数的多副本的数据库（N>=2)的情况下，它至少达到了最终的一致性。但是因为只是最终，但是到达最终的状态的时间是未知的。  \n最终一致性的多副本数据状态（如Aurora、Riak、Cassandra）的不一致对于应用开发者是比较棘手，因为很多底层保证一致的东西需要挪动到应用层上面去添加规则来继续保证。并且导致测试和验证都会变得异常的困难\n\n基于上面的问题，我们可能需要找到一个更加强一致性的模型来进行构建，可以把应用层可能遇到的数据库不一致的问题封装起来。虽然可能会付出其他的代价（如性能下降、容错性差）\n\n### 与事务隔离的级别的差别\n共识与事务隔离都有类似与副本的概念（事务隔离是使用乐观锁（MVCC） 共识是使用多副本）  \n共识：更加强调是针对延时和故障协调副本之间的关系。  \n事务隔离：处理并发事务的各种临界的条件  \n\n# <a id=\"atomic\"><span class=\"toptitle\">如何在分布式系统中做到原子性</span></a>\n## <a id=\"2.1\"><span class=\"secondtitle\">可线性化</span></a>\n（此部分主要是DDIA第9章节的内容）\n定义： 让一个分布式的系统看起来像一个单副本的系统，并且所有的操作都是原子的。  \n### 一个非线性化的例子\n\n<!-- ![非线性化图片](/assets/img/posts/non-linearized-example.png)   -->\n{% asset_img non-linearized-example.png 非线性化 %}\n\n对于上面这个图的简要描述：  \n因为使用了多节点非强一致性的数据库，当Referee修改数据库的情况下，因为集群内同步的时间不一致，导致可能Alice先查的的Slave-1 已经修改了，但是Bob查询的Slave-2的库上面还没有修改，导致Alice和Bob获取到的结果不一致。这种场景对于一些一致性需求比较强的情况下不能接受。\n\n### <span class=\"thirdtitle\">线性化的例子的直觉表达</span>\n\n<b><font color=\"#FF0000\">线性化的简洁但是事实上的描述： 让分布式系统具有寄存器的语义。</font></b>  \n对于这个部分，我们详细去探讨一下  \n一般我们的对于读写请求并发（在客户端的角度）是这样的:\n定义一个前提， 下图中的一个框是指客户端从发出请求到接收到返回值的整个过程  \n单个框可以理解为 客户端发出请求-> 服务器端接受并且处理请求-> 服务器端返回结果-> 客户端在应用级别收到返回  \n下面可能出现框比较长的情况是在上一篇文章（![分布式系统简介以及其问题](https://ray1888.github.io/distributed-system/2019/08/20/chanllange-of-distributed-system/)）的假设所提及的情况，此处不再复述。  \n\n分布式系统中的寄存器： 线性化数据库中的相同的主键。（此处为X)  \n<!-- ![粗粒度线性一致](/assets/img/posts/generate-line.png)   -->\n{% asset_img generate-line.png 粗粒度线性一致 %}\n此处对于寄存器有两类的操作：\n1. read(x)  读取主键为X的值，数据库返回值v\n2. write(x,v) 客户端把X的值更新为V，数据库返回值为r(成功或者失败)\n\n对于上图在read和write重合的过程中，read的结果可能有2种情况：  \n1. read在write完成之前结束(返回0)  \n2. read在write完成之后结束 (返回1)  \n\n但是这个描述的粒度还是比较大，为了把系统线性化的更好的描述，我们添加下面的约束  \n<!-- ![细粒度线性一致](/assets/img/posts/more-detail-line.png)   -->\n{% asset_img more-detail-line.png 细粒度线性一致 %}\n约束为，在写操作的过程中，肯定有某一个时间点，存储上面的x的值会出现冲0到1的跳变。  \n对于上图， 客户端A在某个节点能够读到X的值为1，那么因为客户端B的读操作是晚于客户端A读的发生的，因此  \n客户端B获取到的值也必然是1（如果不是1，则不是可线性化的系统）。  \n<!-- ![线性一致](/assets/img/posts/line-final.png) -->\n{% asset_img line-final.png 线性一致 %}\n但是上面的讨论颗粒还是太大了，此处我们加入进去存储，以及存储接收到的操作来整体观察线性一致。\n我们此处引入一个概念\n```\nCAS(compare and swap):一个原子的比较设置操作。编程语言中一般都要实现此概念，此处不详细叙述\n```\n并且添加一个假设：即使客户端可能还没有收到成功的响应，但是分布式的存储已经全部同步成新的值。\n上图中每个操作都有竖线，表示可能的执行的时间点，把这些点连接起来，最终结果必须是一个有效的寄存器读写顺序。  \n可线性化的要求： 按时间箭头向前移动，不能向后移动。\n可以看到上图中，最后客户端A的操作在c的Cas操作完成后，x的值已经变成了4，但是如果发现读的值为2的话，按时间线的理解就是错误了。因为根据可线性化的要求，cas操作已经执行了，并且时间只能向前走的情况下，客户端A的读操作必然是需要返回4的。\n\n```\n//可线性化和可串行化的对比\n#### 可线性化\n对寄存器（单个对象）的最新值保证。他不要求将操作组合到事务中，可能会出现写倾斜的问题（如果不采取手段去解决的问题）\n#### 可串行化\n是事务的隔离属性。每个事务可以读写多个对象，用于确保事务执行的结果与串行执行相同。即使穿行执行的顺序和实际执行的顺序并不一定相同（可能实际上的执行是并行执行事务，但是对外暴露的结果是一致的就可以）  \n```\n\n### <span class=\"thirdtitle\">需要用到线性化的使用场景</span>\n1. 加锁与主节点选举\n对于主从复制系统的选主问题，可以通过基于Etcd或者ZooKeeper来进行抢锁操作控制选主\n2. 约束与唯一性保证\n应用中对同一个资源（如用户名）的唯一性的约束。（可以延展到数据表的主键约束）\n3. 多信息源的时间依赖\n对于一些异步任务系统虽然采用了最终一致性，但是可能也是会因为实现产生数据的依赖问题。\n\n### 如何实现一个线性化系统\n#### 对比多种可能使用的方案来确定\n在考虑容错的基础上，必须考虑复制的机制。我们可以对比多种复制方案来看看那种可以实现线性化\n1. 主从复制。（部分线性化）\n因为所有写入操作都是从主节点继续，并且把操作同步到从节点上面。但是问题可能出现在实现的问题上：  \n    1. 实时同步可能会出现问题\n    2. 可能会因为快照隔离设计出现问题\n2. 共识算法（可线性化）\n类似于主从复制，但是通过一些手段来防止脑裂和过期的副本\n3. 多主复制（不可线性化）\n当允许并发写入的时候，如果进行异步复制的话，可能会出现数据的冲突。\n4. 无主复制（可能不可线性化）\n类似于Dynamo的机制，即使使用了Quroum机制，但是如果选取的Quroum不一定是满足的情况下，可能会出现非线性化的处理\n\n此处提出一个问题，是否只要有Quroum机制（就必定可以支持线性一致呢？）  \n答： 不一定。用下面的例子进行解释  \n\n<!-- ![QuroumFail](/assets/img/posts/quroum-fail.png)   -->\n{% asset_img quroum-fail.png QuroumFail %}\n\n对于上图中，即使是使用了Quroum，但是没有共识算法的支持，还是可能会出现类似于之前Alice和Bob遇到的情况的问题。但是这个选取的直接是一个Quroum，但是是因为缺少共识，并且网络出现问题才会导致这样的情况出现。\n\n### 线性化的代价\n\n<font color=\"#FF0000\">线性化出现代价的最主要的原因还是因为网络的不确定性。</font>\n\n我们先用主从的架构来讨论这个问题，当网络发生分区的情况，主从不能够继续同步操作，可能会导致从库不可用。\n但是这个是我们需要实现线性化所带来的不可用\n\n先引入一个概念：CAP理论\n```\nCAP : 在同一个时间内，当网络出现分区的情况下，不可能获得兼容可用性和一致性。\n```\nCAP理论的推理：不要求线性化的应用更能够容忍网络分区。\n\n但是为了线性化，我们可能要牺牲性能和延迟。\n那么我们是否有方法可以做到线性化但是减少性能的牺牲呢？\n\n## <a id=\"2.2\"><span class=\"secondtitle\">顺序保证</span></a>\n我们刚刚在讨论线性化的时候使用到了寄存器的概念，那么顺序、可线性化、共识之间是否存在的某种关系呢？\n\n### <a id=\"2.2.1\"><span class=\"thirdtitle\">顺序、因果、全局序号的关系</span>\n#### <span class=\"fourth\">顺序和因果的关系</span>\n\n因果关系对所发生的事件添加了排序， 一件事情会导致另外一件事情，这些的因果关系依赖链条定义了系统中的因果顺序。如果符合因果关系所规定的顺序，我们称之为因果一致性。（快照隔离，在从数据库中读数据的情况下，查询到的诗句，也可以查到这个数据之前发生了什么的操作事件）\n\n#### <span class=\"fourth\">因果顺序并非全序</span>\n\n全序关系是可以支持两个不同的实体直接进行比较（如自然数集5和13的比较）  \n但是部分集合的对比不一定符合全序，集合{a,b} 与 集合{b,c}是无法进行对比的  \n\n因此，提炼到可线性化和因果关系中  \n可线性化是存在全序的操作关系，因为暴露对外的行为是与单副本无异，并且每个操作都是原子的。可以分出先后  \n因果是偏序的操作关系，对于并发的两个操作无法比较的情况下，就会发生冲突，对于可以比较的情况下，与线性无异。    \n那么可以这样说，可线性化一定意味着因果关系，因为可线性化是全序的操作。    \n但是可以这样理解，线性化并非是保证因果关系的唯一的途径。我们可以有其他手段去满足因果一致性而避免线性化所带来的问题。    \n因果一致性是被认为是不会由于网络延迟而显著影响性能，并且可以对网络故障容错提供容错的最强一致性的模型。  \n因为实际上很多的应用所需要的是因果一致性来保证应用的正确性。  \n\n#### <span class=\"fourth\">捕获因果依赖关系</span>\n如果只要解决并发操作的先后依赖关系。这里其实只需要由偏序的关系即可。\n我们常见的数据库的版本技术就是一个解决这个问题的方案之一\n为了确定数据库的因果关系，数据库需要知道应用读取的是哪个版本的数据。\n\n#### <span class=\"fourth\">序列号排序</span>\n那么，这样的情况下，我们是否需要显式的跟踪所有的因果关系呢？  \n为了性能的考虑，我们可以通过序列号和时间戳（尽量不使用物理时钟）来进行对事件排序，这样在保证性能的同时，也能够保证所有操作在全局的关系。但是要保证每个序列号必须唯一，并且可以比较。  \n我们可以按照与因果关系一致的顺序来创建序列号： 如果操作A发生B之前，那么A一定在全序顺序中出现在B之前    \n这样的全局排序可以捕获所有的因果信息，并且加强了比因果关系更为严格的顺序性  \n\n那么对于不存在唯一的主节点（多主或者无主），那么我们能怎样生成上面所提及的序列号呢？  \n有实践中可以采用以下方法：  \n    1. 每个节点单独生成自己的一组序列号。假设有两个节点，一个生成奇数，一个生成偶数  \n    2. 把Timestamp添加到操作中（之前生产中有用此种方式）  \n    3. 预先分配序列号的区间范围。（A节点分配1-1000，B节点分配1001-2000）  \n\n但是这三种实际上生成的唯一的，近似增加的序列号。但是实际上序列号和因果一致不是完全因果一致的。  \n为什么不是因果一致呢?  \n对于情况1，每个节点处理的速率是由不一致的，只要两个节点处于处理速率不一致的情况下，分配的ID必然和实际的顺序关系无法对应  \n对于情况2， 墙上时钟发生偏移的情况  \n对于情况3， 如果sharding的路由发生了变化之后，那么之前1-1000的因果关系就不存在了。  \n\n那么我们是否没有办法可以在非强主的情况可以获取一个序列号与因果一致可以对应上的吗？  \n\n我们还有一个方法！！！此处大神来了Leslie Lamport的Lamport TimeStamp可以解决这个问题  \n\n#### <span class=\"fourth\">LamportTimeStamp</span>\n<!-- ![LamportTimeStamp](/assets/img/posts/LamportTimestamp.png)   -->\n{% asset_img LamportTimestamp.png LamportTimeStamp %}\n每个节点一开始的时候都会有一个唯一的标识符（每次初始为0）， 然后每个节点都有一个计数器来记录各自处理的请求总数。到此与之前的时间戳的并无差别，但是Lamport这里处理的亮点出来了，每个节点和每个客户端都会跟踪迄今为止最大的计数器值，并且在每个请求中附带该最大计数器值。当节点收到某个请求的时候，如果发现请求内的最大计数器值大于自身的计数器值，会更新自己的计数器值（Raft中是通过投票和心跳的RPC来同步这个计数器的值，在Raft的概念里面叫做Term，后面讲解Raft的时候会进一步解析，此处只是一个插叙）。\n\nLamportTimeStamp好像是解决了分布式系统顺序号和因果一致的关系，但是是已经足够解决分布式系统中常见的问题了吗？  \n问题如下：  \n    一个系统的用户名只能由唯一的用户持有，两个用户并发地向系统同时进行注册，我们必须要保证一个成功，一个失败    \n虽然看上去我们是可以把两个请求通过编号把两个并发的请求变成了一个有顺序的问题，但是实际上要保证上面的是唯一的有两个前提：  \n    1. 节点收到用户请求的时候需要马上判断请求时成功还是失败  \n    2. 必须要收集系统的所有创建用户的请求，比较序号  \n但是这个显然是不可能的，只要网络出现问题了，我们就无法做到上面的两个问题。\n\n那么我们如果要知道全局关系是否确定，就需要提到后面的一个概念，全序关系广播\n\n### <a id=\"2.2.2\"><span class=\"thirdtitle\">全局关系的广播</span></a>\n继续先从一个主从复制的系统开始说起，主节点接受写请求并且变成顺序的操作。  \n但是在分布式系统领域，如何扩展系统的吞吐量使之突破单一主节点限制以及处理主节点失效时的故障切换。这类的问题被称为全序关系广播或者原子广播。  \n全序关系广播： 通常指节点之间交换信息的某种协议。有两个特性  \n    1. 可靠发送（没有消息丢失，如果消息发送到某一个节点，它一定要发送到其他的节点）  \n    2. 严格有序（消息总是以相同的顺序发送到每个节点）  \n\n#### <span class=\"fourth\">使用全序关系广播</span>\nZookeeper和Etcd的共识服务就实现了全序关系广播。（那么全序关系广播和共识之间的关系？）  \n\n全序关系广播就是数据库所需要，每条消息表达数据库的写请求，而且每个副本段相同的顺序处理这些写请求，那么所有副本可以保持一致。这个也被称为状态机复制。  \n\n全局关系广播的另一个要点，顺序在发送消息时已经是确定的，如果消息发送成功，节点不允许追溯将某条消息插到先前的位置上。只能进行追加，这样全序关系广播比时间戳的排序要求更强  \n应用场景：  \n    1.我们可以使用全序关系广播来实现可串行化的事务。（每个消息表示为一个确定性质的事务，并且作为存储过程来执行）    \n    2.提供Fencing令牌锁的服务（把取锁的请求变成一个消息追加到日志中，序列号直接可以变成令牌返回）  \n\n#### 全序关系广播来实现线性化存储\n全序关系广播是基于异步模型，保证消息以固定顺序的可靠发送，但是不保证消息何时发送成功，但是可线性化更多地强调读取时能看到最新的写入值。  \n我们可以通过追加的日志的方式使得使用全序关系广播在写入的方式上与可线性化做到一致  \n    1. 在接受请求的本地节点中追加一条消息，指明写入的信息  \n    2. 读取日志，广播到其他节点，等待回应  \n    3. 如果回复中有冲突，则失败，返回错误给客户端；否则返回成功给客户端  \n通过日志追加可以把并发有效的转换为多条的日志来保证因果顺序关系。但是读取却还没做到这个语义  \n为了读取可以与可线性化一致，有以下方法可以解决这个问题：\n    1. 把读的请求也变成日志的方式追加到排序广播，通过变成日志的情况下可以确定了顺序的问题。（ETCD采用的是这种方式）  \n    2. 如果可以以可线性化的方式获取最新日志的消息位置，则查询位置，直到该位置之前的所有条目读发送给你，再进行读取（ZooKeeper使用的方式）  \n    3. 可以从同步更新的副本中进行读取，保证每次读的是最新的值。  \n\n所以最终可线性化的原子地对寄存器做CAS的操作与全序关系广播其实等价于共识的问题。\n\n# <a id=\"Capability\"><span class=\"toptitle\">分布式共识的能力边界</span></a>\n共识： 使得分布式系统中就某件事情达成一致  \n共识的使用场景：  \n    1. 主节点选举（防止脑裂问题）  \n    2. 原子事务的提交（跨节点或分区的数据库，事务在部分节点成功，部分节点失败，需要进行回滚）  \n我们先从事务的原子性开始，讨论2PC（2阶段提交），之后再会谈及其他更好的共识算法的实现（ZooKeeper， Raft）  \n\n## <a id=\"3.1\"><span class=\"secondtitle\">分布式事务 </span></a>\n事务原子性的目的：  \n一个多笔写操作的事务在执行过程中出现意外情况，为上层应用提供一个简单的语义，全部成功或者全部失败  \n单机原子提交：  \n数据库把事务写入持久化部分，然后把提交记录追加写入到磁盘的日志文件中。所以在单节点上面，事务提交非常依赖与数据持久写入磁盘的顺序关系  \n    1. 先写入数据，再提交记录  \n    2. 事务提交或者中止的关键点在于磁盘完成日志的时候，在完成写之前崩溃的情况下，事务需要中止；如果日志在完成写入后发生崩溃，事务被安全提交  \n\n但是对于分布式多节点，处理方法有所差别，原因可能是以下这几个问题引起的  \n    1. 某些节点发现不满足要求中止了事务，但是部分节点通过并且提交    \n    2. 部分请求可能在网络不稳定的情况下丢失，超时而中止；但是其他请求可能成功提交  \n    3. 节点可能在写入日志前崩溃，而且在恢复后回滚（原来数据没有成功，回滚可能会出现问题）  \n如果一部分节点提交了事务，但是部分节点放弃了事务，会导致集群中节点信息的不一致，而且事务一旦被提交，即使事后发现其他节点中止，也无法撤销本节点的事务  \n\n事务提交后不能撤销的原因：   \n一旦数据提交，就会被其他事务可见，然后客户端（应用层）就会做出相应的反应，这个是构成读-提交隔离的基础。但是如果允许撤销的话，那么所有之后的读-提交级别的任务，然后会产生多级的级联式追溯和撤销。导致系统压力巨大甚至崩溃。并且不能保证数据是否能够准确落盘。  \n\n因为不允许撤销事务，因为如果一个错误的事务被提交了，必然需要一个新的事务来抵消它的影响，但是这个需要应用层来进行处理，就不符合我们需要给应用层提供的原子性。  \n\n### 2PC \n两阶段提交（2PC）是一种在多个节点上实现事务原子提交的算法。要么全部提交，要么全部不提交。\n\n##### 2PC的流程（为什么可以解决上面单阶段提交的问题）\n1. 应用启动分布式事务的时候，先去像协调者获取事务ID（全局唯一）\n2. 应用程序在每个参与的节点启动单节点事务，并且把事务ID附加到到参与者的事务上。如果这个阶段发生异常，可以协调者和其他参与者可以安全中止\n3. 应用程序准备提交事务时，协调者回向参与者发送携带事务ID准备请求，只要有一个发现失败的情况下，通知全部放弃事务\n4. 参与者收到请求后，确保自己时候可以提交事务（包括硬件故障和软件故障的确认），然后检查是否有冲突或者违规。一旦返回是，节点会承诺提交事务。（保证了参与者不会撤销事务）\n5. 当协调者收到所有的参与者返回后，要决定是否提交事务，并且把此决定写入到硬盘的事务日志（WAL）中，防止掉电后可能出现的异常\n6. 协调者向参与者发送提交/放弃 事物的请求，只要是提交，每个参与者会重试到成功为止(包括了进程崩溃的重试、节点重启等情况)\n\n所以他是在保证了上面的一个重要前提，只要提交了就不能撤回。\n在参与者在返回给协调者的时候保证了单向性\n并且协调者确定提交了之后也是保证了不可逆，因此保证了2pc可以不会出现那些异常的情况。\n\n但是2PC的单点在于协调者的问题（虽然可以采用共识层来写协调者保证高可用）但是整个过程中的热点也会出现在协调者上面。\n\n### 实际生产上面的分布式事务\n### 异构分布式事务\n虽然分布式事务因为这样可能会有阻塞而导致性能和吞吐量的下降，但是是否没有折中的方法来使用类似的语义呢？\n目前更多的是采用了异构的方法（如数据库+MQ）的执行异构的分布式事务\n\n对于异构形式的分布式事务，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息处理完毕。\n但只要其中一个出现失败的情况，两个部分都必须进行中止的操作。\n\n<b>保证消息可以有效处理有且仅有一次</b>\n\n目前有XA的异构的分布式事务的标准。\n\n## <a id=\"3.2\"><span class=\"secondtitle\">支持容错的共识</span></a>\n共识问题的形式化描述： 一个或者多个节点可以提议某些值，由共识算法来决定最终的值。\n\n基于上面的描述共识算法必须满足以下的性质：\n    1. 协商一致性（所有节点都接受相同的决议）\n    2. 诚实性（所有节点不能反悔，对某项提议不能有两次决定）\n    3. 合法性（决定了值V, 那么V肯定是由某个节点提议的）\n    4. 可终止性（如果节点不崩溃最终一定可以达成协议）\n\n协商一致性和诚实的属性定义了共识算法的核心思想：决定一致的结果，并且一旦决定就不能改变。  \n合法性是为了排除一些无意义的方案，  \n可终止性是容错的体现，避免了整个系统的空转  \n根据之前提及的： 可终止性是活性， 其他三个是安全方面的属性。\n\n因为共识算法的目的是解决在大多数节点正常的情况下正确运行才能确保终止性。\n\n### 共识算法和全序广播的关系\n\n共识算法(如Raft、Paxos、Zab)等都不是直接采用上述的形式化模型。而是决定了一系列的值，然后采用全序关系广播算法来进行实现。  \n\n全序关系广播要点： 消息按相同的顺序发送到所有的节点，有且只有一次。  \n这样的方式相当于多轮的共识过程。在每一轮，节点会提出之后需要发出的信息，然后决定下一个顺序。\n\n对于上面的提到的四个性质：\n1. 由于协商的一致性，所有节点决定以相同的顺序发送相同的消息。\n2. 由于诚实性，消息不会重复\n3. 由于合法性， 消息不会被破坏，也不是凭空捏造\n4. 由于可终止性，消息不会丢失\n\n### Epoch 和 Quorum\n\n对于共识算法来说，都采用了一个弱化的保证，定义了一个世代编号（Epoch）来确保每个世代里面，主节点是唯一的。\n如果发现当前主节点失效的情况，节点开始选举新一轮的主节点，Epoch号递增。在主节点做出任何决定的时候，都需要检查是否由比它更高的Epoch号码。\n主节点必须从Quorum中收集投票，并且把提议传送到各个节点中，等待节点的返回，当只要没有更高的Epoch主节点\n时，才会对当前的提议进行投票。\n\n此处其实是由两个操作组成：1. 选举主节点； 2.对主节点的提议进行投票\n\n注意的一点： 参与两轮的Quorum必须要由重合，这样才能保证主节点没有更高的Epoch，保证正确性。\n\n与2PC的差别， 2PC是需要协调者向每个参与者做出“是”的返回才能进行，而共识算法可以通过直接以集群的多数来确定是否通过决议\n\n### 共识算法的局限性\n\n共识算法虽然为分布式系统带来了好处，为一切不确定的系统带来了安全属性和容错性。并且可以通过全序关系广播以容错的方式实现线性化的原子操作。\n\n但是共识也是有代价的：\n1. 节点投票是一个同步复制过程，性能可能需要妥协（但是可以通过减少选举的频率来减少整个开销）\n2. 共识体系需要严格的多数节点才能执行，换句话来说，最少需要3个节点才能运行\n3. 多数的共识算法假定了一组固定的参与投票的节点集（主要是为了理解的方便）\n4. 共识算法需要依靠超时来对节点失败进行检测，但是可能会出现因为网络原因的误判导致经常切主，数据搬移多，对外的性能降低。\n5. 网络的影响较大，如果出现频繁切主的情况，可能会有长时间出现无法正常对外进行服务\n\n### 基于共识算法的成员与协调服务\n\n对于像ZooKeeper、Etcd这些分布式键值对的服务，暴露的API与数据库是十分类似的，但是为什么我们需要在共识层上面去构建这些服务呢？\n\n#### 作用\n这些分布式键值对数据库主要是针对保存少量，可完全载入内存的数据。采用容错的全序广播算法在所有节点上复制数据使得可以实现高可用的目标。\n1. 线性化的原子操作\n多个节点同时去获取锁，只有一个会成功，共识协议会保证操作满足原子性和线性化，即使节点出现部分失败的情况\n2. 操作全序\n之前分布式系统问题的文章有提及过Fencing令牌的问题，\n3. 故障检测\n客户端会与这些服务保持一个长连接，如果长时间重连失败的情况下，会把该客户端拥有的资源全部释放\n4. 更改通知\n客户端可以通过读取服务来发现其他的客户端的行为\n\n#### 对外的功能\n1. 节点任务分配\n计算作业调度系统(Yarn)，分区资源调度（如Multi-Raft中的ShardMaster)\n2. 服务发现\n解决云环境中服务启停而注册到的服务变更(consul提供的服务)\n3. 成员服务\n节点是否可用并且获取主节点\n\n### 如何验证一个线性化系统\n（此部分会结合Mit6.824和PingCap tikv 的线性化验证的代码阅读和文章来描述）\n\n\n# <a id=\"ShareNote\">ShareNote</a>\n1. [Dynamo](https://pdos.csail.mit.edu/6.824/papers/dynamo.pdf)\n2. [Riak](https://github.com/basho/riak_core)\n3. [Cassandra](http://cassandra.apache.org/)\n4. [数据密集型应用系统设计](https://book.douban.com/subject/30329536/)","source":"_posts/distribute-system-consensus.md","raw":"---\ntitle: 分布式系统一致性与共识\ndate: 2019-08-28 21:08:38\ntags: distributed-system\n---\n\n<!-- ---\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 11:08:38 +0800'\ncategory: \nsummary: Distributed System Consistency and Consensus\nthumbnail: distributed-system.png\n--- -->\n\n# 目录\n1. [分布式系统可以提供的若干保证和抽象机制](#PromiseAbstraction)  \n   1.1 [共识算法的意义](#1.1)  \n2. [如何在分布式系统中做到原子性](#atomic)  \n   2.1 [可线性化](#2.1)  \n   2.2 [顺序化](#2.2)  \n        2.2.1 [顺序、因果、全局序号的关系](#2.2.1)  \n        2.2.2 [全局关系的广播](#2.2.2)  \n3. [分布式系统的能力边界](#Capability)  \n   3.1  [分布式事务](#3.1)  \n   3.2  [容错的共识](#3.2)  \n4. [ShareNote](#ShareNote)  \n\n# <a id=\"PromiseAbstraction\"><span class=\"toptitle\">分布式系统可以提供的若干保证和抽象机制</span></a>\n\n## <a id=\"1.1\"><span class=\"secondtitle\">共识(分布式一致性)算法的意义</span></a>\n对于大多数的多副本的数据库（N>=2)的情况下，它至少达到了最终的一致性。但是因为只是最终，但是到达最终的状态的时间是未知的。  \n最终一致性的多副本数据状态（如Aurora、Riak、Cassandra）的不一致对于应用开发者是比较棘手，因为很多底层保证一致的东西需要挪动到应用层上面去添加规则来继续保证。并且导致测试和验证都会变得异常的困难\n\n基于上面的问题，我们可能需要找到一个更加强一致性的模型来进行构建，可以把应用层可能遇到的数据库不一致的问题封装起来。虽然可能会付出其他的代价（如性能下降、容错性差）\n\n### 与事务隔离的级别的差别\n共识与事务隔离都有类似与副本的概念（事务隔离是使用乐观锁（MVCC） 共识是使用多副本）  \n共识：更加强调是针对延时和故障协调副本之间的关系。  \n事务隔离：处理并发事务的各种临界的条件  \n\n# <a id=\"atomic\"><span class=\"toptitle\">如何在分布式系统中做到原子性</span></a>\n## <a id=\"2.1\"><span class=\"secondtitle\">可线性化</span></a>\n（此部分主要是DDIA第9章节的内容）\n定义： 让一个分布式的系统看起来像一个单副本的系统，并且所有的操作都是原子的。  \n### 一个非线性化的例子\n\n<!-- ![非线性化图片](/assets/img/posts/non-linearized-example.png)   -->\n{% asset_img non-linearized-example.png 非线性化 %}\n\n对于上面这个图的简要描述：  \n因为使用了多节点非强一致性的数据库，当Referee修改数据库的情况下，因为集群内同步的时间不一致，导致可能Alice先查的的Slave-1 已经修改了，但是Bob查询的Slave-2的库上面还没有修改，导致Alice和Bob获取到的结果不一致。这种场景对于一些一致性需求比较强的情况下不能接受。\n\n### <span class=\"thirdtitle\">线性化的例子的直觉表达</span>\n\n<b><font color=\"#FF0000\">线性化的简洁但是事实上的描述： 让分布式系统具有寄存器的语义。</font></b>  \n对于这个部分，我们详细去探讨一下  \n一般我们的对于读写请求并发（在客户端的角度）是这样的:\n定义一个前提， 下图中的一个框是指客户端从发出请求到接收到返回值的整个过程  \n单个框可以理解为 客户端发出请求-> 服务器端接受并且处理请求-> 服务器端返回结果-> 客户端在应用级别收到返回  \n下面可能出现框比较长的情况是在上一篇文章（![分布式系统简介以及其问题](https://ray1888.github.io/distributed-system/2019/08/20/chanllange-of-distributed-system/)）的假设所提及的情况，此处不再复述。  \n\n分布式系统中的寄存器： 线性化数据库中的相同的主键。（此处为X)  \n<!-- ![粗粒度线性一致](/assets/img/posts/generate-line.png)   -->\n{% asset_img generate-line.png 粗粒度线性一致 %}\n此处对于寄存器有两类的操作：\n1. read(x)  读取主键为X的值，数据库返回值v\n2. write(x,v) 客户端把X的值更新为V，数据库返回值为r(成功或者失败)\n\n对于上图在read和write重合的过程中，read的结果可能有2种情况：  \n1. read在write完成之前结束(返回0)  \n2. read在write完成之后结束 (返回1)  \n\n但是这个描述的粒度还是比较大，为了把系统线性化的更好的描述，我们添加下面的约束  \n<!-- ![细粒度线性一致](/assets/img/posts/more-detail-line.png)   -->\n{% asset_img more-detail-line.png 细粒度线性一致 %}\n约束为，在写操作的过程中，肯定有某一个时间点，存储上面的x的值会出现冲0到1的跳变。  \n对于上图， 客户端A在某个节点能够读到X的值为1，那么因为客户端B的读操作是晚于客户端A读的发生的，因此  \n客户端B获取到的值也必然是1（如果不是1，则不是可线性化的系统）。  \n<!-- ![线性一致](/assets/img/posts/line-final.png) -->\n{% asset_img line-final.png 线性一致 %}\n但是上面的讨论颗粒还是太大了，此处我们加入进去存储，以及存储接收到的操作来整体观察线性一致。\n我们此处引入一个概念\n```\nCAS(compare and swap):一个原子的比较设置操作。编程语言中一般都要实现此概念，此处不详细叙述\n```\n并且添加一个假设：即使客户端可能还没有收到成功的响应，但是分布式的存储已经全部同步成新的值。\n上图中每个操作都有竖线，表示可能的执行的时间点，把这些点连接起来，最终结果必须是一个有效的寄存器读写顺序。  \n可线性化的要求： 按时间箭头向前移动，不能向后移动。\n可以看到上图中，最后客户端A的操作在c的Cas操作完成后，x的值已经变成了4，但是如果发现读的值为2的话，按时间线的理解就是错误了。因为根据可线性化的要求，cas操作已经执行了，并且时间只能向前走的情况下，客户端A的读操作必然是需要返回4的。\n\n```\n//可线性化和可串行化的对比\n#### 可线性化\n对寄存器（单个对象）的最新值保证。他不要求将操作组合到事务中，可能会出现写倾斜的问题（如果不采取手段去解决的问题）\n#### 可串行化\n是事务的隔离属性。每个事务可以读写多个对象，用于确保事务执行的结果与串行执行相同。即使穿行执行的顺序和实际执行的顺序并不一定相同（可能实际上的执行是并行执行事务，但是对外暴露的结果是一致的就可以）  \n```\n\n### <span class=\"thirdtitle\">需要用到线性化的使用场景</span>\n1. 加锁与主节点选举\n对于主从复制系统的选主问题，可以通过基于Etcd或者ZooKeeper来进行抢锁操作控制选主\n2. 约束与唯一性保证\n应用中对同一个资源（如用户名）的唯一性的约束。（可以延展到数据表的主键约束）\n3. 多信息源的时间依赖\n对于一些异步任务系统虽然采用了最终一致性，但是可能也是会因为实现产生数据的依赖问题。\n\n### 如何实现一个线性化系统\n#### 对比多种可能使用的方案来确定\n在考虑容错的基础上，必须考虑复制的机制。我们可以对比多种复制方案来看看那种可以实现线性化\n1. 主从复制。（部分线性化）\n因为所有写入操作都是从主节点继续，并且把操作同步到从节点上面。但是问题可能出现在实现的问题上：  \n    1. 实时同步可能会出现问题\n    2. 可能会因为快照隔离设计出现问题\n2. 共识算法（可线性化）\n类似于主从复制，但是通过一些手段来防止脑裂和过期的副本\n3. 多主复制（不可线性化）\n当允许并发写入的时候，如果进行异步复制的话，可能会出现数据的冲突。\n4. 无主复制（可能不可线性化）\n类似于Dynamo的机制，即使使用了Quroum机制，但是如果选取的Quroum不一定是满足的情况下，可能会出现非线性化的处理\n\n此处提出一个问题，是否只要有Quroum机制（就必定可以支持线性一致呢？）  \n答： 不一定。用下面的例子进行解释  \n\n<!-- ![QuroumFail](/assets/img/posts/quroum-fail.png)   -->\n{% asset_img quroum-fail.png QuroumFail %}\n\n对于上图中，即使是使用了Quroum，但是没有共识算法的支持，还是可能会出现类似于之前Alice和Bob遇到的情况的问题。但是这个选取的直接是一个Quroum，但是是因为缺少共识，并且网络出现问题才会导致这样的情况出现。\n\n### 线性化的代价\n\n<font color=\"#FF0000\">线性化出现代价的最主要的原因还是因为网络的不确定性。</font>\n\n我们先用主从的架构来讨论这个问题，当网络发生分区的情况，主从不能够继续同步操作，可能会导致从库不可用。\n但是这个是我们需要实现线性化所带来的不可用\n\n先引入一个概念：CAP理论\n```\nCAP : 在同一个时间内，当网络出现分区的情况下，不可能获得兼容可用性和一致性。\n```\nCAP理论的推理：不要求线性化的应用更能够容忍网络分区。\n\n但是为了线性化，我们可能要牺牲性能和延迟。\n那么我们是否有方法可以做到线性化但是减少性能的牺牲呢？\n\n## <a id=\"2.2\"><span class=\"secondtitle\">顺序保证</span></a>\n我们刚刚在讨论线性化的时候使用到了寄存器的概念，那么顺序、可线性化、共识之间是否存在的某种关系呢？\n\n### <a id=\"2.2.1\"><span class=\"thirdtitle\">顺序、因果、全局序号的关系</span>\n#### <span class=\"fourth\">顺序和因果的关系</span>\n\n因果关系对所发生的事件添加了排序， 一件事情会导致另外一件事情，这些的因果关系依赖链条定义了系统中的因果顺序。如果符合因果关系所规定的顺序，我们称之为因果一致性。（快照隔离，在从数据库中读数据的情况下，查询到的诗句，也可以查到这个数据之前发生了什么的操作事件）\n\n#### <span class=\"fourth\">因果顺序并非全序</span>\n\n全序关系是可以支持两个不同的实体直接进行比较（如自然数集5和13的比较）  \n但是部分集合的对比不一定符合全序，集合{a,b} 与 集合{b,c}是无法进行对比的  \n\n因此，提炼到可线性化和因果关系中  \n可线性化是存在全序的操作关系，因为暴露对外的行为是与单副本无异，并且每个操作都是原子的。可以分出先后  \n因果是偏序的操作关系，对于并发的两个操作无法比较的情况下，就会发生冲突，对于可以比较的情况下，与线性无异。    \n那么可以这样说，可线性化一定意味着因果关系，因为可线性化是全序的操作。    \n但是可以这样理解，线性化并非是保证因果关系的唯一的途径。我们可以有其他手段去满足因果一致性而避免线性化所带来的问题。    \n因果一致性是被认为是不会由于网络延迟而显著影响性能，并且可以对网络故障容错提供容错的最强一致性的模型。  \n因为实际上很多的应用所需要的是因果一致性来保证应用的正确性。  \n\n#### <span class=\"fourth\">捕获因果依赖关系</span>\n如果只要解决并发操作的先后依赖关系。这里其实只需要由偏序的关系即可。\n我们常见的数据库的版本技术就是一个解决这个问题的方案之一\n为了确定数据库的因果关系，数据库需要知道应用读取的是哪个版本的数据。\n\n#### <span class=\"fourth\">序列号排序</span>\n那么，这样的情况下，我们是否需要显式的跟踪所有的因果关系呢？  \n为了性能的考虑，我们可以通过序列号和时间戳（尽量不使用物理时钟）来进行对事件排序，这样在保证性能的同时，也能够保证所有操作在全局的关系。但是要保证每个序列号必须唯一，并且可以比较。  \n我们可以按照与因果关系一致的顺序来创建序列号： 如果操作A发生B之前，那么A一定在全序顺序中出现在B之前    \n这样的全局排序可以捕获所有的因果信息，并且加强了比因果关系更为严格的顺序性  \n\n那么对于不存在唯一的主节点（多主或者无主），那么我们能怎样生成上面所提及的序列号呢？  \n有实践中可以采用以下方法：  \n    1. 每个节点单独生成自己的一组序列号。假设有两个节点，一个生成奇数，一个生成偶数  \n    2. 把Timestamp添加到操作中（之前生产中有用此种方式）  \n    3. 预先分配序列号的区间范围。（A节点分配1-1000，B节点分配1001-2000）  \n\n但是这三种实际上生成的唯一的，近似增加的序列号。但是实际上序列号和因果一致不是完全因果一致的。  \n为什么不是因果一致呢?  \n对于情况1，每个节点处理的速率是由不一致的，只要两个节点处于处理速率不一致的情况下，分配的ID必然和实际的顺序关系无法对应  \n对于情况2， 墙上时钟发生偏移的情况  \n对于情况3， 如果sharding的路由发生了变化之后，那么之前1-1000的因果关系就不存在了。  \n\n那么我们是否没有办法可以在非强主的情况可以获取一个序列号与因果一致可以对应上的吗？  \n\n我们还有一个方法！！！此处大神来了Leslie Lamport的Lamport TimeStamp可以解决这个问题  \n\n#### <span class=\"fourth\">LamportTimeStamp</span>\n<!-- ![LamportTimeStamp](/assets/img/posts/LamportTimestamp.png)   -->\n{% asset_img LamportTimestamp.png LamportTimeStamp %}\n每个节点一开始的时候都会有一个唯一的标识符（每次初始为0）， 然后每个节点都有一个计数器来记录各自处理的请求总数。到此与之前的时间戳的并无差别，但是Lamport这里处理的亮点出来了，每个节点和每个客户端都会跟踪迄今为止最大的计数器值，并且在每个请求中附带该最大计数器值。当节点收到某个请求的时候，如果发现请求内的最大计数器值大于自身的计数器值，会更新自己的计数器值（Raft中是通过投票和心跳的RPC来同步这个计数器的值，在Raft的概念里面叫做Term，后面讲解Raft的时候会进一步解析，此处只是一个插叙）。\n\nLamportTimeStamp好像是解决了分布式系统顺序号和因果一致的关系，但是是已经足够解决分布式系统中常见的问题了吗？  \n问题如下：  \n    一个系统的用户名只能由唯一的用户持有，两个用户并发地向系统同时进行注册，我们必须要保证一个成功，一个失败    \n虽然看上去我们是可以把两个请求通过编号把两个并发的请求变成了一个有顺序的问题，但是实际上要保证上面的是唯一的有两个前提：  \n    1. 节点收到用户请求的时候需要马上判断请求时成功还是失败  \n    2. 必须要收集系统的所有创建用户的请求，比较序号  \n但是这个显然是不可能的，只要网络出现问题了，我们就无法做到上面的两个问题。\n\n那么我们如果要知道全局关系是否确定，就需要提到后面的一个概念，全序关系广播\n\n### <a id=\"2.2.2\"><span class=\"thirdtitle\">全局关系的广播</span></a>\n继续先从一个主从复制的系统开始说起，主节点接受写请求并且变成顺序的操作。  \n但是在分布式系统领域，如何扩展系统的吞吐量使之突破单一主节点限制以及处理主节点失效时的故障切换。这类的问题被称为全序关系广播或者原子广播。  \n全序关系广播： 通常指节点之间交换信息的某种协议。有两个特性  \n    1. 可靠发送（没有消息丢失，如果消息发送到某一个节点，它一定要发送到其他的节点）  \n    2. 严格有序（消息总是以相同的顺序发送到每个节点）  \n\n#### <span class=\"fourth\">使用全序关系广播</span>\nZookeeper和Etcd的共识服务就实现了全序关系广播。（那么全序关系广播和共识之间的关系？）  \n\n全序关系广播就是数据库所需要，每条消息表达数据库的写请求，而且每个副本段相同的顺序处理这些写请求，那么所有副本可以保持一致。这个也被称为状态机复制。  \n\n全局关系广播的另一个要点，顺序在发送消息时已经是确定的，如果消息发送成功，节点不允许追溯将某条消息插到先前的位置上。只能进行追加，这样全序关系广播比时间戳的排序要求更强  \n应用场景：  \n    1.我们可以使用全序关系广播来实现可串行化的事务。（每个消息表示为一个确定性质的事务，并且作为存储过程来执行）    \n    2.提供Fencing令牌锁的服务（把取锁的请求变成一个消息追加到日志中，序列号直接可以变成令牌返回）  \n\n#### 全序关系广播来实现线性化存储\n全序关系广播是基于异步模型，保证消息以固定顺序的可靠发送，但是不保证消息何时发送成功，但是可线性化更多地强调读取时能看到最新的写入值。  \n我们可以通过追加的日志的方式使得使用全序关系广播在写入的方式上与可线性化做到一致  \n    1. 在接受请求的本地节点中追加一条消息，指明写入的信息  \n    2. 读取日志，广播到其他节点，等待回应  \n    3. 如果回复中有冲突，则失败，返回错误给客户端；否则返回成功给客户端  \n通过日志追加可以把并发有效的转换为多条的日志来保证因果顺序关系。但是读取却还没做到这个语义  \n为了读取可以与可线性化一致，有以下方法可以解决这个问题：\n    1. 把读的请求也变成日志的方式追加到排序广播，通过变成日志的情况下可以确定了顺序的问题。（ETCD采用的是这种方式）  \n    2. 如果可以以可线性化的方式获取最新日志的消息位置，则查询位置，直到该位置之前的所有条目读发送给你，再进行读取（ZooKeeper使用的方式）  \n    3. 可以从同步更新的副本中进行读取，保证每次读的是最新的值。  \n\n所以最终可线性化的原子地对寄存器做CAS的操作与全序关系广播其实等价于共识的问题。\n\n# <a id=\"Capability\"><span class=\"toptitle\">分布式共识的能力边界</span></a>\n共识： 使得分布式系统中就某件事情达成一致  \n共识的使用场景：  \n    1. 主节点选举（防止脑裂问题）  \n    2. 原子事务的提交（跨节点或分区的数据库，事务在部分节点成功，部分节点失败，需要进行回滚）  \n我们先从事务的原子性开始，讨论2PC（2阶段提交），之后再会谈及其他更好的共识算法的实现（ZooKeeper， Raft）  \n\n## <a id=\"3.1\"><span class=\"secondtitle\">分布式事务 </span></a>\n事务原子性的目的：  \n一个多笔写操作的事务在执行过程中出现意外情况，为上层应用提供一个简单的语义，全部成功或者全部失败  \n单机原子提交：  \n数据库把事务写入持久化部分，然后把提交记录追加写入到磁盘的日志文件中。所以在单节点上面，事务提交非常依赖与数据持久写入磁盘的顺序关系  \n    1. 先写入数据，再提交记录  \n    2. 事务提交或者中止的关键点在于磁盘完成日志的时候，在完成写之前崩溃的情况下，事务需要中止；如果日志在完成写入后发生崩溃，事务被安全提交  \n\n但是对于分布式多节点，处理方法有所差别，原因可能是以下这几个问题引起的  \n    1. 某些节点发现不满足要求中止了事务，但是部分节点通过并且提交    \n    2. 部分请求可能在网络不稳定的情况下丢失，超时而中止；但是其他请求可能成功提交  \n    3. 节点可能在写入日志前崩溃，而且在恢复后回滚（原来数据没有成功，回滚可能会出现问题）  \n如果一部分节点提交了事务，但是部分节点放弃了事务，会导致集群中节点信息的不一致，而且事务一旦被提交，即使事后发现其他节点中止，也无法撤销本节点的事务  \n\n事务提交后不能撤销的原因：   \n一旦数据提交，就会被其他事务可见，然后客户端（应用层）就会做出相应的反应，这个是构成读-提交隔离的基础。但是如果允许撤销的话，那么所有之后的读-提交级别的任务，然后会产生多级的级联式追溯和撤销。导致系统压力巨大甚至崩溃。并且不能保证数据是否能够准确落盘。  \n\n因为不允许撤销事务，因为如果一个错误的事务被提交了，必然需要一个新的事务来抵消它的影响，但是这个需要应用层来进行处理，就不符合我们需要给应用层提供的原子性。  \n\n### 2PC \n两阶段提交（2PC）是一种在多个节点上实现事务原子提交的算法。要么全部提交，要么全部不提交。\n\n##### 2PC的流程（为什么可以解决上面单阶段提交的问题）\n1. 应用启动分布式事务的时候，先去像协调者获取事务ID（全局唯一）\n2. 应用程序在每个参与的节点启动单节点事务，并且把事务ID附加到到参与者的事务上。如果这个阶段发生异常，可以协调者和其他参与者可以安全中止\n3. 应用程序准备提交事务时，协调者回向参与者发送携带事务ID准备请求，只要有一个发现失败的情况下，通知全部放弃事务\n4. 参与者收到请求后，确保自己时候可以提交事务（包括硬件故障和软件故障的确认），然后检查是否有冲突或者违规。一旦返回是，节点会承诺提交事务。（保证了参与者不会撤销事务）\n5. 当协调者收到所有的参与者返回后，要决定是否提交事务，并且把此决定写入到硬盘的事务日志（WAL）中，防止掉电后可能出现的异常\n6. 协调者向参与者发送提交/放弃 事物的请求，只要是提交，每个参与者会重试到成功为止(包括了进程崩溃的重试、节点重启等情况)\n\n所以他是在保证了上面的一个重要前提，只要提交了就不能撤回。\n在参与者在返回给协调者的时候保证了单向性\n并且协调者确定提交了之后也是保证了不可逆，因此保证了2pc可以不会出现那些异常的情况。\n\n但是2PC的单点在于协调者的问题（虽然可以采用共识层来写协调者保证高可用）但是整个过程中的热点也会出现在协调者上面。\n\n### 实际生产上面的分布式事务\n### 异构分布式事务\n虽然分布式事务因为这样可能会有阻塞而导致性能和吞吐量的下降，但是是否没有折中的方法来使用类似的语义呢？\n目前更多的是采用了异构的方法（如数据库+MQ）的执行异构的分布式事务\n\n对于异构形式的分布式事务，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息处理完毕。\n但只要其中一个出现失败的情况，两个部分都必须进行中止的操作。\n\n<b>保证消息可以有效处理有且仅有一次</b>\n\n目前有XA的异构的分布式事务的标准。\n\n## <a id=\"3.2\"><span class=\"secondtitle\">支持容错的共识</span></a>\n共识问题的形式化描述： 一个或者多个节点可以提议某些值，由共识算法来决定最终的值。\n\n基于上面的描述共识算法必须满足以下的性质：\n    1. 协商一致性（所有节点都接受相同的决议）\n    2. 诚实性（所有节点不能反悔，对某项提议不能有两次决定）\n    3. 合法性（决定了值V, 那么V肯定是由某个节点提议的）\n    4. 可终止性（如果节点不崩溃最终一定可以达成协议）\n\n协商一致性和诚实的属性定义了共识算法的核心思想：决定一致的结果，并且一旦决定就不能改变。  \n合法性是为了排除一些无意义的方案，  \n可终止性是容错的体现，避免了整个系统的空转  \n根据之前提及的： 可终止性是活性， 其他三个是安全方面的属性。\n\n因为共识算法的目的是解决在大多数节点正常的情况下正确运行才能确保终止性。\n\n### 共识算法和全序广播的关系\n\n共识算法(如Raft、Paxos、Zab)等都不是直接采用上述的形式化模型。而是决定了一系列的值，然后采用全序关系广播算法来进行实现。  \n\n全序关系广播要点： 消息按相同的顺序发送到所有的节点，有且只有一次。  \n这样的方式相当于多轮的共识过程。在每一轮，节点会提出之后需要发出的信息，然后决定下一个顺序。\n\n对于上面的提到的四个性质：\n1. 由于协商的一致性，所有节点决定以相同的顺序发送相同的消息。\n2. 由于诚实性，消息不会重复\n3. 由于合法性， 消息不会被破坏，也不是凭空捏造\n4. 由于可终止性，消息不会丢失\n\n### Epoch 和 Quorum\n\n对于共识算法来说，都采用了一个弱化的保证，定义了一个世代编号（Epoch）来确保每个世代里面，主节点是唯一的。\n如果发现当前主节点失效的情况，节点开始选举新一轮的主节点，Epoch号递增。在主节点做出任何决定的时候，都需要检查是否由比它更高的Epoch号码。\n主节点必须从Quorum中收集投票，并且把提议传送到各个节点中，等待节点的返回，当只要没有更高的Epoch主节点\n时，才会对当前的提议进行投票。\n\n此处其实是由两个操作组成：1. 选举主节点； 2.对主节点的提议进行投票\n\n注意的一点： 参与两轮的Quorum必须要由重合，这样才能保证主节点没有更高的Epoch，保证正确性。\n\n与2PC的差别， 2PC是需要协调者向每个参与者做出“是”的返回才能进行，而共识算法可以通过直接以集群的多数来确定是否通过决议\n\n### 共识算法的局限性\n\n共识算法虽然为分布式系统带来了好处，为一切不确定的系统带来了安全属性和容错性。并且可以通过全序关系广播以容错的方式实现线性化的原子操作。\n\n但是共识也是有代价的：\n1. 节点投票是一个同步复制过程，性能可能需要妥协（但是可以通过减少选举的频率来减少整个开销）\n2. 共识体系需要严格的多数节点才能执行，换句话来说，最少需要3个节点才能运行\n3. 多数的共识算法假定了一组固定的参与投票的节点集（主要是为了理解的方便）\n4. 共识算法需要依靠超时来对节点失败进行检测，但是可能会出现因为网络原因的误判导致经常切主，数据搬移多，对外的性能降低。\n5. 网络的影响较大，如果出现频繁切主的情况，可能会有长时间出现无法正常对外进行服务\n\n### 基于共识算法的成员与协调服务\n\n对于像ZooKeeper、Etcd这些分布式键值对的服务，暴露的API与数据库是十分类似的，但是为什么我们需要在共识层上面去构建这些服务呢？\n\n#### 作用\n这些分布式键值对数据库主要是针对保存少量，可完全载入内存的数据。采用容错的全序广播算法在所有节点上复制数据使得可以实现高可用的目标。\n1. 线性化的原子操作\n多个节点同时去获取锁，只有一个会成功，共识协议会保证操作满足原子性和线性化，即使节点出现部分失败的情况\n2. 操作全序\n之前分布式系统问题的文章有提及过Fencing令牌的问题，\n3. 故障检测\n客户端会与这些服务保持一个长连接，如果长时间重连失败的情况下，会把该客户端拥有的资源全部释放\n4. 更改通知\n客户端可以通过读取服务来发现其他的客户端的行为\n\n#### 对外的功能\n1. 节点任务分配\n计算作业调度系统(Yarn)，分区资源调度（如Multi-Raft中的ShardMaster)\n2. 服务发现\n解决云环境中服务启停而注册到的服务变更(consul提供的服务)\n3. 成员服务\n节点是否可用并且获取主节点\n\n### 如何验证一个线性化系统\n（此部分会结合Mit6.824和PingCap tikv 的线性化验证的代码阅读和文章来描述）\n\n\n# <a id=\"ShareNote\">ShareNote</a>\n1. [Dynamo](https://pdos.csail.mit.edu/6.824/papers/dynamo.pdf)\n2. [Riak](https://github.com/basho/riak_core)\n3. [Cassandra](http://cassandra.apache.org/)\n4. [数据密集型应用系统设计](https://book.douban.com/subject/30329536/)","slug":"distribute-system-consensus","published":1,"updated":"2021-01-21T07:27:35.444Z","_id":"ckk6h2epk0003eci51vj6gdyl","comments":1,"layout":"post","photos":[],"link":"","content":"<!-- ---\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 11:08:38 +0800'\ncategory: \nsummary: Distributed System Consistency and Consensus\nthumbnail: distributed-system.png\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#PromiseAbstraction\">分布式系统可以提供的若干保证和抽象机制</a><br>1.1 <a href=\"#1.1\">共识算法的意义</a>  </li>\n<li><a href=\"#atomic\">如何在分布式系统中做到原子性</a><br>2.1 <a href=\"#2.1\">可线性化</a><br>2.2 <a href=\"#2.2\">顺序化</a>  <pre><code> 2.2.1 [顺序、因果、全局序号的关系](#2.2.1)  \n 2.2.2 [全局关系的广播](#2.2.2)  </code></pre>\n</li>\n<li><a href=\"#Capability\">分布式系统的能力边界</a><br>3.1  <a href=\"#3.1\">分布式事务</a><br>3.2  <a href=\"#3.2\">容错的共识</a>  </li>\n<li><a href=\"#ShareNote\">ShareNote</a>  </li>\n</ol>\n\n        <h1 id=\"分布式系统可以提供的若干保证和抽象机制\"   >\n          <a href=\"#分布式系统可以提供的若干保证和抽象机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统可以提供的若干保证和抽象机制</h1>\n      \n        <h2 id=\"共识-分布式一致性-算法的意义\"   >\n          <a href=\"#共识-分布式一致性-算法的意义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识(分布式一致性)算法的意义</h2>\n      <p>对于大多数的多副本的数据库（N&gt;=2)的情况下，它至少达到了最终的一致性。但是因为只是最终，但是到达最终的状态的时间是未知的。<br>最终一致性的多副本数据状态（如Aurora、Riak、Cassandra）的不一致对于应用开发者是比较棘手，因为很多底层保证一致的东西需要挪动到应用层上面去添加规则来继续保证。并且导致测试和验证都会变得异常的困难</p>\n<p>基于上面的问题，我们可能需要找到一个更加强一致性的模型来进行构建，可以把应用层可能遇到的数据库不一致的问题封装起来。虽然可能会付出其他的代价（如性能下降、容错性差）</p>\n\n        <h3 id=\"与事务隔离的级别的差别\"   >\n          <a href=\"#与事务隔离的级别的差别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>与事务隔离的级别的差别</h3>\n      <p>共识与事务隔离都有类似与副本的概念（事务隔离是使用乐观锁（MVCC） 共识是使用多副本）<br>共识：更加强调是针对延时和故障协调副本之间的关系。<br>事务隔离：处理并发事务的各种临界的条件  </p>\n\n        <h1 id=\"如何在分布式系统中做到原子性\"   >\n          <a href=\"#如何在分布式系统中做到原子性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何在分布式系统中做到原子性</h1>\n      \n        <h2 id=\"可线性化\"   >\n          <a href=\"#可线性化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>可线性化</h2>\n      <p>（此部分主要是DDIA第9章节的内容）<br>定义： 让一个分布式的系统看起来像一个单副本的系统，并且所有的操作都是原子的。  </p>\n\n        <h3 id=\"一个非线性化的例子\"   >\n          <a href=\"#一个非线性化的例子\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>一个非线性化的例子</h3>\n      <!-- ![非线性化图片](/assets/img/posts/non-linearized-example.png)   -->\n<img src=\"/2019/08/28/distribute-system-consensus/non-linearized-example.png\" class=\"\" title=\"非线性化\">\n\n<p>对于上面这个图的简要描述：<br>因为使用了多节点非强一致性的数据库，当Referee修改数据库的情况下，因为集群内同步的时间不一致，导致可能Alice先查的的Slave-1 已经修改了，但是Bob查询的Slave-2的库上面还没有修改，导致Alice和Bob获取到的结果不一致。这种场景对于一些一致性需求比较强的情况下不能接受。</p>\n\n        <h3 id=\"线性化的例子的直觉表达\"   >\n          <a href=\"#线性化的例子的直觉表达\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>线性化的例子的直觉表达</h3>\n      <p><b><font color=\"#FF0000\">线性化的简洁但是事实上的描述： 让分布式系统具有寄存器的语义。</font></b><br>对于这个部分，我们详细去探讨一下<br>一般我们的对于读写请求并发（在客户端的角度）是这样的:<br>定义一个前提， 下图中的一个框是指客户端从发出请求到接收到返回值的整个过程<br>单个框可以理解为 客户端发出请求-&gt; 服务器端接受并且处理请求-&gt; 服务器端返回结果-&gt; 客户端在应用级别收到返回<br>下面可能出现框比较长的情况是在上一篇文章（<img src=\"https://ray1888.github.io/distributed-system/2019/08/20/chanllange-of-distributed-system/\" alt=\"分布式系统简介以及其问题\">）的假设所提及的情况，此处不再复述。  </p>\n<p>分布式系统中的寄存器： 线性化数据库中的相同的主键。（此处为X)  </p>\n<!-- ![粗粒度线性一致](/assets/img/posts/generate-line.png)   -->\n<img src=\"/2019/08/28/distribute-system-consensus/generate-line.png\" class=\"\" title=\"粗粒度线性一致\">\n<p>此处对于寄存器有两类的操作：</p>\n<ol>\n<li>read(x)  读取主键为X的值，数据库返回值v</li>\n<li>write(x,v) 客户端把X的值更新为V，数据库返回值为r(成功或者失败)</li>\n</ol>\n<p>对于上图在read和write重合的过程中，read的结果可能有2种情况：  </p>\n<ol>\n<li>read在write完成之前结束(返回0)  </li>\n<li>read在write完成之后结束 (返回1)  </li>\n</ol>\n<p>但是这个描述的粒度还是比较大，为了把系统线性化的更好的描述，我们添加下面的约束  </p>\n<!-- ![细粒度线性一致](/assets/img/posts/more-detail-line.png)   -->\n<img src=\"/2019/08/28/distribute-system-consensus/more-detail-line.png\" class=\"\" title=\"细粒度线性一致\">\n<p>约束为，在写操作的过程中，肯定有某一个时间点，存储上面的x的值会出现冲0到1的跳变。<br>对于上图， 客户端A在某个节点能够读到X的值为1，那么因为客户端B的读操作是晚于客户端A读的发生的，因此<br>客户端B获取到的值也必然是1（如果不是1，则不是可线性化的系统）。  </p>\n<!-- ![线性一致](/assets/img/posts/line-final.png) -->\n<img src=\"/2019/08/28/distribute-system-consensus/line-final.png\" class=\"\" title=\"线性一致\">\n<p>但是上面的讨论颗粒还是太大了，此处我们加入进去存储，以及存储接收到的操作来整体观察线性一致。<br>我们此处引入一个概念</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAS(compare and swap):一个原子的比较设置操作。编程语言中一般都要实现此概念，此处不详细叙述</span><br></pre></td></tr></table></div></figure>\n<p>并且添加一个假设：即使客户端可能还没有收到成功的响应，但是分布式的存储已经全部同步成新的值。<br>上图中每个操作都有竖线，表示可能的执行的时间点，把这些点连接起来，最终结果必须是一个有效的寄存器读写顺序。<br>可线性化的要求： 按时间箭头向前移动，不能向后移动。<br>可以看到上图中，最后客户端A的操作在c的Cas操作完成后，x的值已经变成了4，但是如果发现读的值为2的话，按时间线的理解就是错误了。因为根据可线性化的要求，cas操作已经执行了，并且时间只能向前走的情况下，客户端A的读操作必然是需要返回4的。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;可线性化和可串行化的对比</span><br><span class=\"line\">#### 可线性化</span><br><span class=\"line\">对寄存器（单个对象）的最新值保证。他不要求将操作组合到事务中，可能会出现写倾斜的问题（如果不采取手段去解决的问题）</span><br><span class=\"line\">#### 可串行化</span><br><span class=\"line\">是事务的隔离属性。每个事务可以读写多个对象，用于确保事务执行的结果与串行执行相同。即使穿行执行的顺序和实际执行的顺序并不一定相同（可能实际上的执行是并行执行事务，但是对外暴露的结果是一致的就可以）  </span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"需要用到线性化的使用场景\"   >\n          <a href=\"#需要用到线性化的使用场景\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>需要用到线性化的使用场景</h3>\n      <ol>\n<li>加锁与主节点选举<br>对于主从复制系统的选主问题，可以通过基于Etcd或者ZooKeeper来进行抢锁操作控制选主</li>\n<li>约束与唯一性保证<br>应用中对同一个资源（如用户名）的唯一性的约束。（可以延展到数据表的主键约束）</li>\n<li>多信息源的时间依赖<br>对于一些异步任务系统虽然采用了最终一致性，但是可能也是会因为实现产生数据的依赖问题。</li>\n</ol>\n\n        <h3 id=\"如何实现一个线性化系统\"   >\n          <a href=\"#如何实现一个线性化系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何实现一个线性化系统</h3>\n      \n        <h4 id=\"对比多种可能使用的方案来确定\"   >\n          <a href=\"#对比多种可能使用的方案来确定\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对比多种可能使用的方案来确定</h4>\n      <p>在考虑容错的基础上，必须考虑复制的机制。我们可以对比多种复制方案来看看那种可以实现线性化</p>\n<ol>\n<li>主从复制。（部分线性化）<br>因为所有写入操作都是从主节点继续，并且把操作同步到从节点上面。但是问题可能出现在实现的问题上：  <ol>\n<li>实时同步可能会出现问题</li>\n<li>可能会因为快照隔离设计出现问题</li>\n</ol>\n</li>\n<li>共识算法（可线性化）<br>类似于主从复制，但是通过一些手段来防止脑裂和过期的副本</li>\n<li>多主复制（不可线性化）<br>当允许并发写入的时候，如果进行异步复制的话，可能会出现数据的冲突。</li>\n<li>无主复制（可能不可线性化）<br>类似于Dynamo的机制，即使使用了Quroum机制，但是如果选取的Quroum不一定是满足的情况下，可能会出现非线性化的处理</li>\n</ol>\n<p>此处提出一个问题，是否只要有Quroum机制（就必定可以支持线性一致呢？）<br>答： 不一定。用下面的例子进行解释  </p>\n<!-- ![QuroumFail](/assets/img/posts/quroum-fail.png)   -->\n<img src=\"/2019/08/28/distribute-system-consensus/quroum-fail.png\" class=\"\" title=\"QuroumFail\">\n\n<p>对于上图中，即使是使用了Quroum，但是没有共识算法的支持，还是可能会出现类似于之前Alice和Bob遇到的情况的问题。但是这个选取的直接是一个Quroum，但是是因为缺少共识，并且网络出现问题才会导致这样的情况出现。</p>\n\n        <h3 id=\"线性化的代价\"   >\n          <a href=\"#线性化的代价\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>线性化的代价</h3>\n      <p><font color=\"#FF0000\">线性化出现代价的最主要的原因还是因为网络的不确定性。</font></p>\n<p>我们先用主从的架构来讨论这个问题，当网络发生分区的情况，主从不能够继续同步操作，可能会导致从库不可用。<br>但是这个是我们需要实现线性化所带来的不可用</p>\n<p>先引入一个概念：CAP理论</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAP : 在同一个时间内，当网络出现分区的情况下，不可能获得兼容可用性和一致性。</span><br></pre></td></tr></table></div></figure>\n<p>CAP理论的推理：不要求线性化的应用更能够容忍网络分区。</p>\n<p>但是为了线性化，我们可能要牺牲性能和延迟。<br>那么我们是否有方法可以做到线性化但是减少性能的牺牲呢？</p>\n\n        <h2 id=\"顺序保证\"   >\n          <a href=\"#顺序保证\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序保证</h2>\n      <p>我们刚刚在讨论线性化的时候使用到了寄存器的概念，那么顺序、可线性化、共识之间是否存在的某种关系呢？</p>\n\n        <h3 id=\"顺序、因果、全局序号的关系\"   >\n          <a href=\"#顺序、因果、全局序号的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序、因果、全局序号的关系</h3>\n      \n        <h4 id=\"顺序和因果的关系\"   >\n          <a href=\"#顺序和因果的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序和因果的关系</h4>\n      <p>因果关系对所发生的事件添加了排序， 一件事情会导致另外一件事情，这些的因果关系依赖链条定义了系统中的因果顺序。如果符合因果关系所规定的顺序，我们称之为因果一致性。（快照隔离，在从数据库中读数据的情况下，查询到的诗句，也可以查到这个数据之前发生了什么的操作事件）</p>\n\n        <h4 id=\"因果顺序并非全序\"   >\n          <a href=\"#因果顺序并非全序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>因果顺序并非全序</h4>\n      <p>全序关系是可以支持两个不同的实体直接进行比较（如自然数集5和13的比较）<br>但是部分集合的对比不一定符合全序，集合{a,b} 与 集合{b,c}是无法进行对比的  </p>\n<p>因此，提炼到可线性化和因果关系中<br>可线性化是存在全序的操作关系，因为暴露对外的行为是与单副本无异，并且每个操作都是原子的。可以分出先后<br>因果是偏序的操作关系，对于并发的两个操作无法比较的情况下，就会发生冲突，对于可以比较的情况下，与线性无异。<br>那么可以这样说，可线性化一定意味着因果关系，因为可线性化是全序的操作。<br>但是可以这样理解，线性化并非是保证因果关系的唯一的途径。我们可以有其他手段去满足因果一致性而避免线性化所带来的问题。<br>因果一致性是被认为是不会由于网络延迟而显著影响性能，并且可以对网络故障容错提供容错的最强一致性的模型。<br>因为实际上很多的应用所需要的是因果一致性来保证应用的正确性。  </p>\n\n        <h4 id=\"捕获因果依赖关系\"   >\n          <a href=\"#捕获因果依赖关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>捕获因果依赖关系</h4>\n      <p>如果只要解决并发操作的先后依赖关系。这里其实只需要由偏序的关系即可。<br>我们常见的数据库的版本技术就是一个解决这个问题的方案之一<br>为了确定数据库的因果关系，数据库需要知道应用读取的是哪个版本的数据。</p>\n\n        <h4 id=\"序列号排序\"   >\n          <a href=\"#序列号排序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>序列号排序</h4>\n      <p>那么，这样的情况下，我们是否需要显式的跟踪所有的因果关系呢？<br>为了性能的考虑，我们可以通过序列号和时间戳（尽量不使用物理时钟）来进行对事件排序，这样在保证性能的同时，也能够保证所有操作在全局的关系。但是要保证每个序列号必须唯一，并且可以比较。<br>我们可以按照与因果关系一致的顺序来创建序列号： 如果操作A发生B之前，那么A一定在全序顺序中出现在B之前<br>这样的全局排序可以捕获所有的因果信息，并且加强了比因果关系更为严格的顺序性  </p>\n<p>那么对于不存在唯一的主节点（多主或者无主），那么我们能怎样生成上面所提及的序列号呢？<br>有实践中可以采用以下方法：<br>    1. 每个节点单独生成自己的一组序列号。假设有两个节点，一个生成奇数，一个生成偶数<br>    2. 把Timestamp添加到操作中（之前生产中有用此种方式）<br>    3. 预先分配序列号的区间范围。（A节点分配1-1000，B节点分配1001-2000）  </p>\n<p>但是这三种实际上生成的唯一的，近似增加的序列号。但是实际上序列号和因果一致不是完全因果一致的。<br>为什么不是因果一致呢?<br>对于情况1，每个节点处理的速率是由不一致的，只要两个节点处于处理速率不一致的情况下，分配的ID必然和实际的顺序关系无法对应<br>对于情况2， 墙上时钟发生偏移的情况<br>对于情况3， 如果sharding的路由发生了变化之后，那么之前1-1000的因果关系就不存在了。  </p>\n<p>那么我们是否没有办法可以在非强主的情况可以获取一个序列号与因果一致可以对应上的吗？  </p>\n<p>我们还有一个方法！！！此处大神来了Leslie Lamport的Lamport TimeStamp可以解决这个问题  </p>\n\n        <h4 id=\"LamportTimeStamp\"   >\n          <a href=\"#LamportTimeStamp\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>LamportTimeStamp</h4>\n      <!-- ![LamportTimeStamp](/assets/img/posts/LamportTimestamp.png)   -->\n<img src=\"/2019/08/28/distribute-system-consensus/LamportTimestamp.png\" class=\"\" title=\"LamportTimeStamp\">\n<p>每个节点一开始的时候都会有一个唯一的标识符（每次初始为0）， 然后每个节点都有一个计数器来记录各自处理的请求总数。到此与之前的时间戳的并无差别，但是Lamport这里处理的亮点出来了，每个节点和每个客户端都会跟踪迄今为止最大的计数器值，并且在每个请求中附带该最大计数器值。当节点收到某个请求的时候，如果发现请求内的最大计数器值大于自身的计数器值，会更新自己的计数器值（Raft中是通过投票和心跳的RPC来同步这个计数器的值，在Raft的概念里面叫做Term，后面讲解Raft的时候会进一步解析，此处只是一个插叙）。</p>\n<p>LamportTimeStamp好像是解决了分布式系统顺序号和因果一致的关系，但是是已经足够解决分布式系统中常见的问题了吗？<br>问题如下：<br>    一个系统的用户名只能由唯一的用户持有，两个用户并发地向系统同时进行注册，我们必须要保证一个成功，一个失败<br>虽然看上去我们是可以把两个请求通过编号把两个并发的请求变成了一个有顺序的问题，但是实际上要保证上面的是唯一的有两个前提：<br>    1. 节点收到用户请求的时候需要马上判断请求时成功还是失败<br>    2. 必须要收集系统的所有创建用户的请求，比较序号<br>但是这个显然是不可能的，只要网络出现问题了，我们就无法做到上面的两个问题。</p>\n<p>那么我们如果要知道全局关系是否确定，就需要提到后面的一个概念，全序关系广播</p>\n\n        <h3 id=\"全局关系的广播\"   >\n          <a href=\"#全局关系的广播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>全局关系的广播</h3>\n      <p>继续先从一个主从复制的系统开始说起，主节点接受写请求并且变成顺序的操作。<br>但是在分布式系统领域，如何扩展系统的吞吐量使之突破单一主节点限制以及处理主节点失效时的故障切换。这类的问题被称为全序关系广播或者原子广播。<br>全序关系广播： 通常指节点之间交换信息的某种协议。有两个特性<br>    1. 可靠发送（没有消息丢失，如果消息发送到某一个节点，它一定要发送到其他的节点）<br>    2. 严格有序（消息总是以相同的顺序发送到每个节点）  </p>\n\n        <h4 id=\"使用全序关系广播\"   >\n          <a href=\"#使用全序关系广播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用全序关系广播</h4>\n      <p>Zookeeper和Etcd的共识服务就实现了全序关系广播。（那么全序关系广播和共识之间的关系？）  </p>\n<p>全序关系广播就是数据库所需要，每条消息表达数据库的写请求，而且每个副本段相同的顺序处理这些写请求，那么所有副本可以保持一致。这个也被称为状态机复制。  </p>\n<p>全局关系广播的另一个要点，顺序在发送消息时已经是确定的，如果消息发送成功，节点不允许追溯将某条消息插到先前的位置上。只能进行追加，这样全序关系广播比时间戳的排序要求更强<br>应用场景：<br>    1.我们可以使用全序关系广播来实现可串行化的事务。（每个消息表示为一个确定性质的事务，并且作为存储过程来执行）<br>    2.提供Fencing令牌锁的服务（把取锁的请求变成一个消息追加到日志中，序列号直接可以变成令牌返回）  </p>\n\n        <h4 id=\"全序关系广播来实现线性化存储\"   >\n          <a href=\"#全序关系广播来实现线性化存储\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>全序关系广播来实现线性化存储</h4>\n      <p>全序关系广播是基于异步模型，保证消息以固定顺序的可靠发送，但是不保证消息何时发送成功，但是可线性化更多地强调读取时能看到最新的写入值。<br>我们可以通过追加的日志的方式使得使用全序关系广播在写入的方式上与可线性化做到一致<br>    1. 在接受请求的本地节点中追加一条消息，指明写入的信息<br>    2. 读取日志，广播到其他节点，等待回应<br>    3. 如果回复中有冲突，则失败，返回错误给客户端；否则返回成功给客户端<br>通过日志追加可以把并发有效的转换为多条的日志来保证因果顺序关系。但是读取却还没做到这个语义<br>为了读取可以与可线性化一致，有以下方法可以解决这个问题：<br>    1. 把读的请求也变成日志的方式追加到排序广播，通过变成日志的情况下可以确定了顺序的问题。（ETCD采用的是这种方式）<br>    2. 如果可以以可线性化的方式获取最新日志的消息位置，则查询位置，直到该位置之前的所有条目读发送给你，再进行读取（ZooKeeper使用的方式）<br>    3. 可以从同步更新的副本中进行读取，保证每次读的是最新的值。  </p>\n<p>所以最终可线性化的原子地对寄存器做CAS的操作与全序关系广播其实等价于共识的问题。</p>\n\n        <h1 id=\"分布式共识的能力边界\"   >\n          <a href=\"#分布式共识的能力边界\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识的能力边界</h1>\n      <p>共识： 使得分布式系统中就某件事情达成一致<br>共识的使用场景：<br>    1. 主节点选举（防止脑裂问题）<br>    2. 原子事务的提交（跨节点或分区的数据库，事务在部分节点成功，部分节点失败，需要进行回滚）<br>我们先从事务的原子性开始，讨论2PC（2阶段提交），之后再会谈及其他更好的共识算法的实现（ZooKeeper， Raft）  </p>\n\n        <h2 id=\"分布式事务\"   >\n          <a href=\"#分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式事务</h2>\n      <p>事务原子性的目的：<br>一个多笔写操作的事务在执行过程中出现意外情况，为上层应用提供一个简单的语义，全部成功或者全部失败<br>单机原子提交：<br>数据库把事务写入持久化部分，然后把提交记录追加写入到磁盘的日志文件中。所以在单节点上面，事务提交非常依赖与数据持久写入磁盘的顺序关系<br>    1. 先写入数据，再提交记录<br>    2. 事务提交或者中止的关键点在于磁盘完成日志的时候，在完成写之前崩溃的情况下，事务需要中止；如果日志在完成写入后发生崩溃，事务被安全提交  </p>\n<p>但是对于分布式多节点，处理方法有所差别，原因可能是以下这几个问题引起的<br>    1. 某些节点发现不满足要求中止了事务，但是部分节点通过并且提交<br>    2. 部分请求可能在网络不稳定的情况下丢失，超时而中止；但是其他请求可能成功提交<br>    3. 节点可能在写入日志前崩溃，而且在恢复后回滚（原来数据没有成功，回滚可能会出现问题）<br>如果一部分节点提交了事务，但是部分节点放弃了事务，会导致集群中节点信息的不一致，而且事务一旦被提交，即使事后发现其他节点中止，也无法撤销本节点的事务  </p>\n<p>事务提交后不能撤销的原因：<br>一旦数据提交，就会被其他事务可见，然后客户端（应用层）就会做出相应的反应，这个是构成读-提交隔离的基础。但是如果允许撤销的话，那么所有之后的读-提交级别的任务，然后会产生多级的级联式追溯和撤销。导致系统压力巨大甚至崩溃。并且不能保证数据是否能够准确落盘。  </p>\n<p>因为不允许撤销事务，因为如果一个错误的事务被提交了，必然需要一个新的事务来抵消它的影响，但是这个需要应用层来进行处理，就不符合我们需要给应用层提供的原子性。  </p>\n\n        <h3 id=\"2PC\"   >\n          <a href=\"#2PC\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2PC</h3>\n      <p>两阶段提交（2PC）是一种在多个节点上实现事务原子提交的算法。要么全部提交，要么全部不提交。</p>\n\n        <h5 id=\"2PC的流程（为什么可以解决上面单阶段提交的问题）\"   >\n          <a href=\"#2PC的流程（为什么可以解决上面单阶段提交的问题）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2PC的流程（为什么可以解决上面单阶段提交的问题）</h5>\n      <ol>\n<li>应用启动分布式事务的时候，先去像协调者获取事务ID（全局唯一）</li>\n<li>应用程序在每个参与的节点启动单节点事务，并且把事务ID附加到到参与者的事务上。如果这个阶段发生异常，可以协调者和其他参与者可以安全中止</li>\n<li>应用程序准备提交事务时，协调者回向参与者发送携带事务ID准备请求，只要有一个发现失败的情况下，通知全部放弃事务</li>\n<li>参与者收到请求后，确保自己时候可以提交事务（包括硬件故障和软件故障的确认），然后检查是否有冲突或者违规。一旦返回是，节点会承诺提交事务。（保证了参与者不会撤销事务）</li>\n<li>当协调者收到所有的参与者返回后，要决定是否提交事务，并且把此决定写入到硬盘的事务日志（WAL）中，防止掉电后可能出现的异常</li>\n<li>协调者向参与者发送提交/放弃 事物的请求，只要是提交，每个参与者会重试到成功为止(包括了进程崩溃的重试、节点重启等情况)</li>\n</ol>\n<p>所以他是在保证了上面的一个重要前提，只要提交了就不能撤回。<br>在参与者在返回给协调者的时候保证了单向性<br>并且协调者确定提交了之后也是保证了不可逆，因此保证了2pc可以不会出现那些异常的情况。</p>\n<p>但是2PC的单点在于协调者的问题（虽然可以采用共识层来写协调者保证高可用）但是整个过程中的热点也会出现在协调者上面。</p>\n\n        <h3 id=\"实际生产上面的分布式事务\"   >\n          <a href=\"#实际生产上面的分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实际生产上面的分布式事务</h3>\n      \n        <h3 id=\"异构分布式事务\"   >\n          <a href=\"#异构分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>异构分布式事务</h3>\n      <p>虽然分布式事务因为这样可能会有阻塞而导致性能和吞吐量的下降，但是是否没有折中的方法来使用类似的语义呢？<br>目前更多的是采用了异构的方法（如数据库+MQ）的执行异构的分布式事务</p>\n<p>对于异构形式的分布式事务，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息处理完毕。<br>但只要其中一个出现失败的情况，两个部分都必须进行中止的操作。</p>\n<p><b>保证消息可以有效处理有且仅有一次</b></p>\n<p>目前有XA的异构的分布式事务的标准。</p>\n\n        <h2 id=\"支持容错的共识\"   >\n          <a href=\"#支持容错的共识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>支持容错的共识</h2>\n      <p>共识问题的形式化描述： 一个或者多个节点可以提议某些值，由共识算法来决定最终的值。</p>\n<p>基于上面的描述共识算法必须满足以下的性质：<br>    1. 协商一致性（所有节点都接受相同的决议）<br>    2. 诚实性（所有节点不能反悔，对某项提议不能有两次决定）<br>    3. 合法性（决定了值V, 那么V肯定是由某个节点提议的）<br>    4. 可终止性（如果节点不崩溃最终一定可以达成协议）</p>\n<p>协商一致性和诚实的属性定义了共识算法的核心思想：决定一致的结果，并且一旦决定就不能改变。<br>合法性是为了排除一些无意义的方案，<br>可终止性是容错的体现，避免了整个系统的空转<br>根据之前提及的： 可终止性是活性， 其他三个是安全方面的属性。</p>\n<p>因为共识算法的目的是解决在大多数节点正常的情况下正确运行才能确保终止性。</p>\n\n        <h3 id=\"共识算法和全序广播的关系\"   >\n          <a href=\"#共识算法和全序广播的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识算法和全序广播的关系</h3>\n      <p>共识算法(如Raft、Paxos、Zab)等都不是直接采用上述的形式化模型。而是决定了一系列的值，然后采用全序关系广播算法来进行实现。  </p>\n<p>全序关系广播要点： 消息按相同的顺序发送到所有的节点，有且只有一次。<br>这样的方式相当于多轮的共识过程。在每一轮，节点会提出之后需要发出的信息，然后决定下一个顺序。</p>\n<p>对于上面的提到的四个性质：</p>\n<ol>\n<li>由于协商的一致性，所有节点决定以相同的顺序发送相同的消息。</li>\n<li>由于诚实性，消息不会重复</li>\n<li>由于合法性， 消息不会被破坏，也不是凭空捏造</li>\n<li>由于可终止性，消息不会丢失</li>\n</ol>\n\n        <h3 id=\"Epoch-和-Quorum\"   >\n          <a href=\"#Epoch-和-Quorum\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Epoch 和 Quorum</h3>\n      <p>对于共识算法来说，都采用了一个弱化的保证，定义了一个世代编号（Epoch）来确保每个世代里面，主节点是唯一的。<br>如果发现当前主节点失效的情况，节点开始选举新一轮的主节点，Epoch号递增。在主节点做出任何决定的时候，都需要检查是否由比它更高的Epoch号码。<br>主节点必须从Quorum中收集投票，并且把提议传送到各个节点中，等待节点的返回，当只要没有更高的Epoch主节点<br>时，才会对当前的提议进行投票。</p>\n<p>此处其实是由两个操作组成：1. 选举主节点； 2.对主节点的提议进行投票</p>\n<p>注意的一点： 参与两轮的Quorum必须要由重合，这样才能保证主节点没有更高的Epoch，保证正确性。</p>\n<p>与2PC的差别， 2PC是需要协调者向每个参与者做出“是”的返回才能进行，而共识算法可以通过直接以集群的多数来确定是否通过决议</p>\n\n        <h3 id=\"共识算法的局限性\"   >\n          <a href=\"#共识算法的局限性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识算法的局限性</h3>\n      <p>共识算法虽然为分布式系统带来了好处，为一切不确定的系统带来了安全属性和容错性。并且可以通过全序关系广播以容错的方式实现线性化的原子操作。</p>\n<p>但是共识也是有代价的：</p>\n<ol>\n<li>节点投票是一个同步复制过程，性能可能需要妥协（但是可以通过减少选举的频率来减少整个开销）</li>\n<li>共识体系需要严格的多数节点才能执行，换句话来说，最少需要3个节点才能运行</li>\n<li>多数的共识算法假定了一组固定的参与投票的节点集（主要是为了理解的方便）</li>\n<li>共识算法需要依靠超时来对节点失败进行检测，但是可能会出现因为网络原因的误判导致经常切主，数据搬移多，对外的性能降低。</li>\n<li>网络的影响较大，如果出现频繁切主的情况，可能会有长时间出现无法正常对外进行服务</li>\n</ol>\n\n        <h3 id=\"基于共识算法的成员与协调服务\"   >\n          <a href=\"#基于共识算法的成员与协调服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基于共识算法的成员与协调服务</h3>\n      <p>对于像ZooKeeper、Etcd这些分布式键值对的服务，暴露的API与数据库是十分类似的，但是为什么我们需要在共识层上面去构建这些服务呢？</p>\n\n        <h4 id=\"作用\"   >\n          <a href=\"#作用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>作用</h4>\n      <p>这些分布式键值对数据库主要是针对保存少量，可完全载入内存的数据。采用容错的全序广播算法在所有节点上复制数据使得可以实现高可用的目标。</p>\n<ol>\n<li>线性化的原子操作<br>多个节点同时去获取锁，只有一个会成功，共识协议会保证操作满足原子性和线性化，即使节点出现部分失败的情况</li>\n<li>操作全序<br>之前分布式系统问题的文章有提及过Fencing令牌的问题，</li>\n<li>故障检测<br>客户端会与这些服务保持一个长连接，如果长时间重连失败的情况下，会把该客户端拥有的资源全部释放</li>\n<li>更改通知<br>客户端可以通过读取服务来发现其他的客户端的行为</li>\n</ol>\n\n        <h4 id=\"对外的功能\"   >\n          <a href=\"#对外的功能\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对外的功能</h4>\n      <ol>\n<li>节点任务分配<br>计算作业调度系统(Yarn)，分区资源调度（如Multi-Raft中的ShardMaster)</li>\n<li>服务发现<br>解决云环境中服务启停而注册到的服务变更(consul提供的服务)</li>\n<li>成员服务<br>节点是否可用并且获取主节点</li>\n</ol>\n\n        <h3 id=\"如何验证一个线性化系统\"   >\n          <a href=\"#如何验证一个线性化系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何验证一个线性化系统</h3>\n      <p>（此部分会结合Mit6.824和PingCap tikv 的线性化验证的代码阅读和文章来描述）</p>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://pdos.csail.mit.edu/6.824/papers/dynamo.pdf\" >Dynamo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/basho/riak_core\" >Riak</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://cassandra.apache.org/\" >Cassandra</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://book.douban.com/subject/30329536/\" >数据密集型应用系统设计</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<!-- ---\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 11:08:38 +0800'\ncategory: \nsummary: Distributed System Consistency and Consensus\nthumbnail: distributed-system.png\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#PromiseAbstraction\">分布式系统可以提供的若干保证和抽象机制</a><br>1.1 <a href=\"#1.1\">共识算法的意义</a>  </li>\n<li><a href=\"#atomic\">如何在分布式系统中做到原子性</a><br>2.1 <a href=\"#2.1\">可线性化</a><br>2.2 <a href=\"#2.2\">顺序化</a>  <pre><code> 2.2.1 [顺序、因果、全局序号的关系](#2.2.1)  \n 2.2.2 [全局关系的广播](#2.2.2)  </code></pre>\n</li>\n<li><a href=\"#Capability\">分布式系统的能力边界</a><br>3.1  <a href=\"#3.1\">分布式事务</a><br>3.2  <a href=\"#3.2\">容错的共识</a>  </li>\n<li><a href=\"#ShareNote\">ShareNote</a>  </li>\n</ol>\n\n        <h1 id=\"分布式系统可以提供的若干保证和抽象机制\"   >\n          <a href=\"#分布式系统可以提供的若干保证和抽象机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统可以提供的若干保证和抽象机制</h1>\n      \n        <h2 id=\"共识-分布式一致性-算法的意义\"   >\n          <a href=\"#共识-分布式一致性-算法的意义\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识(分布式一致性)算法的意义</h2>\n      <p>对于大多数的多副本的数据库（N&gt;=2)的情况下，它至少达到了最终的一致性。但是因为只是最终，但是到达最终的状态的时间是未知的。<br>最终一致性的多副本数据状态（如Aurora、Riak、Cassandra）的不一致对于应用开发者是比较棘手，因为很多底层保证一致的东西需要挪动到应用层上面去添加规则来继续保证。并且导致测试和验证都会变得异常的困难</p>\n<p>基于上面的问题，我们可能需要找到一个更加强一致性的模型来进行构建，可以把应用层可能遇到的数据库不一致的问题封装起来。虽然可能会付出其他的代价（如性能下降、容错性差）</p>\n\n        <h3 id=\"与事务隔离的级别的差别\"   >\n          <a href=\"#与事务隔离的级别的差别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>与事务隔离的级别的差别</h3>\n      <p>共识与事务隔离都有类似与副本的概念（事务隔离是使用乐观锁（MVCC） 共识是使用多副本）<br>共识：更加强调是针对延时和故障协调副本之间的关系。<br>事务隔离：处理并发事务的各种临界的条件  </p>\n\n        <h1 id=\"如何在分布式系统中做到原子性\"   >\n          <a href=\"#如何在分布式系统中做到原子性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何在分布式系统中做到原子性</h1>\n      \n        <h2 id=\"可线性化\"   >\n          <a href=\"#可线性化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>可线性化</h2>\n      <p>（此部分主要是DDIA第9章节的内容）<br>定义： 让一个分布式的系统看起来像一个单副本的系统，并且所有的操作都是原子的。  </p>\n\n        <h3 id=\"一个非线性化的例子\"   >\n          <a href=\"#一个非线性化的例子\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>一个非线性化的例子</h3>\n      <!-- ![非线性化图片](/assets/img/posts/non-linearized-example.png)   -->\n<img src=\"/2019/08/28/distribute-system-consensus/non-linearized-example.png\" class=\"\" title=\"非线性化\">\n\n<p>对于上面这个图的简要描述：<br>因为使用了多节点非强一致性的数据库，当Referee修改数据库的情况下，因为集群内同步的时间不一致，导致可能Alice先查的的Slave-1 已经修改了，但是Bob查询的Slave-2的库上面还没有修改，导致Alice和Bob获取到的结果不一致。这种场景对于一些一致性需求比较强的情况下不能接受。</p>\n\n        <h3 id=\"线性化的例子的直觉表达\"   >\n          <a href=\"#线性化的例子的直觉表达\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>线性化的例子的直觉表达</h3>\n      <p><b><font color=\"#FF0000\">线性化的简洁但是事实上的描述： 让分布式系统具有寄存器的语义。</font></b><br>对于这个部分，我们详细去探讨一下<br>一般我们的对于读写请求并发（在客户端的角度）是这样的:<br>定义一个前提， 下图中的一个框是指客户端从发出请求到接收到返回值的整个过程<br>单个框可以理解为 客户端发出请求-&gt; 服务器端接受并且处理请求-&gt; 服务器端返回结果-&gt; 客户端在应用级别收到返回<br>下面可能出现框比较长的情况是在上一篇文章（<img src=\"https://ray1888.github.io/distributed-system/2019/08/20/chanllange-of-distributed-system/\" alt=\"分布式系统简介以及其问题\">）的假设所提及的情况，此处不再复述。  </p>\n<p>分布式系统中的寄存器： 线性化数据库中的相同的主键。（此处为X)  </p>\n<!-- ![粗粒度线性一致](/assets/img/posts/generate-line.png)   -->\n<img src=\"/2019/08/28/distribute-system-consensus/generate-line.png\" class=\"\" title=\"粗粒度线性一致\">\n<p>此处对于寄存器有两类的操作：</p>\n<ol>\n<li>read(x)  读取主键为X的值，数据库返回值v</li>\n<li>write(x,v) 客户端把X的值更新为V，数据库返回值为r(成功或者失败)</li>\n</ol>\n<p>对于上图在read和write重合的过程中，read的结果可能有2种情况：  </p>\n<ol>\n<li>read在write完成之前结束(返回0)  </li>\n<li>read在write完成之后结束 (返回1)  </li>\n</ol>\n<p>但是这个描述的粒度还是比较大，为了把系统线性化的更好的描述，我们添加下面的约束  </p>\n<!-- ![细粒度线性一致](/assets/img/posts/more-detail-line.png)   -->\n<img src=\"/2019/08/28/distribute-system-consensus/more-detail-line.png\" class=\"\" title=\"细粒度线性一致\">\n<p>约束为，在写操作的过程中，肯定有某一个时间点，存储上面的x的值会出现冲0到1的跳变。<br>对于上图， 客户端A在某个节点能够读到X的值为1，那么因为客户端B的读操作是晚于客户端A读的发生的，因此<br>客户端B获取到的值也必然是1（如果不是1，则不是可线性化的系统）。  </p>\n<!-- ![线性一致](/assets/img/posts/line-final.png) -->\n<img src=\"/2019/08/28/distribute-system-consensus/line-final.png\" class=\"\" title=\"线性一致\">\n<p>但是上面的讨论颗粒还是太大了，此处我们加入进去存储，以及存储接收到的操作来整体观察线性一致。<br>我们此处引入一个概念</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAS(compare and swap):一个原子的比较设置操作。编程语言中一般都要实现此概念，此处不详细叙述</span><br></pre></td></tr></table></div></figure>\n<p>并且添加一个假设：即使客户端可能还没有收到成功的响应，但是分布式的存储已经全部同步成新的值。<br>上图中每个操作都有竖线，表示可能的执行的时间点，把这些点连接起来，最终结果必须是一个有效的寄存器读写顺序。<br>可线性化的要求： 按时间箭头向前移动，不能向后移动。<br>可以看到上图中，最后客户端A的操作在c的Cas操作完成后，x的值已经变成了4，但是如果发现读的值为2的话，按时间线的理解就是错误了。因为根据可线性化的要求，cas操作已经执行了，并且时间只能向前走的情况下，客户端A的读操作必然是需要返回4的。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;可线性化和可串行化的对比</span><br><span class=\"line\">#### 可线性化</span><br><span class=\"line\">对寄存器（单个对象）的最新值保证。他不要求将操作组合到事务中，可能会出现写倾斜的问题（如果不采取手段去解决的问题）</span><br><span class=\"line\">#### 可串行化</span><br><span class=\"line\">是事务的隔离属性。每个事务可以读写多个对象，用于确保事务执行的结果与串行执行相同。即使穿行执行的顺序和实际执行的顺序并不一定相同（可能实际上的执行是并行执行事务，但是对外暴露的结果是一致的就可以）  </span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"需要用到线性化的使用场景\"   >\n          <a href=\"#需要用到线性化的使用场景\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>需要用到线性化的使用场景</h3>\n      <ol>\n<li>加锁与主节点选举<br>对于主从复制系统的选主问题，可以通过基于Etcd或者ZooKeeper来进行抢锁操作控制选主</li>\n<li>约束与唯一性保证<br>应用中对同一个资源（如用户名）的唯一性的约束。（可以延展到数据表的主键约束）</li>\n<li>多信息源的时间依赖<br>对于一些异步任务系统虽然采用了最终一致性，但是可能也是会因为实现产生数据的依赖问题。</li>\n</ol>\n\n        <h3 id=\"如何实现一个线性化系统\"   >\n          <a href=\"#如何实现一个线性化系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何实现一个线性化系统</h3>\n      \n        <h4 id=\"对比多种可能使用的方案来确定\"   >\n          <a href=\"#对比多种可能使用的方案来确定\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对比多种可能使用的方案来确定</h4>\n      <p>在考虑容错的基础上，必须考虑复制的机制。我们可以对比多种复制方案来看看那种可以实现线性化</p>\n<ol>\n<li>主从复制。（部分线性化）<br>因为所有写入操作都是从主节点继续，并且把操作同步到从节点上面。但是问题可能出现在实现的问题上：  <ol>\n<li>实时同步可能会出现问题</li>\n<li>可能会因为快照隔离设计出现问题</li>\n</ol>\n</li>\n<li>共识算法（可线性化）<br>类似于主从复制，但是通过一些手段来防止脑裂和过期的副本</li>\n<li>多主复制（不可线性化）<br>当允许并发写入的时候，如果进行异步复制的话，可能会出现数据的冲突。</li>\n<li>无主复制（可能不可线性化）<br>类似于Dynamo的机制，即使使用了Quroum机制，但是如果选取的Quroum不一定是满足的情况下，可能会出现非线性化的处理</li>\n</ol>\n<p>此处提出一个问题，是否只要有Quroum机制（就必定可以支持线性一致呢？）<br>答： 不一定。用下面的例子进行解释  </p>\n<!-- ![QuroumFail](/assets/img/posts/quroum-fail.png)   -->\n<img src=\"/2019/08/28/distribute-system-consensus/quroum-fail.png\" class=\"\" title=\"QuroumFail\">\n\n<p>对于上图中，即使是使用了Quroum，但是没有共识算法的支持，还是可能会出现类似于之前Alice和Bob遇到的情况的问题。但是这个选取的直接是一个Quroum，但是是因为缺少共识，并且网络出现问题才会导致这样的情况出现。</p>\n\n        <h3 id=\"线性化的代价\"   >\n          <a href=\"#线性化的代价\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>线性化的代价</h3>\n      <p><font color=\"#FF0000\">线性化出现代价的最主要的原因还是因为网络的不确定性。</font></p>\n<p>我们先用主从的架构来讨论这个问题，当网络发生分区的情况，主从不能够继续同步操作，可能会导致从库不可用。<br>但是这个是我们需要实现线性化所带来的不可用</p>\n<p>先引入一个概念：CAP理论</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAP : 在同一个时间内，当网络出现分区的情况下，不可能获得兼容可用性和一致性。</span><br></pre></td></tr></table></div></figure>\n<p>CAP理论的推理：不要求线性化的应用更能够容忍网络分区。</p>\n<p>但是为了线性化，我们可能要牺牲性能和延迟。<br>那么我们是否有方法可以做到线性化但是减少性能的牺牲呢？</p>\n\n        <h2 id=\"顺序保证\"   >\n          <a href=\"#顺序保证\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序保证</h2>\n      <p>我们刚刚在讨论线性化的时候使用到了寄存器的概念，那么顺序、可线性化、共识之间是否存在的某种关系呢？</p>\n\n        <h3 id=\"顺序、因果、全局序号的关系\"   >\n          <a href=\"#顺序、因果、全局序号的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序、因果、全局序号的关系</h3>\n      \n        <h4 id=\"顺序和因果的关系\"   >\n          <a href=\"#顺序和因果的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>顺序和因果的关系</h4>\n      <p>因果关系对所发生的事件添加了排序， 一件事情会导致另外一件事情，这些的因果关系依赖链条定义了系统中的因果顺序。如果符合因果关系所规定的顺序，我们称之为因果一致性。（快照隔离，在从数据库中读数据的情况下，查询到的诗句，也可以查到这个数据之前发生了什么的操作事件）</p>\n\n        <h4 id=\"因果顺序并非全序\"   >\n          <a href=\"#因果顺序并非全序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>因果顺序并非全序</h4>\n      <p>全序关系是可以支持两个不同的实体直接进行比较（如自然数集5和13的比较）<br>但是部分集合的对比不一定符合全序，集合{a,b} 与 集合{b,c}是无法进行对比的  </p>\n<p>因此，提炼到可线性化和因果关系中<br>可线性化是存在全序的操作关系，因为暴露对外的行为是与单副本无异，并且每个操作都是原子的。可以分出先后<br>因果是偏序的操作关系，对于并发的两个操作无法比较的情况下，就会发生冲突，对于可以比较的情况下，与线性无异。<br>那么可以这样说，可线性化一定意味着因果关系，因为可线性化是全序的操作。<br>但是可以这样理解，线性化并非是保证因果关系的唯一的途径。我们可以有其他手段去满足因果一致性而避免线性化所带来的问题。<br>因果一致性是被认为是不会由于网络延迟而显著影响性能，并且可以对网络故障容错提供容错的最强一致性的模型。<br>因为实际上很多的应用所需要的是因果一致性来保证应用的正确性。  </p>\n\n        <h4 id=\"捕获因果依赖关系\"   >\n          <a href=\"#捕获因果依赖关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>捕获因果依赖关系</h4>\n      <p>如果只要解决并发操作的先后依赖关系。这里其实只需要由偏序的关系即可。<br>我们常见的数据库的版本技术就是一个解决这个问题的方案之一<br>为了确定数据库的因果关系，数据库需要知道应用读取的是哪个版本的数据。</p>\n\n        <h4 id=\"序列号排序\"   >\n          <a href=\"#序列号排序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>序列号排序</h4>\n      <p>那么，这样的情况下，我们是否需要显式的跟踪所有的因果关系呢？<br>为了性能的考虑，我们可以通过序列号和时间戳（尽量不使用物理时钟）来进行对事件排序，这样在保证性能的同时，也能够保证所有操作在全局的关系。但是要保证每个序列号必须唯一，并且可以比较。<br>我们可以按照与因果关系一致的顺序来创建序列号： 如果操作A发生B之前，那么A一定在全序顺序中出现在B之前<br>这样的全局排序可以捕获所有的因果信息，并且加强了比因果关系更为严格的顺序性  </p>\n<p>那么对于不存在唯一的主节点（多主或者无主），那么我们能怎样生成上面所提及的序列号呢？<br>有实践中可以采用以下方法：<br>    1. 每个节点单独生成自己的一组序列号。假设有两个节点，一个生成奇数，一个生成偶数<br>    2. 把Timestamp添加到操作中（之前生产中有用此种方式）<br>    3. 预先分配序列号的区间范围。（A节点分配1-1000，B节点分配1001-2000）  </p>\n<p>但是这三种实际上生成的唯一的，近似增加的序列号。但是实际上序列号和因果一致不是完全因果一致的。<br>为什么不是因果一致呢?<br>对于情况1，每个节点处理的速率是由不一致的，只要两个节点处于处理速率不一致的情况下，分配的ID必然和实际的顺序关系无法对应<br>对于情况2， 墙上时钟发生偏移的情况<br>对于情况3， 如果sharding的路由发生了变化之后，那么之前1-1000的因果关系就不存在了。  </p>\n<p>那么我们是否没有办法可以在非强主的情况可以获取一个序列号与因果一致可以对应上的吗？  </p>\n<p>我们还有一个方法！！！此处大神来了Leslie Lamport的Lamport TimeStamp可以解决这个问题  </p>\n\n        <h4 id=\"LamportTimeStamp\"   >\n          <a href=\"#LamportTimeStamp\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>LamportTimeStamp</h4>\n      <!-- ![LamportTimeStamp](/assets/img/posts/LamportTimestamp.png)   -->\n<img src=\"/2019/08/28/distribute-system-consensus/LamportTimestamp.png\" class=\"\" title=\"LamportTimeStamp\">\n<p>每个节点一开始的时候都会有一个唯一的标识符（每次初始为0）， 然后每个节点都有一个计数器来记录各自处理的请求总数。到此与之前的时间戳的并无差别，但是Lamport这里处理的亮点出来了，每个节点和每个客户端都会跟踪迄今为止最大的计数器值，并且在每个请求中附带该最大计数器值。当节点收到某个请求的时候，如果发现请求内的最大计数器值大于自身的计数器值，会更新自己的计数器值（Raft中是通过投票和心跳的RPC来同步这个计数器的值，在Raft的概念里面叫做Term，后面讲解Raft的时候会进一步解析，此处只是一个插叙）。</p>\n<p>LamportTimeStamp好像是解决了分布式系统顺序号和因果一致的关系，但是是已经足够解决分布式系统中常见的问题了吗？<br>问题如下：<br>    一个系统的用户名只能由唯一的用户持有，两个用户并发地向系统同时进行注册，我们必须要保证一个成功，一个失败<br>虽然看上去我们是可以把两个请求通过编号把两个并发的请求变成了一个有顺序的问题，但是实际上要保证上面的是唯一的有两个前提：<br>    1. 节点收到用户请求的时候需要马上判断请求时成功还是失败<br>    2. 必须要收集系统的所有创建用户的请求，比较序号<br>但是这个显然是不可能的，只要网络出现问题了，我们就无法做到上面的两个问题。</p>\n<p>那么我们如果要知道全局关系是否确定，就需要提到后面的一个概念，全序关系广播</p>\n\n        <h3 id=\"全局关系的广播\"   >\n          <a href=\"#全局关系的广播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>全局关系的广播</h3>\n      <p>继续先从一个主从复制的系统开始说起，主节点接受写请求并且变成顺序的操作。<br>但是在分布式系统领域，如何扩展系统的吞吐量使之突破单一主节点限制以及处理主节点失效时的故障切换。这类的问题被称为全序关系广播或者原子广播。<br>全序关系广播： 通常指节点之间交换信息的某种协议。有两个特性<br>    1. 可靠发送（没有消息丢失，如果消息发送到某一个节点，它一定要发送到其他的节点）<br>    2. 严格有序（消息总是以相同的顺序发送到每个节点）  </p>\n\n        <h4 id=\"使用全序关系广播\"   >\n          <a href=\"#使用全序关系广播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用全序关系广播</h4>\n      <p>Zookeeper和Etcd的共识服务就实现了全序关系广播。（那么全序关系广播和共识之间的关系？）  </p>\n<p>全序关系广播就是数据库所需要，每条消息表达数据库的写请求，而且每个副本段相同的顺序处理这些写请求，那么所有副本可以保持一致。这个也被称为状态机复制。  </p>\n<p>全局关系广播的另一个要点，顺序在发送消息时已经是确定的，如果消息发送成功，节点不允许追溯将某条消息插到先前的位置上。只能进行追加，这样全序关系广播比时间戳的排序要求更强<br>应用场景：<br>    1.我们可以使用全序关系广播来实现可串行化的事务。（每个消息表示为一个确定性质的事务，并且作为存储过程来执行）<br>    2.提供Fencing令牌锁的服务（把取锁的请求变成一个消息追加到日志中，序列号直接可以变成令牌返回）  </p>\n\n        <h4 id=\"全序关系广播来实现线性化存储\"   >\n          <a href=\"#全序关系广播来实现线性化存储\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>全序关系广播来实现线性化存储</h4>\n      <p>全序关系广播是基于异步模型，保证消息以固定顺序的可靠发送，但是不保证消息何时发送成功，但是可线性化更多地强调读取时能看到最新的写入值。<br>我们可以通过追加的日志的方式使得使用全序关系广播在写入的方式上与可线性化做到一致<br>    1. 在接受请求的本地节点中追加一条消息，指明写入的信息<br>    2. 读取日志，广播到其他节点，等待回应<br>    3. 如果回复中有冲突，则失败，返回错误给客户端；否则返回成功给客户端<br>通过日志追加可以把并发有效的转换为多条的日志来保证因果顺序关系。但是读取却还没做到这个语义<br>为了读取可以与可线性化一致，有以下方法可以解决这个问题：<br>    1. 把读的请求也变成日志的方式追加到排序广播，通过变成日志的情况下可以确定了顺序的问题。（ETCD采用的是这种方式）<br>    2. 如果可以以可线性化的方式获取最新日志的消息位置，则查询位置，直到该位置之前的所有条目读发送给你，再进行读取（ZooKeeper使用的方式）<br>    3. 可以从同步更新的副本中进行读取，保证每次读的是最新的值。  </p>\n<p>所以最终可线性化的原子地对寄存器做CAS的操作与全序关系广播其实等价于共识的问题。</p>\n\n        <h1 id=\"分布式共识的能力边界\"   >\n          <a href=\"#分布式共识的能力边界\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识的能力边界</h1>\n      <p>共识： 使得分布式系统中就某件事情达成一致<br>共识的使用场景：<br>    1. 主节点选举（防止脑裂问题）<br>    2. 原子事务的提交（跨节点或分区的数据库，事务在部分节点成功，部分节点失败，需要进行回滚）<br>我们先从事务的原子性开始，讨论2PC（2阶段提交），之后再会谈及其他更好的共识算法的实现（ZooKeeper， Raft）  </p>\n\n        <h2 id=\"分布式事务\"   >\n          <a href=\"#分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式事务</h2>\n      <p>事务原子性的目的：<br>一个多笔写操作的事务在执行过程中出现意外情况，为上层应用提供一个简单的语义，全部成功或者全部失败<br>单机原子提交：<br>数据库把事务写入持久化部分，然后把提交记录追加写入到磁盘的日志文件中。所以在单节点上面，事务提交非常依赖与数据持久写入磁盘的顺序关系<br>    1. 先写入数据，再提交记录<br>    2. 事务提交或者中止的关键点在于磁盘完成日志的时候，在完成写之前崩溃的情况下，事务需要中止；如果日志在完成写入后发生崩溃，事务被安全提交  </p>\n<p>但是对于分布式多节点，处理方法有所差别，原因可能是以下这几个问题引起的<br>    1. 某些节点发现不满足要求中止了事务，但是部分节点通过并且提交<br>    2. 部分请求可能在网络不稳定的情况下丢失，超时而中止；但是其他请求可能成功提交<br>    3. 节点可能在写入日志前崩溃，而且在恢复后回滚（原来数据没有成功，回滚可能会出现问题）<br>如果一部分节点提交了事务，但是部分节点放弃了事务，会导致集群中节点信息的不一致，而且事务一旦被提交，即使事后发现其他节点中止，也无法撤销本节点的事务  </p>\n<p>事务提交后不能撤销的原因：<br>一旦数据提交，就会被其他事务可见，然后客户端（应用层）就会做出相应的反应，这个是构成读-提交隔离的基础。但是如果允许撤销的话，那么所有之后的读-提交级别的任务，然后会产生多级的级联式追溯和撤销。导致系统压力巨大甚至崩溃。并且不能保证数据是否能够准确落盘。  </p>\n<p>因为不允许撤销事务，因为如果一个错误的事务被提交了，必然需要一个新的事务来抵消它的影响，但是这个需要应用层来进行处理，就不符合我们需要给应用层提供的原子性。  </p>\n\n        <h3 id=\"2PC\"   >\n          <a href=\"#2PC\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2PC</h3>\n      <p>两阶段提交（2PC）是一种在多个节点上实现事务原子提交的算法。要么全部提交，要么全部不提交。</p>\n\n        <h5 id=\"2PC的流程（为什么可以解决上面单阶段提交的问题）\"   >\n          <a href=\"#2PC的流程（为什么可以解决上面单阶段提交的问题）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2PC的流程（为什么可以解决上面单阶段提交的问题）</h5>\n      <ol>\n<li>应用启动分布式事务的时候，先去像协调者获取事务ID（全局唯一）</li>\n<li>应用程序在每个参与的节点启动单节点事务，并且把事务ID附加到到参与者的事务上。如果这个阶段发生异常，可以协调者和其他参与者可以安全中止</li>\n<li>应用程序准备提交事务时，协调者回向参与者发送携带事务ID准备请求，只要有一个发现失败的情况下，通知全部放弃事务</li>\n<li>参与者收到请求后，确保自己时候可以提交事务（包括硬件故障和软件故障的确认），然后检查是否有冲突或者违规。一旦返回是，节点会承诺提交事务。（保证了参与者不会撤销事务）</li>\n<li>当协调者收到所有的参与者返回后，要决定是否提交事务，并且把此决定写入到硬盘的事务日志（WAL）中，防止掉电后可能出现的异常</li>\n<li>协调者向参与者发送提交/放弃 事物的请求，只要是提交，每个参与者会重试到成功为止(包括了进程崩溃的重试、节点重启等情况)</li>\n</ol>\n<p>所以他是在保证了上面的一个重要前提，只要提交了就不能撤回。<br>在参与者在返回给协调者的时候保证了单向性<br>并且协调者确定提交了之后也是保证了不可逆，因此保证了2pc可以不会出现那些异常的情况。</p>\n<p>但是2PC的单点在于协调者的问题（虽然可以采用共识层来写协调者保证高可用）但是整个过程中的热点也会出现在协调者上面。</p>\n\n        <h3 id=\"实际生产上面的分布式事务\"   >\n          <a href=\"#实际生产上面的分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实际生产上面的分布式事务</h3>\n      \n        <h3 id=\"异构分布式事务\"   >\n          <a href=\"#异构分布式事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>异构分布式事务</h3>\n      <p>虽然分布式事务因为这样可能会有阻塞而导致性能和吞吐量的下降，但是是否没有折中的方法来使用类似的语义呢？<br>目前更多的是采用了异构的方法（如数据库+MQ）的执行异构的分布式事务</p>\n<p>对于异构形式的分布式事务，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息处理完毕。<br>但只要其中一个出现失败的情况，两个部分都必须进行中止的操作。</p>\n<p><b>保证消息可以有效处理有且仅有一次</b></p>\n<p>目前有XA的异构的分布式事务的标准。</p>\n\n        <h2 id=\"支持容错的共识\"   >\n          <a href=\"#支持容错的共识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>支持容错的共识</h2>\n      <p>共识问题的形式化描述： 一个或者多个节点可以提议某些值，由共识算法来决定最终的值。</p>\n<p>基于上面的描述共识算法必须满足以下的性质：<br>    1. 协商一致性（所有节点都接受相同的决议）<br>    2. 诚实性（所有节点不能反悔，对某项提议不能有两次决定）<br>    3. 合法性（决定了值V, 那么V肯定是由某个节点提议的）<br>    4. 可终止性（如果节点不崩溃最终一定可以达成协议）</p>\n<p>协商一致性和诚实的属性定义了共识算法的核心思想：决定一致的结果，并且一旦决定就不能改变。<br>合法性是为了排除一些无意义的方案，<br>可终止性是容错的体现，避免了整个系统的空转<br>根据之前提及的： 可终止性是活性， 其他三个是安全方面的属性。</p>\n<p>因为共识算法的目的是解决在大多数节点正常的情况下正确运行才能确保终止性。</p>\n\n        <h3 id=\"共识算法和全序广播的关系\"   >\n          <a href=\"#共识算法和全序广播的关系\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识算法和全序广播的关系</h3>\n      <p>共识算法(如Raft、Paxos、Zab)等都不是直接采用上述的形式化模型。而是决定了一系列的值，然后采用全序关系广播算法来进行实现。  </p>\n<p>全序关系广播要点： 消息按相同的顺序发送到所有的节点，有且只有一次。<br>这样的方式相当于多轮的共识过程。在每一轮，节点会提出之后需要发出的信息，然后决定下一个顺序。</p>\n<p>对于上面的提到的四个性质：</p>\n<ol>\n<li>由于协商的一致性，所有节点决定以相同的顺序发送相同的消息。</li>\n<li>由于诚实性，消息不会重复</li>\n<li>由于合法性， 消息不会被破坏，也不是凭空捏造</li>\n<li>由于可终止性，消息不会丢失</li>\n</ol>\n\n        <h3 id=\"Epoch-和-Quorum\"   >\n          <a href=\"#Epoch-和-Quorum\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Epoch 和 Quorum</h3>\n      <p>对于共识算法来说，都采用了一个弱化的保证，定义了一个世代编号（Epoch）来确保每个世代里面，主节点是唯一的。<br>如果发现当前主节点失效的情况，节点开始选举新一轮的主节点，Epoch号递增。在主节点做出任何决定的时候，都需要检查是否由比它更高的Epoch号码。<br>主节点必须从Quorum中收集投票，并且把提议传送到各个节点中，等待节点的返回，当只要没有更高的Epoch主节点<br>时，才会对当前的提议进行投票。</p>\n<p>此处其实是由两个操作组成：1. 选举主节点； 2.对主节点的提议进行投票</p>\n<p>注意的一点： 参与两轮的Quorum必须要由重合，这样才能保证主节点没有更高的Epoch，保证正确性。</p>\n<p>与2PC的差别， 2PC是需要协调者向每个参与者做出“是”的返回才能进行，而共识算法可以通过直接以集群的多数来确定是否通过决议</p>\n\n        <h3 id=\"共识算法的局限性\"   >\n          <a href=\"#共识算法的局限性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>共识算法的局限性</h3>\n      <p>共识算法虽然为分布式系统带来了好处，为一切不确定的系统带来了安全属性和容错性。并且可以通过全序关系广播以容错的方式实现线性化的原子操作。</p>\n<p>但是共识也是有代价的：</p>\n<ol>\n<li>节点投票是一个同步复制过程，性能可能需要妥协（但是可以通过减少选举的频率来减少整个开销）</li>\n<li>共识体系需要严格的多数节点才能执行，换句话来说，最少需要3个节点才能运行</li>\n<li>多数的共识算法假定了一组固定的参与投票的节点集（主要是为了理解的方便）</li>\n<li>共识算法需要依靠超时来对节点失败进行检测，但是可能会出现因为网络原因的误判导致经常切主，数据搬移多，对外的性能降低。</li>\n<li>网络的影响较大，如果出现频繁切主的情况，可能会有长时间出现无法正常对外进行服务</li>\n</ol>\n\n        <h3 id=\"基于共识算法的成员与协调服务\"   >\n          <a href=\"#基于共识算法的成员与协调服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基于共识算法的成员与协调服务</h3>\n      <p>对于像ZooKeeper、Etcd这些分布式键值对的服务，暴露的API与数据库是十分类似的，但是为什么我们需要在共识层上面去构建这些服务呢？</p>\n\n        <h4 id=\"作用\"   >\n          <a href=\"#作用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>作用</h4>\n      <p>这些分布式键值对数据库主要是针对保存少量，可完全载入内存的数据。采用容错的全序广播算法在所有节点上复制数据使得可以实现高可用的目标。</p>\n<ol>\n<li>线性化的原子操作<br>多个节点同时去获取锁，只有一个会成功，共识协议会保证操作满足原子性和线性化，即使节点出现部分失败的情况</li>\n<li>操作全序<br>之前分布式系统问题的文章有提及过Fencing令牌的问题，</li>\n<li>故障检测<br>客户端会与这些服务保持一个长连接，如果长时间重连失败的情况下，会把该客户端拥有的资源全部释放</li>\n<li>更改通知<br>客户端可以通过读取服务来发现其他的客户端的行为</li>\n</ol>\n\n        <h4 id=\"对外的功能\"   >\n          <a href=\"#对外的功能\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对外的功能</h4>\n      <ol>\n<li>节点任务分配<br>计算作业调度系统(Yarn)，分区资源调度（如Multi-Raft中的ShardMaster)</li>\n<li>服务发现<br>解决云环境中服务启停而注册到的服务变更(consul提供的服务)</li>\n<li>成员服务<br>节点是否可用并且获取主节点</li>\n</ol>\n\n        <h3 id=\"如何验证一个线性化系统\"   >\n          <a href=\"#如何验证一个线性化系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何验证一个线性化系统</h3>\n      <p>（此部分会结合Mit6.824和PingCap tikv 的线性化验证的代码阅读和文章来描述）</p>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://pdos.csail.mit.edu/6.824/papers/dynamo.pdf\" >Dynamo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/basho/riak_core\" >Riak</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://cassandra.apache.org/\" >Cassandra</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://book.douban.com/subject/30329536/\" >数据密集型应用系统设计</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n"},{"title":"分布式系统概念简介及其问题的描述","date":"2019-08-21T13:07:38.000Z","_content":"\n<!-- ---\n\nauthor: Ray Chan(ray1888)\ndate: 2019-08-20 11:07:38\ncategory: \nsummary: introduction of distributed system and its problem\nthumbnail: distributed-system.png\n--- -->\n\n# 目录 \n1. [什么是分布式系统](#Introduction)  \n2. [分布式系统能够解决什么问题](#Purpose)  \n   2.1 [服务器的性能扩展方案](#2.1)  \n   2.2 [分布式系统的特点](#2.2)  \n   2.3 [分布式系统解决的问题](#2.3)  \n3. [分布式系统的问题](#Problem)  \n   3.1 [网络问题](#3.1)  \n   3.2 [时钟问题](#3.2)  \n   3.3 [节点问题](#3.3)  \n4. [在不可靠硬件构建可靠软件需要满足的条件和假设](#ConditionAssumtion)  \n   4.1 [真相由多数决定](#4.1)  \n   4.2 [理论系统模型与现实](#4.2)  \n5. [ShareNote](#ShareNote)  \n\n\n# <a id=\"Introduction\"><span class=\"toptitle\">#什么是分布式系统</span></a>\n\n### 分布式系统\n\n```\n// Definantion from IBM Site \nA distributed computer system consists of multiple software components that are on multiple computers, but run as a single system. The computers that are in a distributed \nsystem can be physically close together and connected by a local network, or they can be geographically distant and connected by a wide area network. A distributed system can consist of any number of possible configurations, such as mainframes, personal computers, workstations, minicomputers, and so on. The goal of distributed computing is to make such a network work as a single computer.\n```\n\n简述：\n分布式的计算机系统是由多台形式的计算机（包括服务器、个人电脑、工作站、嵌入式系统的形式）组成的，但是对外表示成一个完整功能的系统。对于分布式系统的使用者，可以把一个大型的分布式系统看作一个黑盒来进行使用。  \n\n# <a id=\"Purpose\"><span class=\"toptitle\">#分布式系统能够解决什么问题</span></a>\n\n###  <a id=\"2.1\"><span class=\"secondtitle\">2.1. 服务器的性能扩展方案</span></a>\n\n对于一个系统来说，如果当需要计算的问题太过庞大的时候，会有两种思路来进行算力的添加  \n\n1.Scale UP（纵向扩展）  \n纵向扩展:企业后端大型服务器以增加处理器等运算资源进行升级以获得对应用性能的要求。\n这种是比较传统的思路，具有以下特点：  \n    1. 扩容的成本较高。能够支持纵向扩展的系统都需要服务商进行服务的支持，需要购买特殊的硬件。而不是使用能够通用的硬件来进行扩容  \n    2. 延迟低，单点吞吐量大。本质上是单点的系统，可以减少了很多网络上面的开销，所以延迟一般会比分布式系统的延迟更低。而且单节点如果在没有超过负荷的情况下，因为硬件堆积在上面，单节点的性能一般会比分布式的单节点性能更强。  \n    3. 备份成本高，遇到不可恢复的故障时可能要中断一定时间的服务。如果对于纵向扩展的设备需要进行灾备的情况下，可能需要同时购入相同配置的硬件通过配置主备来继续容灾，而不能通过像分布式系统在多个地域继续节点部署和配置添加达到冗余的程度。  \n  实例的系统： 传统的SAN(storage area network)系统  \n\n2.Scale Out(水平扩展)  \n水平扩展：企业可以根据需求增加不同的服务器应用，依靠多部服务器协同运算，借负载平衡及容错等功能来提高运算能力及可靠度。  \n这是从谷歌的三篇经典的分布式论文（bigtable、distributed filesystem、 mapreduce)提炼出来的特点：  \n    1. 成本低，扩展性好。使用的是市面上可以购买的通用的服务器配件，并且可以根据需求进行硬件的升级即可提升整体的性能（如存储服务器上面，把HDD更换为全闪存的NVME SSD，立刻可以在读写的吞吐量和时延上面获得具体的提升）  \n    2. 弹性好。可以通过配置动态的增删服务器，可以动态的对业务使用的服务器资源具有更好的调配，并且可以通过弹性的配置获得根据地理位置的容灾以及数据冗余功能（如金融企业中的两地三中心的需求）  \n    3. 处理单节点无法处理的问题。（最重要）  \n\n### <a id=\"2.2\"><span class=\"secondtitle\">2.2 分布式系统的特点</span></a>\n1. 扩展性强(Scalability)  \n2. 有冗余(Redundancy)  \n\n### <a id=\"2.3\"><span class=\"secondtitle\">2.3 分布式系统解决的问题</span></a>\n分布式系统最重要解决的问题是：  \n1. 处理单机无法计算的问题。  \n因为问题能够被分治成为了更小的问题，使得更弱的节点也可以进行计算  \n2. 同样的工作量下，减少计算使用的时间。  \n因为部分计算是可以并行来继续执行的，只要调度得当的情况下，可以减少单机系统中出现的等待的情况。  \n3. 在有限的成本内，可以通过多区域部署服务来降低该地区的服务的时延。  \n\n\n# <a id=\"Problem\"><span class=\"toptitle\">分布式系统的问题</span></a>\n（此部分有部分会引用到数据密集型应用系统设计（DDIA）的第8章部分的内容）  \n软件工程的世界里面没有银弹，分布式系统并不是所有问题的最优解。它在解决上述问题的情况下也引入了下面的多种问题    \n此处需要引入一个部分失效的概念：  \n```\n部分失效：在分布式系统中，可能会出现系统的一部分工作正常，其他部分出现难以预测的故障。\n```\n\n### 对于互联网服务的分布式系统的假设\n1. 需要7*24的可用状况，所以不能有服务不可用的状态\n2. 采用通用的硬件，故障率会较高，成本较低\n3. 采用IP和以太网的技术，网络可靠性不如专有网络(Fiber Channel等。。。)\n\n因为上面的三个原因可能引申出来的另外的假设  \n\n4. 系统越大，局部组件失效的概率越大。（长时间的运行时间，失效、修复、再失效是正常的状况而不能当为异常的情况去考虑）\n5. 由于局部失效的概率高，因此需要必须容忍部分节点失败，并且能够保持对外提供可用的服务\n\n<b><font color=\"#FF0000\">所以实际上我们目前大部分的分布式的系统是需要在不可靠的硬件上面通过软件容错来构建可靠的系统。</font></b>\n\n### <strong><font color=\"#FF0000\">所以分布式系统遇到的问题可以分为三个大类</font></strong>\n1. 网络类问题  \n2. 时钟问题  \n3. 节点软件和硬件的问题  \n\n## <a id=\"3.1\"><span class=\"secondtitle\">网络问题</span></a>\n对于上面的假设（主要是成本考虑）来说，一般都会采用无共享的方式来构建集群。\n\n由于通常使用的都是以太网来构建，而且以太网是异步的网络。可能会出现下面的这些情况\n1. 请求丢失  \n2. 请求再队列等待，无法发送（网络问题或者接收方繁忙在内核的队列中等待）  \n3. 远程接收节点失效（节点崩溃）  \n4. 远程节点无法响应  \n5. 远程节点有返回，但是返回过程中丢失  \n6. 远程节点处理请求，但是在返回时候被延时处理（优先级问题， 或者网络问题或则和发送方阻塞了）  \n\n\n此处需要多引入一个新概念，网络分区\n```\n网络分区（Network Partition）：当网络的一部分由于网络故障而与其他部分隔开，称之为网络分区或者网络分片\n```\n\n在工程的实践中，网络故障(丢包、链路中断、路由问题、物理设备损坏)的概率是远比想象中高， 因此在基于我们假设的前提的环境下面，必须要把网络分区和网络故障接入到软件中进行容错。\n\n对于如何处理检测是否故障，需要判断的一个问题是，是节点服务上面出现了真实的故障，还是网络的不可靠导致的服务失效的表现。\n```\n在实际生产的实践中有这样的方法来快速的在本应用层（网络正常的情况下）来进行简单的判断\n1. 通过服务注册的心跳来注册自己的服务存活，并且把死亡状态的服务实例剔除出可用服务中\n2. 检测进程是否崩溃，如果崩溃发送一个信号。（或者在我的工作经历中，使用一个进程去定时检测进程是否存活，失败了发送信号使得资源进行重启的尝试，并且上报告警）\n3. 通过交换机去查询网络的状况\n4. 通过中间件的自身监控（如Rabbitmq的web界面）来监控中间件的执行状况\n5. 定期去尝试访问网络是否通达\n```\n但是最终我们唯一能够完全判断故障的方法只有超时，来保证节点是不可用的状态（为了保证网络的不可靠问题）。\n\n### 超时引入的问题\n我们如何能够判断什么时候才是最好的超时的判断间隔呢？\n\n对于上面的这个问题， 我们引入两个问题的前置的讨论  \n1. 是什么导致我们会出现网络的不稳定  \n2. 如果出现超时之后，会有怎样的影响，会导致什么样的后果  \n\n#### 网络不稳定的原因\n根本的原因： 在设计目前的TCP/IP的协议和方法的时候，我们的目的是为了尽可能高的提高资源的利用率  \n设计的思想： 通过动态分配和竞争的机制使得动态决定那个包被发送，但是这样的方法必然会引入排队的机制  \n\n```\n// 出现网络不稳定的原因可能如下\n1. 对于交换机的角度，会有多条等待队列来进行数据报文的转发，如果符合过重，则需要等待轮询机制来等待发送的机会，并且如果数据量过多的情况下，也有可能出现数据报文被丢弃，然后被不断重试的现象\n2. 在服务器的处理中，因为Linux内核处理接收到的报文也是类似于交换机的处理模式，通过队列来对接受到的包进行排序以及复制到用户态，因此也是需要一定的时间需要处理\n3. 在TCP的协议中的重传的机制也会根据返回的报文的控制字段来减小发送窗口的大小来减少对接受方的压力，可能导致排队会提前到发送方的等待队列中。并且重传机制会进行多次的重试，引入了隐形的超时时间\n```\n\n#### 调用超时（网络超时）可能会导致的后果\n主要的影响是发生了责任的转移，可能带来可能的影响  \n1. 命令的重复执行  \n2. 数据迁移  \n3. 当整个系统处于高负荷的状态，可能会把其他正常的部分通过转移职责导致整个系统被拖垮  \n\n因此我们必须很小心调整这个超时的阈值,如果在以前的情况下，可能需要系统管理员对于在生产环境的情况下调整一定的参数来慢慢测试得出一个最优值。\n但是在最近的组建的实现中有两种新的思路\n```\n1. 通过内部的一个故障检测器来计算成功率来进行对超时阈值的控制（Akka， Cassandra， Hytrsix中有使用此种方法）\n2. 通过对数据的采集清洗和分析（AIOPS）（可能是APM(Application Performance Metric)的埋点采集数据以及对监控数据的整体清洗通过一些机器学习的模型来计算出超时的阈值）\n```\n\n## <a id=\"3.2\"><span class=\"secondtitle\">时钟问题</span></a>\n分布式的系统的时钟问题也是一个非常值得重视的问题，后面会有我自己的工作案例来说明可能出现的情况的严重性。\n\n其实对于时间我们一般分为两种的应用方式\n1. 在一段时间内的统计数据（时间段）\n2. 某些时间点是否有指定动作完成或某个历史行为的发生的时间点\n\n### 服务器时间的维护方式以及问题\n每个机器的时间可以通过两种方式来共同维护\n1. 本地时间（通过主板的石英振荡器来维护）\n2. 通过与一个准确的时间获取源来定是同步时间（NTP和Chrony就是服务于方面的协议）\n\n这两种的结合不一定能够保证这样的可信赖的分布式集群中的时间就必然是同步的\n1. 本地时间本来每个节点都可能会出现偏差\n2. 同步时间的时候必须通过网络来进行同步，而在我们上面提及的假设中，网络是不可靠的，因此可能会出现失败的情况。 \n3. NTP如果发现时间差别太大（实际生产中是时间差>=10分钟的情况下）的话会拒绝同步（但是Chrony并没有此问题）\n4. 闰秒的问题\n\n当然可以像Google维护Spanner集群那样采用高精度的原子钟加上GPS定位来保证错误在一定的可接受范围内运行（一般误差的单位为5微妙）。但是不是每个分布式系统都能够有如此之高的维护成本去使用这种方式来\n\n### 时钟的概念\n\n时钟可以分解为两个时钟的概念\n1. 物理时钟\n物理时钟:包括了两种一个是墙上时钟，一个是单调时钟。可以理解为可以通过系统时间相关的API进行获取的时钟。\n2. 逻辑时钟\n逻辑时钟：可以理解为分布式系统中全局的单调递增的事件ID，事件发生顺序与此相同。\n\n#### 物理时钟\n需要先引入一个时间调整的概念：\n<!-- ![时间跳变说明图](/assets/img/posts/TimeJump.png)   -->\n{% asset_img TimeJump.png 时间跳变说明图 %}\n如果把时间以时间轴的方式来进行表达，往时间变大的方向调整为向前调整，往时间变小的方向调整的是向后调整。\n只要发生了时间的变动，我们都可以称之为服务器发生了时间跳变。\n\n<b><font color=\"\">1. 墙上时钟 </font> </b><br>\n根据日历返回当前的时钟，就是我们平时在Linux上直接使用date命令或者语言内置的时间相关的api的输出。\n这种时钟可以与时间同步服务器后同步后进行修改，可能会出现向前调整或者向后调整的可能性\n\n<b><font color=\"\">2. 单调时钟</font></b><br>\n用于： 适合测量持续的时间段    \n单调时钟的特性：    \n    1. 保证只会向前调整    \n    2. 不需要进行同步    \n\n#### 计算和调整的方式\n在一个时间点进行对单调时间的获取，然后完成某项工作后，再去检查时间。但是这段时间的差值并没有太大的意义。\n\n#### 时间与事件的顺序问题\n\n当两个客户端对于一个分布式的数据库（非Raft或者Paxos类型，如Riak）分别进行写入的情况下（此处假设先写入的客户端为A，晚写入的客户端为B）  \n<!-- ![事件与时序冲突](/assets/img/posts/Time&EventMissmatch.png) -->\n{% asset_img Time&EventMissmatch.png 事件与时序冲突 %}\n当B虽然在发生的时间比A要晚，但是B在集群中同步完成的时间比A要早的情况写。即对外部来说A还未写入成功的情况下，先执行了B的操作，可能导致B的操作丢失（如果B的操作是依赖于A先写入的操作）。  \n上面是一个非常经典的关于分布式集群时间与事件的顺序问题。然而这种问题即使在时间同步服务精度再再提高的情况下，也无法保证它的执行的顺序与时间是一致的。  \n\n#### 工作上发生过与物理时间相关的问题\n\n<b>问题1： 发生时间跳变后，导致任务的调度器不再调度任务的情况  </b>  \n<!-- ![调度器时间跳变问题](/assets/img/posts/SchdulerTimeJump.png)   -->\n{% asset_img SchdulerTimeJump.png 调度器时间跳变问题 %}\n    现象的描述： \n    调度器默认应该定时把任务调度到线程上面，但是查看日志后发现任务并没有被调度   \n    原因解释：    \n    时间发生了向后的跳变，但是跳变的幅度大于调度的间隔，导致系统中认为调度成功，之后就没有追踪下面的状态（因为当时那部分代码的实现是再调度的时候修改调度的时间为last调度时间）    \n    解决方法：    \n    把时间从墙上时间更换为单调时间，然后添加检查执行的间隔即可。  \n  \n<b>问题2：同步时间后，由于时间差溢出导致结果溢出的问题  </b><br>\n    现象描述：    \n    从Ceph Mgr获取单个采集数据的情况下，然后发现数据变得异常的大，是一个int64是随机数  \n    原因解释：  \n    因为采用的是墙上的时候，但是发生了时间的向后调变，导致计算出来的值发生异常  \n    解决方法：  \n    把墙上时间更换为单调时间  \n\n#### 逻辑时钟\n做法： 需要一个全局的单调递增的ID。\n但是是否可以使用同步后的时间来做呢？\n答： 不可以。因为还是时间精度的不确定性。\n\n## <a id=\"3.3\"><span class=\"secondtitle\">节点本身的问题（硬件和软件）</span></a>\n比较极端但是可能出现率比较高的场景是进程出现暂停的情况\n\n1. 带GC的编程语言的GC(Garbage collection) halt\n2. 虚拟化环境的虚拟机的暂停\n3. 电脑发生休眠或者断电\n4. 上下文切换的情况下卡住了\n5. 执行同步磁盘的操作的时候（如fsync操作）\n6. 接收到信号导致进程退出的情况下\n\n# <a id=\"ConditionAssumtion\"><span class=\"toptitle\">#在不可靠硬件构建可靠软件需要满足的条件和假设</span></a>\n\n此部分为DDIA第8章的描述总结，可以理解成为读书笔记    \n\n## <a id=\"4.1\"><span class=\"secondtitle\">真相由多数决定（重要的判定条件）</span></a>\n节点不能通过自己的信息来判断自身的状态。因为节点可能出现失效、假死、甚至无法恢复的状况.可能出现的场景如下\n```\n1. 节点成功收到请求，但是因为路由问题，无法进行返回，超时后而被判失效\n2. 半断开的节点发现自己的信息没有被其他节点所确认，意识到自己网络出现问题\n3. GC halt导致无法接受请求，但是对于应用来说，切回到工作状态时候，自身状态没有变化\n```\n以上的多种情景都是实际出现问题，但是自身的状态并不会改变，因为没有收到其他节点的通知，它会一直维持原来的状态。    \n所以分布式的算法依赖节点间的相互投票与最小投票数（使用Quorum机制，m>=(n+1)/2）进行对比来产生结果,由于一个集群不会存在两个多数在同事做出相互冲突的决定，减少对特定节点的依赖。\n\n基于上面所提及节点不能通过自己的信息来判断自己的状态，我们讨论一个比较常见的问题，主节点与锁是比较常见的使用方法\n```\n可能的出现的场景\n1. 只允许一个节点作为数据库分区的主节点（Multi-Raft是其中的一种实现）\n2. 只允许一个事务或者客户端持有特定资源的锁，以防止同时并发写入带来的数据被破坏的问题\n```\n\n### <span class=\"thirdtitle\">如果由自己的状态决定可能会出现的问题</span>\n但是此处我们的假设时在分布式系统中，那么有可能出现节点中间出现了角色的切换，但是如果不加以对状态的判断，可能会出现这样的问题\n问题描述  \n<!-- ![客户端锁问题](/assets/img/posts/lockingproblem.png)   -->\n{% asset_img lockingproblem.png 客户端锁问题 %}\n客户端写入存储的时候需要先从分布式服务中获取锁，有两个客户端在线，客户端A先从服务中获取锁，然后发生了进程halt状态（可能是GC或者其他的原因）\n如果不加判断的情况下，在客户端A halt的状态的情况下，客户端B获得锁并且写入存储成功，然后客户端A从Halt状态中回复正常，客户端A认为锁还在，然后写入存储，\n如果两个客户端写入的是同一个文件的话，数据可能会出现问题。  \n### <span class=\"thirdtitle\">解决上面的问题</span>\n对于上面的问题，我们可以使用一个Fencing令牌来解决这个问题。(此机制到后面的文章还会继续详细讲解)  \n<!-- ![Fencing令牌解决锁问题](/assets/img/posts/lockingproblem2.png)   -->\n{% asset_img lockingproblem2.png Fencing令牌解决锁问题 %}\n我们在客户端A获取锁的时候给令牌赋予一个值，为33。 在客户端B获取锁的时候赋予一个令牌值34。  \n当B写入完成后，存储会把已写入令牌改为34，下一次分发的令牌为35， 这样的话，如果A带上33的令牌写入的时候直接被拒绝，能够保证一致性。  \n实际上上面这种方法不仅加上了一个令牌，而且在服务器端会有一个关于令牌的校验。这种做法非常常见。\n\n\n## <a id=\"4.2\"><span class=\"secondtitle\">理论系统模型与现实</span></a>\n对于一个在现实中能够容错的分布式系统，我们需要对预期的系统错误证明形式化的描述。我们通过定义部分的系统模型来形式化描述算法的前提条件。 \n\n<h3><b><span class=\"thirdtitle\">计时模型</span></b></h3>\n#### 同步模型\n假定有上界网络延迟和上界进程的暂停和上界时钟误差。（但是这个模型一般不存在，因为以太网的不可靠性，除非使用更加稳定的网络介质，并且使用高精度时间设备同步）\n#### 部分同步模型\n大多数情况下像一个同步系统运行，但是会有超出网络延迟，进程暂停和时钟漂移的上界。这个就是比较现实的模型，就是上面我们提到的真实环境可能出现的情况的总和。而且大部分时间比较稳定，小部分时间会有背离，但是发生背离就会出现三者中的组合的情况出现。\n#### 异步模型\n\n\n<h3><b><span class=\"thirdtitle\">节点失效模型</span></b></h3>\n#### 崩溃-中止模型\n节点以一种特定的方式发生故障，故障后，出现系统崩溃，并且节点不会再添加进入集群中，无法恢复\n#### 崩溃-恢复模型\n节点可能会在任何时候发生崩溃，并且会在未知的时间长度来进行恢复。但是节点上只要持久性存储的数据都可以在恢复之后得以保存，内存的状态会消失。\n#### 拜占庭失效\n在非可信任的集群中进行共识的计算，可能会出现作弊、欺诈的操作（区块链上面的假设的环境）  \n所以满足我们实际生产环境（互联网或者企业内部的环境）的是 部分同步模型+ 崩溃恢复模型的组合。\n\n我们目前的分布式的环境是 崩溃-恢复模型+ 部分同步的模型 \n\n### <span class=\"thirdtitle\">分布式共识算法的正确性必须要有以下的性质</span>\n1. 唯一性  \n两个令牌不能获得相同的值  \n2. 单调递增  \n如果请求x返回令牌tx， 请求y返回了令牌ty, 且x在y开始之前先完成，tx < ty  \n3. 可用性  \n请求令牌的节点如果不发生崩溃最终一定能收到响应（无论是对应用来说正确或者错误的回答）  \n\n#### 分布式共识算法的安全性和活性\n在正确性中其实可以再进行细分分为安全性和活性（理解上，并非准确的定义，准确的定义可以查看FLP的理论）：  \n安全性： 没有发生意外  \n活性： 预期的事情一定会发生（最终会发生）  \n\n如果违反了安全的属性，我们可以找到发生特定时间的时间点。但是违反安全属性的事件发生，必定不可逆，数据丢失。  \n活性的话无法明确具体发生的时间点，但是希望再未来某个时间点能够达到要求。  \n\n# <a id=\"ShareNote\"><span class=\"toptitle\">ShareNote</span></a>\nPS: 文章中部分的图来源是来自于《数据密集型应用系统设计》，为PDF翻译的截图，截图的引用在[此处](https://github.com/hyhlinux/DDIA/blob/master/ch8.md)。如果涉及到版权的问题，请通知我，我会使用工具继续重画。\n1. [IBM Defination of Distributed System](https://www.ibm.com/support/knowledgecenter/en/SSAL2T_8.2.0/com.ibm.cics.tx.doc/concepts/c_wht_is_distd_comptg.html)\n2. [数据密集型应用系统设计](https://book.douban.com/subject/30329536/)\n3. [FLP Impossibility](https://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/)\n4. [拜占庭错误](https://en.wikipedia.org/wiki/Byzantine_fault)\n5. [拜占庭容错](https://www.usenix.org/legacy/events/osdi99/full_papers/castro/castro_html/castro.html)\n6. [Riak](https://github.com/basho/riak_core)","source":"_posts/intro-distributed-system.md","raw":"---\ntitle: 分布式系统概念简介及其问题的描述\ndate: 2019-08-21 21:07:38\ntags: distributed-system\n---\n\n<!-- ---\n\nauthor: Ray Chan(ray1888)\ndate: 2019-08-20 11:07:38\ncategory: \nsummary: introduction of distributed system and its problem\nthumbnail: distributed-system.png\n--- -->\n\n# 目录 \n1. [什么是分布式系统](#Introduction)  \n2. [分布式系统能够解决什么问题](#Purpose)  \n   2.1 [服务器的性能扩展方案](#2.1)  \n   2.2 [分布式系统的特点](#2.2)  \n   2.3 [分布式系统解决的问题](#2.3)  \n3. [分布式系统的问题](#Problem)  \n   3.1 [网络问题](#3.1)  \n   3.2 [时钟问题](#3.2)  \n   3.3 [节点问题](#3.3)  \n4. [在不可靠硬件构建可靠软件需要满足的条件和假设](#ConditionAssumtion)  \n   4.1 [真相由多数决定](#4.1)  \n   4.2 [理论系统模型与现实](#4.2)  \n5. [ShareNote](#ShareNote)  \n\n\n# <a id=\"Introduction\"><span class=\"toptitle\">#什么是分布式系统</span></a>\n\n### 分布式系统\n\n```\n// Definantion from IBM Site \nA distributed computer system consists of multiple software components that are on multiple computers, but run as a single system. The computers that are in a distributed \nsystem can be physically close together and connected by a local network, or they can be geographically distant and connected by a wide area network. A distributed system can consist of any number of possible configurations, such as mainframes, personal computers, workstations, minicomputers, and so on. The goal of distributed computing is to make such a network work as a single computer.\n```\n\n简述：\n分布式的计算机系统是由多台形式的计算机（包括服务器、个人电脑、工作站、嵌入式系统的形式）组成的，但是对外表示成一个完整功能的系统。对于分布式系统的使用者，可以把一个大型的分布式系统看作一个黑盒来进行使用。  \n\n# <a id=\"Purpose\"><span class=\"toptitle\">#分布式系统能够解决什么问题</span></a>\n\n###  <a id=\"2.1\"><span class=\"secondtitle\">2.1. 服务器的性能扩展方案</span></a>\n\n对于一个系统来说，如果当需要计算的问题太过庞大的时候，会有两种思路来进行算力的添加  \n\n1.Scale UP（纵向扩展）  \n纵向扩展:企业后端大型服务器以增加处理器等运算资源进行升级以获得对应用性能的要求。\n这种是比较传统的思路，具有以下特点：  \n    1. 扩容的成本较高。能够支持纵向扩展的系统都需要服务商进行服务的支持，需要购买特殊的硬件。而不是使用能够通用的硬件来进行扩容  \n    2. 延迟低，单点吞吐量大。本质上是单点的系统，可以减少了很多网络上面的开销，所以延迟一般会比分布式系统的延迟更低。而且单节点如果在没有超过负荷的情况下，因为硬件堆积在上面，单节点的性能一般会比分布式的单节点性能更强。  \n    3. 备份成本高，遇到不可恢复的故障时可能要中断一定时间的服务。如果对于纵向扩展的设备需要进行灾备的情况下，可能需要同时购入相同配置的硬件通过配置主备来继续容灾，而不能通过像分布式系统在多个地域继续节点部署和配置添加达到冗余的程度。  \n  实例的系统： 传统的SAN(storage area network)系统  \n\n2.Scale Out(水平扩展)  \n水平扩展：企业可以根据需求增加不同的服务器应用，依靠多部服务器协同运算，借负载平衡及容错等功能来提高运算能力及可靠度。  \n这是从谷歌的三篇经典的分布式论文（bigtable、distributed filesystem、 mapreduce)提炼出来的特点：  \n    1. 成本低，扩展性好。使用的是市面上可以购买的通用的服务器配件，并且可以根据需求进行硬件的升级即可提升整体的性能（如存储服务器上面，把HDD更换为全闪存的NVME SSD，立刻可以在读写的吞吐量和时延上面获得具体的提升）  \n    2. 弹性好。可以通过配置动态的增删服务器，可以动态的对业务使用的服务器资源具有更好的调配，并且可以通过弹性的配置获得根据地理位置的容灾以及数据冗余功能（如金融企业中的两地三中心的需求）  \n    3. 处理单节点无法处理的问题。（最重要）  \n\n### <a id=\"2.2\"><span class=\"secondtitle\">2.2 分布式系统的特点</span></a>\n1. 扩展性强(Scalability)  \n2. 有冗余(Redundancy)  \n\n### <a id=\"2.3\"><span class=\"secondtitle\">2.3 分布式系统解决的问题</span></a>\n分布式系统最重要解决的问题是：  \n1. 处理单机无法计算的问题。  \n因为问题能够被分治成为了更小的问题，使得更弱的节点也可以进行计算  \n2. 同样的工作量下，减少计算使用的时间。  \n因为部分计算是可以并行来继续执行的，只要调度得当的情况下，可以减少单机系统中出现的等待的情况。  \n3. 在有限的成本内，可以通过多区域部署服务来降低该地区的服务的时延。  \n\n\n# <a id=\"Problem\"><span class=\"toptitle\">分布式系统的问题</span></a>\n（此部分有部分会引用到数据密集型应用系统设计（DDIA）的第8章部分的内容）  \n软件工程的世界里面没有银弹，分布式系统并不是所有问题的最优解。它在解决上述问题的情况下也引入了下面的多种问题    \n此处需要引入一个部分失效的概念：  \n```\n部分失效：在分布式系统中，可能会出现系统的一部分工作正常，其他部分出现难以预测的故障。\n```\n\n### 对于互联网服务的分布式系统的假设\n1. 需要7*24的可用状况，所以不能有服务不可用的状态\n2. 采用通用的硬件，故障率会较高，成本较低\n3. 采用IP和以太网的技术，网络可靠性不如专有网络(Fiber Channel等。。。)\n\n因为上面的三个原因可能引申出来的另外的假设  \n\n4. 系统越大，局部组件失效的概率越大。（长时间的运行时间，失效、修复、再失效是正常的状况而不能当为异常的情况去考虑）\n5. 由于局部失效的概率高，因此需要必须容忍部分节点失败，并且能够保持对外提供可用的服务\n\n<b><font color=\"#FF0000\">所以实际上我们目前大部分的分布式的系统是需要在不可靠的硬件上面通过软件容错来构建可靠的系统。</font></b>\n\n### <strong><font color=\"#FF0000\">所以分布式系统遇到的问题可以分为三个大类</font></strong>\n1. 网络类问题  \n2. 时钟问题  \n3. 节点软件和硬件的问题  \n\n## <a id=\"3.1\"><span class=\"secondtitle\">网络问题</span></a>\n对于上面的假设（主要是成本考虑）来说，一般都会采用无共享的方式来构建集群。\n\n由于通常使用的都是以太网来构建，而且以太网是异步的网络。可能会出现下面的这些情况\n1. 请求丢失  \n2. 请求再队列等待，无法发送（网络问题或者接收方繁忙在内核的队列中等待）  \n3. 远程接收节点失效（节点崩溃）  \n4. 远程节点无法响应  \n5. 远程节点有返回，但是返回过程中丢失  \n6. 远程节点处理请求，但是在返回时候被延时处理（优先级问题， 或者网络问题或则和发送方阻塞了）  \n\n\n此处需要多引入一个新概念，网络分区\n```\n网络分区（Network Partition）：当网络的一部分由于网络故障而与其他部分隔开，称之为网络分区或者网络分片\n```\n\n在工程的实践中，网络故障(丢包、链路中断、路由问题、物理设备损坏)的概率是远比想象中高， 因此在基于我们假设的前提的环境下面，必须要把网络分区和网络故障接入到软件中进行容错。\n\n对于如何处理检测是否故障，需要判断的一个问题是，是节点服务上面出现了真实的故障，还是网络的不可靠导致的服务失效的表现。\n```\n在实际生产的实践中有这样的方法来快速的在本应用层（网络正常的情况下）来进行简单的判断\n1. 通过服务注册的心跳来注册自己的服务存活，并且把死亡状态的服务实例剔除出可用服务中\n2. 检测进程是否崩溃，如果崩溃发送一个信号。（或者在我的工作经历中，使用一个进程去定时检测进程是否存活，失败了发送信号使得资源进行重启的尝试，并且上报告警）\n3. 通过交换机去查询网络的状况\n4. 通过中间件的自身监控（如Rabbitmq的web界面）来监控中间件的执行状况\n5. 定期去尝试访问网络是否通达\n```\n但是最终我们唯一能够完全判断故障的方法只有超时，来保证节点是不可用的状态（为了保证网络的不可靠问题）。\n\n### 超时引入的问题\n我们如何能够判断什么时候才是最好的超时的判断间隔呢？\n\n对于上面的这个问题， 我们引入两个问题的前置的讨论  \n1. 是什么导致我们会出现网络的不稳定  \n2. 如果出现超时之后，会有怎样的影响，会导致什么样的后果  \n\n#### 网络不稳定的原因\n根本的原因： 在设计目前的TCP/IP的协议和方法的时候，我们的目的是为了尽可能高的提高资源的利用率  \n设计的思想： 通过动态分配和竞争的机制使得动态决定那个包被发送，但是这样的方法必然会引入排队的机制  \n\n```\n// 出现网络不稳定的原因可能如下\n1. 对于交换机的角度，会有多条等待队列来进行数据报文的转发，如果符合过重，则需要等待轮询机制来等待发送的机会，并且如果数据量过多的情况下，也有可能出现数据报文被丢弃，然后被不断重试的现象\n2. 在服务器的处理中，因为Linux内核处理接收到的报文也是类似于交换机的处理模式，通过队列来对接受到的包进行排序以及复制到用户态，因此也是需要一定的时间需要处理\n3. 在TCP的协议中的重传的机制也会根据返回的报文的控制字段来减小发送窗口的大小来减少对接受方的压力，可能导致排队会提前到发送方的等待队列中。并且重传机制会进行多次的重试，引入了隐形的超时时间\n```\n\n#### 调用超时（网络超时）可能会导致的后果\n主要的影响是发生了责任的转移，可能带来可能的影响  \n1. 命令的重复执行  \n2. 数据迁移  \n3. 当整个系统处于高负荷的状态，可能会把其他正常的部分通过转移职责导致整个系统被拖垮  \n\n因此我们必须很小心调整这个超时的阈值,如果在以前的情况下，可能需要系统管理员对于在生产环境的情况下调整一定的参数来慢慢测试得出一个最优值。\n但是在最近的组建的实现中有两种新的思路\n```\n1. 通过内部的一个故障检测器来计算成功率来进行对超时阈值的控制（Akka， Cassandra， Hytrsix中有使用此种方法）\n2. 通过对数据的采集清洗和分析（AIOPS）（可能是APM(Application Performance Metric)的埋点采集数据以及对监控数据的整体清洗通过一些机器学习的模型来计算出超时的阈值）\n```\n\n## <a id=\"3.2\"><span class=\"secondtitle\">时钟问题</span></a>\n分布式的系统的时钟问题也是一个非常值得重视的问题，后面会有我自己的工作案例来说明可能出现的情况的严重性。\n\n其实对于时间我们一般分为两种的应用方式\n1. 在一段时间内的统计数据（时间段）\n2. 某些时间点是否有指定动作完成或某个历史行为的发生的时间点\n\n### 服务器时间的维护方式以及问题\n每个机器的时间可以通过两种方式来共同维护\n1. 本地时间（通过主板的石英振荡器来维护）\n2. 通过与一个准确的时间获取源来定是同步时间（NTP和Chrony就是服务于方面的协议）\n\n这两种的结合不一定能够保证这样的可信赖的分布式集群中的时间就必然是同步的\n1. 本地时间本来每个节点都可能会出现偏差\n2. 同步时间的时候必须通过网络来进行同步，而在我们上面提及的假设中，网络是不可靠的，因此可能会出现失败的情况。 \n3. NTP如果发现时间差别太大（实际生产中是时间差>=10分钟的情况下）的话会拒绝同步（但是Chrony并没有此问题）\n4. 闰秒的问题\n\n当然可以像Google维护Spanner集群那样采用高精度的原子钟加上GPS定位来保证错误在一定的可接受范围内运行（一般误差的单位为5微妙）。但是不是每个分布式系统都能够有如此之高的维护成本去使用这种方式来\n\n### 时钟的概念\n\n时钟可以分解为两个时钟的概念\n1. 物理时钟\n物理时钟:包括了两种一个是墙上时钟，一个是单调时钟。可以理解为可以通过系统时间相关的API进行获取的时钟。\n2. 逻辑时钟\n逻辑时钟：可以理解为分布式系统中全局的单调递增的事件ID，事件发生顺序与此相同。\n\n#### 物理时钟\n需要先引入一个时间调整的概念：\n<!-- ![时间跳变说明图](/assets/img/posts/TimeJump.png)   -->\n{% asset_img TimeJump.png 时间跳变说明图 %}\n如果把时间以时间轴的方式来进行表达，往时间变大的方向调整为向前调整，往时间变小的方向调整的是向后调整。\n只要发生了时间的变动，我们都可以称之为服务器发生了时间跳变。\n\n<b><font color=\"\">1. 墙上时钟 </font> </b><br>\n根据日历返回当前的时钟，就是我们平时在Linux上直接使用date命令或者语言内置的时间相关的api的输出。\n这种时钟可以与时间同步服务器后同步后进行修改，可能会出现向前调整或者向后调整的可能性\n\n<b><font color=\"\">2. 单调时钟</font></b><br>\n用于： 适合测量持续的时间段    \n单调时钟的特性：    \n    1. 保证只会向前调整    \n    2. 不需要进行同步    \n\n#### 计算和调整的方式\n在一个时间点进行对单调时间的获取，然后完成某项工作后，再去检查时间。但是这段时间的差值并没有太大的意义。\n\n#### 时间与事件的顺序问题\n\n当两个客户端对于一个分布式的数据库（非Raft或者Paxos类型，如Riak）分别进行写入的情况下（此处假设先写入的客户端为A，晚写入的客户端为B）  \n<!-- ![事件与时序冲突](/assets/img/posts/Time&EventMissmatch.png) -->\n{% asset_img Time&EventMissmatch.png 事件与时序冲突 %}\n当B虽然在发生的时间比A要晚，但是B在集群中同步完成的时间比A要早的情况写。即对外部来说A还未写入成功的情况下，先执行了B的操作，可能导致B的操作丢失（如果B的操作是依赖于A先写入的操作）。  \n上面是一个非常经典的关于分布式集群时间与事件的顺序问题。然而这种问题即使在时间同步服务精度再再提高的情况下，也无法保证它的执行的顺序与时间是一致的。  \n\n#### 工作上发生过与物理时间相关的问题\n\n<b>问题1： 发生时间跳变后，导致任务的调度器不再调度任务的情况  </b>  \n<!-- ![调度器时间跳变问题](/assets/img/posts/SchdulerTimeJump.png)   -->\n{% asset_img SchdulerTimeJump.png 调度器时间跳变问题 %}\n    现象的描述： \n    调度器默认应该定时把任务调度到线程上面，但是查看日志后发现任务并没有被调度   \n    原因解释：    \n    时间发生了向后的跳变，但是跳变的幅度大于调度的间隔，导致系统中认为调度成功，之后就没有追踪下面的状态（因为当时那部分代码的实现是再调度的时候修改调度的时间为last调度时间）    \n    解决方法：    \n    把时间从墙上时间更换为单调时间，然后添加检查执行的间隔即可。  \n  \n<b>问题2：同步时间后，由于时间差溢出导致结果溢出的问题  </b><br>\n    现象描述：    \n    从Ceph Mgr获取单个采集数据的情况下，然后发现数据变得异常的大，是一个int64是随机数  \n    原因解释：  \n    因为采用的是墙上的时候，但是发生了时间的向后调变，导致计算出来的值发生异常  \n    解决方法：  \n    把墙上时间更换为单调时间  \n\n#### 逻辑时钟\n做法： 需要一个全局的单调递增的ID。\n但是是否可以使用同步后的时间来做呢？\n答： 不可以。因为还是时间精度的不确定性。\n\n## <a id=\"3.3\"><span class=\"secondtitle\">节点本身的问题（硬件和软件）</span></a>\n比较极端但是可能出现率比较高的场景是进程出现暂停的情况\n\n1. 带GC的编程语言的GC(Garbage collection) halt\n2. 虚拟化环境的虚拟机的暂停\n3. 电脑发生休眠或者断电\n4. 上下文切换的情况下卡住了\n5. 执行同步磁盘的操作的时候（如fsync操作）\n6. 接收到信号导致进程退出的情况下\n\n# <a id=\"ConditionAssumtion\"><span class=\"toptitle\">#在不可靠硬件构建可靠软件需要满足的条件和假设</span></a>\n\n此部分为DDIA第8章的描述总结，可以理解成为读书笔记    \n\n## <a id=\"4.1\"><span class=\"secondtitle\">真相由多数决定（重要的判定条件）</span></a>\n节点不能通过自己的信息来判断自身的状态。因为节点可能出现失效、假死、甚至无法恢复的状况.可能出现的场景如下\n```\n1. 节点成功收到请求，但是因为路由问题，无法进行返回，超时后而被判失效\n2. 半断开的节点发现自己的信息没有被其他节点所确认，意识到自己网络出现问题\n3. GC halt导致无法接受请求，但是对于应用来说，切回到工作状态时候，自身状态没有变化\n```\n以上的多种情景都是实际出现问题，但是自身的状态并不会改变，因为没有收到其他节点的通知，它会一直维持原来的状态。    \n所以分布式的算法依赖节点间的相互投票与最小投票数（使用Quorum机制，m>=(n+1)/2）进行对比来产生结果,由于一个集群不会存在两个多数在同事做出相互冲突的决定，减少对特定节点的依赖。\n\n基于上面所提及节点不能通过自己的信息来判断自己的状态，我们讨论一个比较常见的问题，主节点与锁是比较常见的使用方法\n```\n可能的出现的场景\n1. 只允许一个节点作为数据库分区的主节点（Multi-Raft是其中的一种实现）\n2. 只允许一个事务或者客户端持有特定资源的锁，以防止同时并发写入带来的数据被破坏的问题\n```\n\n### <span class=\"thirdtitle\">如果由自己的状态决定可能会出现的问题</span>\n但是此处我们的假设时在分布式系统中，那么有可能出现节点中间出现了角色的切换，但是如果不加以对状态的判断，可能会出现这样的问题\n问题描述  \n<!-- ![客户端锁问题](/assets/img/posts/lockingproblem.png)   -->\n{% asset_img lockingproblem.png 客户端锁问题 %}\n客户端写入存储的时候需要先从分布式服务中获取锁，有两个客户端在线，客户端A先从服务中获取锁，然后发生了进程halt状态（可能是GC或者其他的原因）\n如果不加判断的情况下，在客户端A halt的状态的情况下，客户端B获得锁并且写入存储成功，然后客户端A从Halt状态中回复正常，客户端A认为锁还在，然后写入存储，\n如果两个客户端写入的是同一个文件的话，数据可能会出现问题。  \n### <span class=\"thirdtitle\">解决上面的问题</span>\n对于上面的问题，我们可以使用一个Fencing令牌来解决这个问题。(此机制到后面的文章还会继续详细讲解)  \n<!-- ![Fencing令牌解决锁问题](/assets/img/posts/lockingproblem2.png)   -->\n{% asset_img lockingproblem2.png Fencing令牌解决锁问题 %}\n我们在客户端A获取锁的时候给令牌赋予一个值，为33。 在客户端B获取锁的时候赋予一个令牌值34。  \n当B写入完成后，存储会把已写入令牌改为34，下一次分发的令牌为35， 这样的话，如果A带上33的令牌写入的时候直接被拒绝，能够保证一致性。  \n实际上上面这种方法不仅加上了一个令牌，而且在服务器端会有一个关于令牌的校验。这种做法非常常见。\n\n\n## <a id=\"4.2\"><span class=\"secondtitle\">理论系统模型与现实</span></a>\n对于一个在现实中能够容错的分布式系统，我们需要对预期的系统错误证明形式化的描述。我们通过定义部分的系统模型来形式化描述算法的前提条件。 \n\n<h3><b><span class=\"thirdtitle\">计时模型</span></b></h3>\n#### 同步模型\n假定有上界网络延迟和上界进程的暂停和上界时钟误差。（但是这个模型一般不存在，因为以太网的不可靠性，除非使用更加稳定的网络介质，并且使用高精度时间设备同步）\n#### 部分同步模型\n大多数情况下像一个同步系统运行，但是会有超出网络延迟，进程暂停和时钟漂移的上界。这个就是比较现实的模型，就是上面我们提到的真实环境可能出现的情况的总和。而且大部分时间比较稳定，小部分时间会有背离，但是发生背离就会出现三者中的组合的情况出现。\n#### 异步模型\n\n\n<h3><b><span class=\"thirdtitle\">节点失效模型</span></b></h3>\n#### 崩溃-中止模型\n节点以一种特定的方式发生故障，故障后，出现系统崩溃，并且节点不会再添加进入集群中，无法恢复\n#### 崩溃-恢复模型\n节点可能会在任何时候发生崩溃，并且会在未知的时间长度来进行恢复。但是节点上只要持久性存储的数据都可以在恢复之后得以保存，内存的状态会消失。\n#### 拜占庭失效\n在非可信任的集群中进行共识的计算，可能会出现作弊、欺诈的操作（区块链上面的假设的环境）  \n所以满足我们实际生产环境（互联网或者企业内部的环境）的是 部分同步模型+ 崩溃恢复模型的组合。\n\n我们目前的分布式的环境是 崩溃-恢复模型+ 部分同步的模型 \n\n### <span class=\"thirdtitle\">分布式共识算法的正确性必须要有以下的性质</span>\n1. 唯一性  \n两个令牌不能获得相同的值  \n2. 单调递增  \n如果请求x返回令牌tx， 请求y返回了令牌ty, 且x在y开始之前先完成，tx < ty  \n3. 可用性  \n请求令牌的节点如果不发生崩溃最终一定能收到响应（无论是对应用来说正确或者错误的回答）  \n\n#### 分布式共识算法的安全性和活性\n在正确性中其实可以再进行细分分为安全性和活性（理解上，并非准确的定义，准确的定义可以查看FLP的理论）：  \n安全性： 没有发生意外  \n活性： 预期的事情一定会发生（最终会发生）  \n\n如果违反了安全的属性，我们可以找到发生特定时间的时间点。但是违反安全属性的事件发生，必定不可逆，数据丢失。  \n活性的话无法明确具体发生的时间点，但是希望再未来某个时间点能够达到要求。  \n\n# <a id=\"ShareNote\"><span class=\"toptitle\">ShareNote</span></a>\nPS: 文章中部分的图来源是来自于《数据密集型应用系统设计》，为PDF翻译的截图，截图的引用在[此处](https://github.com/hyhlinux/DDIA/blob/master/ch8.md)。如果涉及到版权的问题，请通知我，我会使用工具继续重画。\n1. [IBM Defination of Distributed System](https://www.ibm.com/support/knowledgecenter/en/SSAL2T_8.2.0/com.ibm.cics.tx.doc/concepts/c_wht_is_distd_comptg.html)\n2. [数据密集型应用系统设计](https://book.douban.com/subject/30329536/)\n3. [FLP Impossibility](https://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/)\n4. [拜占庭错误](https://en.wikipedia.org/wiki/Byzantine_fault)\n5. [拜占庭容错](https://www.usenix.org/legacy/events/osdi99/full_papers/castro/castro_html/castro.html)\n6. [Riak](https://github.com/basho/riak_core)","slug":"intro-distributed-system","published":1,"updated":"2021-01-21T07:27:34.188Z","_id":"ckk6h2epk0004eci5cgca101l","comments":1,"layout":"post","photos":[],"link":"","content":"<!-- ---\n\nauthor: Ray Chan(ray1888)\ndate: 2019-08-20 11:07:38\ncategory: \nsummary: introduction of distributed system and its problem\nthumbnail: distributed-system.png\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#Introduction\">什么是分布式系统</a>  </li>\n<li><a href=\"#Purpose\">分布式系统能够解决什么问题</a><br>2.1 <a href=\"#2.1\">服务器的性能扩展方案</a><br>2.2 <a href=\"#2.2\">分布式系统的特点</a><br>2.3 <a href=\"#2.3\">分布式系统解决的问题</a>  </li>\n<li><a href=\"#Problem\">分布式系统的问题</a><br>3.1 <a href=\"#3.1\">网络问题</a><br>3.2 <a href=\"#3.2\">时钟问题</a><br>3.3 <a href=\"#3.3\">节点问题</a>  </li>\n<li><a href=\"#ConditionAssumtion\">在不可靠硬件构建可靠软件需要满足的条件和假设</a><br>4.1 <a href=\"#4.1\">真相由多数决定</a><br>4.2 <a href=\"#4.2\">理论系统模型与现实</a>  </li>\n<li><a href=\"#ShareNote\">ShareNote</a>  </li>\n</ol>\n\n        <h1 id=\"什么是分布式系统\"   >\n          <a href=\"#什么是分布式系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#什么是分布式系统</h1>\n      \n        <h3 id=\"分布式系统\"   >\n          <a href=\"#分布式系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Definantion from IBM Site </span><br><span class=\"line\">A distributed computer system consists of multiple software components that are on multiple computers, but run as a single system. The computers that are in a distributed </span><br><span class=\"line\">system can be physically close together and connected by a local network, or they can be geographically distant and connected by a wide area network. A distributed system can consist of any number of possible configurations, such as mainframes, personal computers, workstations, minicomputers, and so on. The goal of distributed computing is to make such a network work as a single computer.</span><br></pre></td></tr></table></div></figure>\n<p>简述：<br>分布式的计算机系统是由多台形式的计算机（包括服务器、个人电脑、工作站、嵌入式系统的形式）组成的，但是对外表示成一个完整功能的系统。对于分布式系统的使用者，可以把一个大型的分布式系统看作一个黑盒来进行使用。  </p>\n\n        <h1 id=\"分布式系统能够解决什么问题\"   >\n          <a href=\"#分布式系统能够解决什么问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#分布式系统能够解决什么问题</h1>\n      \n        <h3 id=\"2-1-服务器的性能扩展方案\"   >\n          <a href=\"#2-1-服务器的性能扩展方案\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.1. 服务器的性能扩展方案</h3>\n      <p>对于一个系统来说，如果当需要计算的问题太过庞大的时候，会有两种思路来进行算力的添加  </p>\n<p>1.Scale UP（纵向扩展）<br>纵向扩展:企业后端大型服务器以增加处理器等运算资源进行升级以获得对应用性能的要求。<br>这种是比较传统的思路，具有以下特点：<br>    1. 扩容的成本较高。能够支持纵向扩展的系统都需要服务商进行服务的支持，需要购买特殊的硬件。而不是使用能够通用的硬件来进行扩容<br>    2. 延迟低，单点吞吐量大。本质上是单点的系统，可以减少了很多网络上面的开销，所以延迟一般会比分布式系统的延迟更低。而且单节点如果在没有超过负荷的情况下，因为硬件堆积在上面，单节点的性能一般会比分布式的单节点性能更强。<br>    3. 备份成本高，遇到不可恢复的故障时可能要中断一定时间的服务。如果对于纵向扩展的设备需要进行灾备的情况下，可能需要同时购入相同配置的硬件通过配置主备来继续容灾，而不能通过像分布式系统在多个地域继续节点部署和配置添加达到冗余的程度。<br>  实例的系统： 传统的SAN(storage area network)系统  </p>\n<p>2.Scale Out(水平扩展)<br>水平扩展：企业可以根据需求增加不同的服务器应用，依靠多部服务器协同运算，借负载平衡及容错等功能来提高运算能力及可靠度。<br>这是从谷歌的三篇经典的分布式论文（bigtable、distributed filesystem、 mapreduce)提炼出来的特点：<br>    1. 成本低，扩展性好。使用的是市面上可以购买的通用的服务器配件，并且可以根据需求进行硬件的升级即可提升整体的性能（如存储服务器上面，把HDD更换为全闪存的NVME SSD，立刻可以在读写的吞吐量和时延上面获得具体的提升）<br>    2. 弹性好。可以通过配置动态的增删服务器，可以动态的对业务使用的服务器资源具有更好的调配，并且可以通过弹性的配置获得根据地理位置的容灾以及数据冗余功能（如金融企业中的两地三中心的需求）<br>    3. 处理单节点无法处理的问题。（最重要）  </p>\n\n        <h3 id=\"2-2-分布式系统的特点\"   >\n          <a href=\"#2-2-分布式系统的特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.2 分布式系统的特点</h3>\n      <ol>\n<li>扩展性强(Scalability)  </li>\n<li>有冗余(Redundancy)  </li>\n</ol>\n\n        <h3 id=\"2-3-分布式系统解决的问题\"   >\n          <a href=\"#2-3-分布式系统解决的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.3 分布式系统解决的问题</h3>\n      <p>分布式系统最重要解决的问题是：  </p>\n<ol>\n<li>处理单机无法计算的问题。<br>因为问题能够被分治成为了更小的问题，使得更弱的节点也可以进行计算  </li>\n<li>同样的工作量下，减少计算使用的时间。<br>因为部分计算是可以并行来继续执行的，只要调度得当的情况下，可以减少单机系统中出现的等待的情况。  </li>\n<li>在有限的成本内，可以通过多区域部署服务来降低该地区的服务的时延。  </li>\n</ol>\n\n        <h1 id=\"分布式系统的问题\"   >\n          <a href=\"#分布式系统的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统的问题</h1>\n      <p>（此部分有部分会引用到数据密集型应用系统设计（DDIA）的第8章部分的内容）<br>软件工程的世界里面没有银弹，分布式系统并不是所有问题的最优解。它在解决上述问题的情况下也引入了下面的多种问题<br>此处需要引入一个部分失效的概念：  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">部分失效：在分布式系统中，可能会出现系统的一部分工作正常，其他部分出现难以预测的故障。</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"对于互联网服务的分布式系统的假设\"   >\n          <a href=\"#对于互联网服务的分布式系统的假设\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对于互联网服务的分布式系统的假设</h3>\n      <ol>\n<li>需要7*24的可用状况，所以不能有服务不可用的状态</li>\n<li>采用通用的硬件，故障率会较高，成本较低</li>\n<li>采用IP和以太网的技术，网络可靠性不如专有网络(Fiber Channel等。。。)</li>\n</ol>\n<p>因为上面的三个原因可能引申出来的另外的假设  </p>\n<ol start=\"4\">\n<li>系统越大，局部组件失效的概率越大。（长时间的运行时间，失效、修复、再失效是正常的状况而不能当为异常的情况去考虑）</li>\n<li>由于局部失效的概率高，因此需要必须容忍部分节点失败，并且能够保持对外提供可用的服务</li>\n</ol>\n<p><b><font color=\"#FF0000\">所以实际上我们目前大部分的分布式的系统是需要在不可靠的硬件上面通过软件容错来构建可靠的系统。</font></b></p>\n\n        <h3 id=\"所以分布式系统遇到的问题可以分为三个大类\"   >\n          <a href=\"#所以分布式系统遇到的问题可以分为三个大类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>所以分布式系统遇到的问题可以分为三个大类</h3>\n      <ol>\n<li>网络类问题  </li>\n<li>时钟问题  </li>\n<li>节点软件和硬件的问题  </li>\n</ol>\n\n        <h2 id=\"网络问题\"   >\n          <a href=\"#网络问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>网络问题</h2>\n      <p>对于上面的假设（主要是成本考虑）来说，一般都会采用无共享的方式来构建集群。</p>\n<p>由于通常使用的都是以太网来构建，而且以太网是异步的网络。可能会出现下面的这些情况</p>\n<ol>\n<li>请求丢失  </li>\n<li>请求再队列等待，无法发送（网络问题或者接收方繁忙在内核的队列中等待）  </li>\n<li>远程接收节点失效（节点崩溃）  </li>\n<li>远程节点无法响应  </li>\n<li>远程节点有返回，但是返回过程中丢失  </li>\n<li>远程节点处理请求，但是在返回时候被延时处理（优先级问题， 或者网络问题或则和发送方阻塞了）  </li>\n</ol>\n<p>此处需要多引入一个新概念，网络分区</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网络分区（Network Partition）：当网络的一部分由于网络故障而与其他部分隔开，称之为网络分区或者网络分片</span><br></pre></td></tr></table></div></figure>\n<p>在工程的实践中，网络故障(丢包、链路中断、路由问题、物理设备损坏)的概率是远比想象中高， 因此在基于我们假设的前提的环境下面，必须要把网络分区和网络故障接入到软件中进行容错。</p>\n<p>对于如何处理检测是否故障，需要判断的一个问题是，是节点服务上面出现了真实的故障，还是网络的不可靠导致的服务失效的表现。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在实际生产的实践中有这样的方法来快速的在本应用层（网络正常的情况下）来进行简单的判断</span><br><span class=\"line\">1. 通过服务注册的心跳来注册自己的服务存活，并且把死亡状态的服务实例剔除出可用服务中</span><br><span class=\"line\">2. 检测进程是否崩溃，如果崩溃发送一个信号。（或者在我的工作经历中，使用一个进程去定时检测进程是否存活，失败了发送信号使得资源进行重启的尝试，并且上报告警）</span><br><span class=\"line\">3. 通过交换机去查询网络的状况</span><br><span class=\"line\">4. 通过中间件的自身监控（如Rabbitmq的web界面）来监控中间件的执行状况</span><br><span class=\"line\">5. 定期去尝试访问网络是否通达</span><br></pre></td></tr></table></div></figure>\n<p>但是最终我们唯一能够完全判断故障的方法只有超时，来保证节点是不可用的状态（为了保证网络的不可靠问题）。</p>\n\n        <h3 id=\"超时引入的问题\"   >\n          <a href=\"#超时引入的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>超时引入的问题</h3>\n      <p>我们如何能够判断什么时候才是最好的超时的判断间隔呢？</p>\n<p>对于上面的这个问题， 我们引入两个问题的前置的讨论  </p>\n<ol>\n<li>是什么导致我们会出现网络的不稳定  </li>\n<li>如果出现超时之后，会有怎样的影响，会导致什么样的后果  </li>\n</ol>\n\n        <h4 id=\"网络不稳定的原因\"   >\n          <a href=\"#网络不稳定的原因\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>网络不稳定的原因</h4>\n      <p>根本的原因： 在设计目前的TCP/IP的协议和方法的时候，我们的目的是为了尽可能高的提高资源的利用率<br>设计的思想： 通过动态分配和竞争的机制使得动态决定那个包被发送，但是这样的方法必然会引入排队的机制  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 出现网络不稳定的原因可能如下</span><br><span class=\"line\">1. 对于交换机的角度，会有多条等待队列来进行数据报文的转发，如果符合过重，则需要等待轮询机制来等待发送的机会，并且如果数据量过多的情况下，也有可能出现数据报文被丢弃，然后被不断重试的现象</span><br><span class=\"line\">2. 在服务器的处理中，因为Linux内核处理接收到的报文也是类似于交换机的处理模式，通过队列来对接受到的包进行排序以及复制到用户态，因此也是需要一定的时间需要处理</span><br><span class=\"line\">3. 在TCP的协议中的重传的机制也会根据返回的报文的控制字段来减小发送窗口的大小来减少对接受方的压力，可能导致排队会提前到发送方的等待队列中。并且重传机制会进行多次的重试，引入了隐形的超时时间</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"调用超时（网络超时）可能会导致的后果\"   >\n          <a href=\"#调用超时（网络超时）可能会导致的后果\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>调用超时（网络超时）可能会导致的后果</h4>\n      <p>主要的影响是发生了责任的转移，可能带来可能的影响  </p>\n<ol>\n<li>命令的重复执行  </li>\n<li>数据迁移  </li>\n<li>当整个系统处于高负荷的状态，可能会把其他正常的部分通过转移职责导致整个系统被拖垮  </li>\n</ol>\n<p>因此我们必须很小心调整这个超时的阈值,如果在以前的情况下，可能需要系统管理员对于在生产环境的情况下调整一定的参数来慢慢测试得出一个最优值。<br>但是在最近的组建的实现中有两种新的思路</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 通过内部的一个故障检测器来计算成功率来进行对超时阈值的控制（Akka， Cassandra， Hytrsix中有使用此种方法）</span><br><span class=\"line\">2. 通过对数据的采集清洗和分析（AIOPS）（可能是APM(Application Performance Metric)的埋点采集数据以及对监控数据的整体清洗通过一些机器学习的模型来计算出超时的阈值）</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"时钟问题\"   >\n          <a href=\"#时钟问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时钟问题</h2>\n      <p>分布式的系统的时钟问题也是一个非常值得重视的问题，后面会有我自己的工作案例来说明可能出现的情况的严重性。</p>\n<p>其实对于时间我们一般分为两种的应用方式</p>\n<ol>\n<li>在一段时间内的统计数据（时间段）</li>\n<li>某些时间点是否有指定动作完成或某个历史行为的发生的时间点</li>\n</ol>\n\n        <h3 id=\"服务器时间的维护方式以及问题\"   >\n          <a href=\"#服务器时间的维护方式以及问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>服务器时间的维护方式以及问题</h3>\n      <p>每个机器的时间可以通过两种方式来共同维护</p>\n<ol>\n<li>本地时间（通过主板的石英振荡器来维护）</li>\n<li>通过与一个准确的时间获取源来定是同步时间（NTP和Chrony就是服务于方面的协议）</li>\n</ol>\n<p>这两种的结合不一定能够保证这样的可信赖的分布式集群中的时间就必然是同步的</p>\n<ol>\n<li>本地时间本来每个节点都可能会出现偏差</li>\n<li>同步时间的时候必须通过网络来进行同步，而在我们上面提及的假设中，网络是不可靠的，因此可能会出现失败的情况。 </li>\n<li>NTP如果发现时间差别太大（实际生产中是时间差&gt;=10分钟的情况下）的话会拒绝同步（但是Chrony并没有此问题）</li>\n<li>闰秒的问题</li>\n</ol>\n<p>当然可以像Google维护Spanner集群那样采用高精度的原子钟加上GPS定位来保证错误在一定的可接受范围内运行（一般误差的单位为5微妙）。但是不是每个分布式系统都能够有如此之高的维护成本去使用这种方式来</p>\n\n        <h3 id=\"时钟的概念\"   >\n          <a href=\"#时钟的概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时钟的概念</h3>\n      <p>时钟可以分解为两个时钟的概念</p>\n<ol>\n<li>物理时钟<br>物理时钟:包括了两种一个是墙上时钟，一个是单调时钟。可以理解为可以通过系统时间相关的API进行获取的时钟。</li>\n<li>逻辑时钟<br>逻辑时钟：可以理解为分布式系统中全局的单调递增的事件ID，事件发生顺序与此相同。</li>\n</ol>\n\n        <h4 id=\"物理时钟\"   >\n          <a href=\"#物理时钟\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>物理时钟</h4>\n      <p>需要先引入一个时间调整的概念：</p>\n<!-- ![时间跳变说明图](/assets/img/posts/TimeJump.png)   -->\n<img src=\"/2019/08/21/intro-distributed-system/TimeJump.png\" class=\"\" title=\"时间跳变说明图\">\n<p>如果把时间以时间轴的方式来进行表达，往时间变大的方向调整为向前调整，往时间变小的方向调整的是向后调整。<br>只要发生了时间的变动，我们都可以称之为服务器发生了时间跳变。</p>\n<p><b><font color=\"\">1. 墙上时钟 </font> </b><br><br>根据日历返回当前的时钟，就是我们平时在Linux上直接使用date命令或者语言内置的时间相关的api的输出。<br>这种时钟可以与时间同步服务器后同步后进行修改，可能会出现向前调整或者向后调整的可能性</p>\n<p><b><font color=\"\">2. 单调时钟</font></b><br><br>用于： 适合测量持续的时间段<br>单调时钟的特性：<br>    1. 保证只会向前调整<br>    2. 不需要进行同步    </p>\n\n        <h4 id=\"计算和调整的方式\"   >\n          <a href=\"#计算和调整的方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>计算和调整的方式</h4>\n      <p>在一个时间点进行对单调时间的获取，然后完成某项工作后，再去检查时间。但是这段时间的差值并没有太大的意义。</p>\n\n        <h4 id=\"时间与事件的顺序问题\"   >\n          <a href=\"#时间与事件的顺序问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时间与事件的顺序问题</h4>\n      <p>当两个客户端对于一个分布式的数据库（非Raft或者Paxos类型，如Riak）分别进行写入的情况下（此处假设先写入的客户端为A，晚写入的客户端为B）  </p>\n<!-- ![事件与时序冲突](/assets/img/posts/Time&EventMissmatch.png) -->\n<img src=\"/2019/08/21/intro-distributed-system/Time&EventMissmatch.png\" class=\"\" title=\"事件与时序冲突\">\n<p>当B虽然在发生的时间比A要晚，但是B在集群中同步完成的时间比A要早的情况写。即对外部来说A还未写入成功的情况下，先执行了B的操作，可能导致B的操作丢失（如果B的操作是依赖于A先写入的操作）。<br>上面是一个非常经典的关于分布式集群时间与事件的顺序问题。然而这种问题即使在时间同步服务精度再再提高的情况下，也无法保证它的执行的顺序与时间是一致的。  </p>\n\n        <h4 id=\"工作上发生过与物理时间相关的问题\"   >\n          <a href=\"#工作上发生过与物理时间相关的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>工作上发生过与物理时间相关的问题</h4>\n      <p><b>问题1： 发生时间跳变后，导致任务的调度器不再调度任务的情况  </b>  </p>\n<!-- ![调度器时间跳变问题](/assets/img/posts/SchdulerTimeJump.png)   -->\n<img src=\"/2019/08/21/intro-distributed-system/SchdulerTimeJump.png\" class=\"\" title=\"调度器时间跳变问题\">\n<pre><code>现象的描述： \n调度器默认应该定时把任务调度到线程上面，但是查看日志后发现任务并没有被调度   \n原因解释：    \n时间发生了向后的跳变，但是跳变的幅度大于调度的间隔，导致系统中认为调度成功，之后就没有追踪下面的状态（因为当时那部分代码的实现是再调度的时候修改调度的时间为last调度时间）    \n解决方法：    \n把时间从墙上时间更换为单调时间，然后添加检查执行的间隔即可。  </code></pre>\n<p><b>问题2：同步时间后，由于时间差溢出导致结果溢出的问题  </b><br><br>    现象描述：<br>    从Ceph Mgr获取单个采集数据的情况下，然后发现数据变得异常的大，是一个int64是随机数<br>    原因解释：<br>    因为采用的是墙上的时候，但是发生了时间的向后调变，导致计算出来的值发生异常<br>    解决方法：<br>    把墙上时间更换为单调时间  </p>\n\n        <h4 id=\"逻辑时钟\"   >\n          <a href=\"#逻辑时钟\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>逻辑时钟</h4>\n      <p>做法： 需要一个全局的单调递增的ID。<br>但是是否可以使用同步后的时间来做呢？<br>答： 不可以。因为还是时间精度的不确定性。</p>\n\n        <h2 id=\"节点本身的问题（硬件和软件）\"   >\n          <a href=\"#节点本身的问题（硬件和软件）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>节点本身的问题（硬件和软件）</h2>\n      <p>比较极端但是可能出现率比较高的场景是进程出现暂停的情况</p>\n<ol>\n<li>带GC的编程语言的GC(Garbage collection) halt</li>\n<li>虚拟化环境的虚拟机的暂停</li>\n<li>电脑发生休眠或者断电</li>\n<li>上下文切换的情况下卡住了</li>\n<li>执行同步磁盘的操作的时候（如fsync操作）</li>\n<li>接收到信号导致进程退出的情况下</li>\n</ol>\n\n        <h1 id=\"在不可靠硬件构建可靠软件需要满足的条件和假设\"   >\n          <a href=\"#在不可靠硬件构建可靠软件需要满足的条件和假设\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#在不可靠硬件构建可靠软件需要满足的条件和假设</h1>\n      <p>此部分为DDIA第8章的描述总结，可以理解成为读书笔记    </p>\n\n        <h2 id=\"真相由多数决定（重要的判定条件）\"   >\n          <a href=\"#真相由多数决定（重要的判定条件）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>真相由多数决定（重要的判定条件）</h2>\n      <p>节点不能通过自己的信息来判断自身的状态。因为节点可能出现失效、假死、甚至无法恢复的状况.可能出现的场景如下</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 节点成功收到请求，但是因为路由问题，无法进行返回，超时后而被判失效</span><br><span class=\"line\">2. 半断开的节点发现自己的信息没有被其他节点所确认，意识到自己网络出现问题</span><br><span class=\"line\">3. GC halt导致无法接受请求，但是对于应用来说，切回到工作状态时候，自身状态没有变化</span><br></pre></td></tr></table></div></figure>\n<p>以上的多种情景都是实际出现问题，但是自身的状态并不会改变，因为没有收到其他节点的通知，它会一直维持原来的状态。<br>所以分布式的算法依赖节点间的相互投票与最小投票数（使用Quorum机制，m&gt;=(n+1)/2）进行对比来产生结果,由于一个集群不会存在两个多数在同事做出相互冲突的决定，减少对特定节点的依赖。</p>\n<p>基于上面所提及节点不能通过自己的信息来判断自己的状态，我们讨论一个比较常见的问题，主节点与锁是比较常见的使用方法</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可能的出现的场景</span><br><span class=\"line\">1. 只允许一个节点作为数据库分区的主节点（Multi-Raft是其中的一种实现）</span><br><span class=\"line\">2. 只允许一个事务或者客户端持有特定资源的锁，以防止同时并发写入带来的数据被破坏的问题</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"如果由自己的状态决定可能会出现的问题\"   >\n          <a href=\"#如果由自己的状态决定可能会出现的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如果由自己的状态决定可能会出现的问题</h3>\n      <p>但是此处我们的假设时在分布式系统中，那么有可能出现节点中间出现了角色的切换，但是如果不加以对状态的判断，可能会出现这样的问题<br>问题描述  </p>\n<!-- ![客户端锁问题](/assets/img/posts/lockingproblem.png)   -->\n<img src=\"/2019/08/21/intro-distributed-system/lockingproblem.png\" class=\"\" title=\"客户端锁问题\">\n<p>客户端写入存储的时候需要先从分布式服务中获取锁，有两个客户端在线，客户端A先从服务中获取锁，然后发生了进程halt状态（可能是GC或者其他的原因）<br>如果不加判断的情况下，在客户端A halt的状态的情况下，客户端B获得锁并且写入存储成功，然后客户端A从Halt状态中回复正常，客户端A认为锁还在，然后写入存储，<br>如果两个客户端写入的是同一个文件的话，数据可能会出现问题。  </p>\n\n        <h3 id=\"解决上面的问题\"   >\n          <a href=\"#解决上面的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>解决上面的问题</h3>\n      <p>对于上面的问题，我们可以使用一个Fencing令牌来解决这个问题。(此机制到后面的文章还会继续详细讲解)  </p>\n<!-- ![Fencing令牌解决锁问题](/assets/img/posts/lockingproblem2.png)   -->\n<img src=\"/2019/08/21/intro-distributed-system/lockingproblem2.png\" class=\"\" title=\"Fencing令牌解决锁问题\">\n<p>我们在客户端A获取锁的时候给令牌赋予一个值，为33。 在客户端B获取锁的时候赋予一个令牌值34。<br>当B写入完成后，存储会把已写入令牌改为34，下一次分发的令牌为35， 这样的话，如果A带上33的令牌写入的时候直接被拒绝，能够保证一致性。<br>实际上上面这种方法不仅加上了一个令牌，而且在服务器端会有一个关于令牌的校验。这种做法非常常见。</p>\n\n        <h2 id=\"理论系统模型与现实\"   >\n          <a href=\"#理论系统模型与现实\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>理论系统模型与现实</h2>\n      <p>对于一个在现实中能够容错的分布式系统，我们需要对预期的系统错误证明形式化的描述。我们通过定义部分的系统模型来形式化描述算法的前提条件。 </p>\n<h3><b><span class=\"thirdtitle\">计时模型</span></b></h3>\n#### 同步模型\n假定有上界网络延迟和上界进程的暂停和上界时钟误差。（但是这个模型一般不存在，因为以太网的不可靠性，除非使用更加稳定的网络介质，并且使用高精度时间设备同步）\n#### 部分同步模型\n大多数情况下像一个同步系统运行，但是会有超出网络延迟，进程暂停和时钟漂移的上界。这个就是比较现实的模型，就是上面我们提到的真实环境可能出现的情况的总和。而且大部分时间比较稳定，小部分时间会有背离，但是发生背离就会出现三者中的组合的情况出现。\n#### 异步模型\n\n\n<h3><b><span class=\"thirdtitle\">节点失效模型</span></b></h3>\n#### 崩溃-中止模型\n节点以一种特定的方式发生故障，故障后，出现系统崩溃，并且节点不会再添加进入集群中，无法恢复\n#### 崩溃-恢复模型\n节点可能会在任何时候发生崩溃，并且会在未知的时间长度来进行恢复。但是节点上只要持久性存储的数据都可以在恢复之后得以保存，内存的状态会消失。\n#### 拜占庭失效\n在非可信任的集群中进行共识的计算，可能会出现作弊、欺诈的操作（区块链上面的假设的环境）  \n所以满足我们实际生产环境（互联网或者企业内部的环境）的是 部分同步模型+ 崩溃恢复模型的组合。\n\n<p>我们目前的分布式的环境是 崩溃-恢复模型+ 部分同步的模型 </p>\n\n        <h3 id=\"分布式共识算法的正确性必须要有以下的性质\"   >\n          <a href=\"#分布式共识算法的正确性必须要有以下的性质\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识算法的正确性必须要有以下的性质</h3>\n      <ol>\n<li>唯一性<br>两个令牌不能获得相同的值  </li>\n<li>单调递增<br>如果请求x返回令牌tx， 请求y返回了令牌ty, 且x在y开始之前先完成，tx &lt; ty  </li>\n<li>可用性<br>请求令牌的节点如果不发生崩溃最终一定能收到响应（无论是对应用来说正确或者错误的回答）  </li>\n</ol>\n\n        <h4 id=\"分布式共识算法的安全性和活性\"   >\n          <a href=\"#分布式共识算法的安全性和活性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识算法的安全性和活性</h4>\n      <p>在正确性中其实可以再进行细分分为安全性和活性（理解上，并非准确的定义，准确的定义可以查看FLP的理论）：<br>安全性： 没有发生意外<br>活性： 预期的事情一定会发生（最终会发生）  </p>\n<p>如果违反了安全的属性，我们可以找到发生特定时间的时间点。但是违反安全属性的事件发生，必定不可逆，数据丢失。<br>活性的话无法明确具体发生的时间点，但是希望再未来某个时间点能够达到要求。  </p>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <p>PS: 文章中部分的图来源是来自于《数据密集型应用系统设计》，为PDF翻译的截图，截图的引用在<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/hyhlinux/DDIA/blob/master/ch8.md\" >此处</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>。如果涉及到版权的问题，请通知我，我会使用工具继续重画。</p>\n<ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.ibm.com/support/knowledgecenter/en/SSAL2T_8.2.0/com.ibm.cics.tx.doc/concepts/c_wht_is_distd_comptg.html\" >IBM Defination of Distributed System</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://book.douban.com/subject/30329536/\" >数据密集型应用系统设计</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/\" >FLP Impossibility</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://en.wikipedia.org/wiki/Byzantine_fault\" >拜占庭错误</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.usenix.org/legacy/events/osdi99/full_papers/castro/castro_html/castro.html\" >拜占庭容错</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/basho/riak_core\" >Riak</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<!-- ---\n\nauthor: Ray Chan(ray1888)\ndate: 2019-08-20 11:07:38\ncategory: \nsummary: introduction of distributed system and its problem\nthumbnail: distributed-system.png\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#Introduction\">什么是分布式系统</a>  </li>\n<li><a href=\"#Purpose\">分布式系统能够解决什么问题</a><br>2.1 <a href=\"#2.1\">服务器的性能扩展方案</a><br>2.2 <a href=\"#2.2\">分布式系统的特点</a><br>2.3 <a href=\"#2.3\">分布式系统解决的问题</a>  </li>\n<li><a href=\"#Problem\">分布式系统的问题</a><br>3.1 <a href=\"#3.1\">网络问题</a><br>3.2 <a href=\"#3.2\">时钟问题</a><br>3.3 <a href=\"#3.3\">节点问题</a>  </li>\n<li><a href=\"#ConditionAssumtion\">在不可靠硬件构建可靠软件需要满足的条件和假设</a><br>4.1 <a href=\"#4.1\">真相由多数决定</a><br>4.2 <a href=\"#4.2\">理论系统模型与现实</a>  </li>\n<li><a href=\"#ShareNote\">ShareNote</a>  </li>\n</ol>\n\n        <h1 id=\"什么是分布式系统\"   >\n          <a href=\"#什么是分布式系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#什么是分布式系统</h1>\n      \n        <h3 id=\"分布式系统\"   >\n          <a href=\"#分布式系统\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Definantion from IBM Site </span><br><span class=\"line\">A distributed computer system consists of multiple software components that are on multiple computers, but run as a single system. The computers that are in a distributed </span><br><span class=\"line\">system can be physically close together and connected by a local network, or they can be geographically distant and connected by a wide area network. A distributed system can consist of any number of possible configurations, such as mainframes, personal computers, workstations, minicomputers, and so on. The goal of distributed computing is to make such a network work as a single computer.</span><br></pre></td></tr></table></div></figure>\n<p>简述：<br>分布式的计算机系统是由多台形式的计算机（包括服务器、个人电脑、工作站、嵌入式系统的形式）组成的，但是对外表示成一个完整功能的系统。对于分布式系统的使用者，可以把一个大型的分布式系统看作一个黑盒来进行使用。  </p>\n\n        <h1 id=\"分布式系统能够解决什么问题\"   >\n          <a href=\"#分布式系统能够解决什么问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#分布式系统能够解决什么问题</h1>\n      \n        <h3 id=\"2-1-服务器的性能扩展方案\"   >\n          <a href=\"#2-1-服务器的性能扩展方案\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.1. 服务器的性能扩展方案</h3>\n      <p>对于一个系统来说，如果当需要计算的问题太过庞大的时候，会有两种思路来进行算力的添加  </p>\n<p>1.Scale UP（纵向扩展）<br>纵向扩展:企业后端大型服务器以增加处理器等运算资源进行升级以获得对应用性能的要求。<br>这种是比较传统的思路，具有以下特点：<br>    1. 扩容的成本较高。能够支持纵向扩展的系统都需要服务商进行服务的支持，需要购买特殊的硬件。而不是使用能够通用的硬件来进行扩容<br>    2. 延迟低，单点吞吐量大。本质上是单点的系统，可以减少了很多网络上面的开销，所以延迟一般会比分布式系统的延迟更低。而且单节点如果在没有超过负荷的情况下，因为硬件堆积在上面，单节点的性能一般会比分布式的单节点性能更强。<br>    3. 备份成本高，遇到不可恢复的故障时可能要中断一定时间的服务。如果对于纵向扩展的设备需要进行灾备的情况下，可能需要同时购入相同配置的硬件通过配置主备来继续容灾，而不能通过像分布式系统在多个地域继续节点部署和配置添加达到冗余的程度。<br>  实例的系统： 传统的SAN(storage area network)系统  </p>\n<p>2.Scale Out(水平扩展)<br>水平扩展：企业可以根据需求增加不同的服务器应用，依靠多部服务器协同运算，借负载平衡及容错等功能来提高运算能力及可靠度。<br>这是从谷歌的三篇经典的分布式论文（bigtable、distributed filesystem、 mapreduce)提炼出来的特点：<br>    1. 成本低，扩展性好。使用的是市面上可以购买的通用的服务器配件，并且可以根据需求进行硬件的升级即可提升整体的性能（如存储服务器上面，把HDD更换为全闪存的NVME SSD，立刻可以在读写的吞吐量和时延上面获得具体的提升）<br>    2. 弹性好。可以通过配置动态的增删服务器，可以动态的对业务使用的服务器资源具有更好的调配，并且可以通过弹性的配置获得根据地理位置的容灾以及数据冗余功能（如金融企业中的两地三中心的需求）<br>    3. 处理单节点无法处理的问题。（最重要）  </p>\n\n        <h3 id=\"2-2-分布式系统的特点\"   >\n          <a href=\"#2-2-分布式系统的特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.2 分布式系统的特点</h3>\n      <ol>\n<li>扩展性强(Scalability)  </li>\n<li>有冗余(Redundancy)  </li>\n</ol>\n\n        <h3 id=\"2-3-分布式系统解决的问题\"   >\n          <a href=\"#2-3-分布式系统解决的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.3 分布式系统解决的问题</h3>\n      <p>分布式系统最重要解决的问题是：  </p>\n<ol>\n<li>处理单机无法计算的问题。<br>因为问题能够被分治成为了更小的问题，使得更弱的节点也可以进行计算  </li>\n<li>同样的工作量下，减少计算使用的时间。<br>因为部分计算是可以并行来继续执行的，只要调度得当的情况下，可以减少单机系统中出现的等待的情况。  </li>\n<li>在有限的成本内，可以通过多区域部署服务来降低该地区的服务的时延。  </li>\n</ol>\n\n        <h1 id=\"分布式系统的问题\"   >\n          <a href=\"#分布式系统的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式系统的问题</h1>\n      <p>（此部分有部分会引用到数据密集型应用系统设计（DDIA）的第8章部分的内容）<br>软件工程的世界里面没有银弹，分布式系统并不是所有问题的最优解。它在解决上述问题的情况下也引入了下面的多种问题<br>此处需要引入一个部分失效的概念：  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">部分失效：在分布式系统中，可能会出现系统的一部分工作正常，其他部分出现难以预测的故障。</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"对于互联网服务的分布式系统的假设\"   >\n          <a href=\"#对于互联网服务的分布式系统的假设\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对于互联网服务的分布式系统的假设</h3>\n      <ol>\n<li>需要7*24的可用状况，所以不能有服务不可用的状态</li>\n<li>采用通用的硬件，故障率会较高，成本较低</li>\n<li>采用IP和以太网的技术，网络可靠性不如专有网络(Fiber Channel等。。。)</li>\n</ol>\n<p>因为上面的三个原因可能引申出来的另外的假设  </p>\n<ol start=\"4\">\n<li>系统越大，局部组件失效的概率越大。（长时间的运行时间，失效、修复、再失效是正常的状况而不能当为异常的情况去考虑）</li>\n<li>由于局部失效的概率高，因此需要必须容忍部分节点失败，并且能够保持对外提供可用的服务</li>\n</ol>\n<p><b><font color=\"#FF0000\">所以实际上我们目前大部分的分布式的系统是需要在不可靠的硬件上面通过软件容错来构建可靠的系统。</font></b></p>\n\n        <h3 id=\"所以分布式系统遇到的问题可以分为三个大类\"   >\n          <a href=\"#所以分布式系统遇到的问题可以分为三个大类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>所以分布式系统遇到的问题可以分为三个大类</h3>\n      <ol>\n<li>网络类问题  </li>\n<li>时钟问题  </li>\n<li>节点软件和硬件的问题  </li>\n</ol>\n\n        <h2 id=\"网络问题\"   >\n          <a href=\"#网络问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>网络问题</h2>\n      <p>对于上面的假设（主要是成本考虑）来说，一般都会采用无共享的方式来构建集群。</p>\n<p>由于通常使用的都是以太网来构建，而且以太网是异步的网络。可能会出现下面的这些情况</p>\n<ol>\n<li>请求丢失  </li>\n<li>请求再队列等待，无法发送（网络问题或者接收方繁忙在内核的队列中等待）  </li>\n<li>远程接收节点失效（节点崩溃）  </li>\n<li>远程节点无法响应  </li>\n<li>远程节点有返回，但是返回过程中丢失  </li>\n<li>远程节点处理请求，但是在返回时候被延时处理（优先级问题， 或者网络问题或则和发送方阻塞了）  </li>\n</ol>\n<p>此处需要多引入一个新概念，网络分区</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">网络分区（Network Partition）：当网络的一部分由于网络故障而与其他部分隔开，称之为网络分区或者网络分片</span><br></pre></td></tr></table></div></figure>\n<p>在工程的实践中，网络故障(丢包、链路中断、路由问题、物理设备损坏)的概率是远比想象中高， 因此在基于我们假设的前提的环境下面，必须要把网络分区和网络故障接入到软件中进行容错。</p>\n<p>对于如何处理检测是否故障，需要判断的一个问题是，是节点服务上面出现了真实的故障，还是网络的不可靠导致的服务失效的表现。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在实际生产的实践中有这样的方法来快速的在本应用层（网络正常的情况下）来进行简单的判断</span><br><span class=\"line\">1. 通过服务注册的心跳来注册自己的服务存活，并且把死亡状态的服务实例剔除出可用服务中</span><br><span class=\"line\">2. 检测进程是否崩溃，如果崩溃发送一个信号。（或者在我的工作经历中，使用一个进程去定时检测进程是否存活，失败了发送信号使得资源进行重启的尝试，并且上报告警）</span><br><span class=\"line\">3. 通过交换机去查询网络的状况</span><br><span class=\"line\">4. 通过中间件的自身监控（如Rabbitmq的web界面）来监控中间件的执行状况</span><br><span class=\"line\">5. 定期去尝试访问网络是否通达</span><br></pre></td></tr></table></div></figure>\n<p>但是最终我们唯一能够完全判断故障的方法只有超时，来保证节点是不可用的状态（为了保证网络的不可靠问题）。</p>\n\n        <h3 id=\"超时引入的问题\"   >\n          <a href=\"#超时引入的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>超时引入的问题</h3>\n      <p>我们如何能够判断什么时候才是最好的超时的判断间隔呢？</p>\n<p>对于上面的这个问题， 我们引入两个问题的前置的讨论  </p>\n<ol>\n<li>是什么导致我们会出现网络的不稳定  </li>\n<li>如果出现超时之后，会有怎样的影响，会导致什么样的后果  </li>\n</ol>\n\n        <h4 id=\"网络不稳定的原因\"   >\n          <a href=\"#网络不稳定的原因\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>网络不稳定的原因</h4>\n      <p>根本的原因： 在设计目前的TCP/IP的协议和方法的时候，我们的目的是为了尽可能高的提高资源的利用率<br>设计的思想： 通过动态分配和竞争的机制使得动态决定那个包被发送，但是这样的方法必然会引入排队的机制  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 出现网络不稳定的原因可能如下</span><br><span class=\"line\">1. 对于交换机的角度，会有多条等待队列来进行数据报文的转发，如果符合过重，则需要等待轮询机制来等待发送的机会，并且如果数据量过多的情况下，也有可能出现数据报文被丢弃，然后被不断重试的现象</span><br><span class=\"line\">2. 在服务器的处理中，因为Linux内核处理接收到的报文也是类似于交换机的处理模式，通过队列来对接受到的包进行排序以及复制到用户态，因此也是需要一定的时间需要处理</span><br><span class=\"line\">3. 在TCP的协议中的重传的机制也会根据返回的报文的控制字段来减小发送窗口的大小来减少对接受方的压力，可能导致排队会提前到发送方的等待队列中。并且重传机制会进行多次的重试，引入了隐形的超时时间</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"调用超时（网络超时）可能会导致的后果\"   >\n          <a href=\"#调用超时（网络超时）可能会导致的后果\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>调用超时（网络超时）可能会导致的后果</h4>\n      <p>主要的影响是发生了责任的转移，可能带来可能的影响  </p>\n<ol>\n<li>命令的重复执行  </li>\n<li>数据迁移  </li>\n<li>当整个系统处于高负荷的状态，可能会把其他正常的部分通过转移职责导致整个系统被拖垮  </li>\n</ol>\n<p>因此我们必须很小心调整这个超时的阈值,如果在以前的情况下，可能需要系统管理员对于在生产环境的情况下调整一定的参数来慢慢测试得出一个最优值。<br>但是在最近的组建的实现中有两种新的思路</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 通过内部的一个故障检测器来计算成功率来进行对超时阈值的控制（Akka， Cassandra， Hytrsix中有使用此种方法）</span><br><span class=\"line\">2. 通过对数据的采集清洗和分析（AIOPS）（可能是APM(Application Performance Metric)的埋点采集数据以及对监控数据的整体清洗通过一些机器学习的模型来计算出超时的阈值）</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"时钟问题\"   >\n          <a href=\"#时钟问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时钟问题</h2>\n      <p>分布式的系统的时钟问题也是一个非常值得重视的问题，后面会有我自己的工作案例来说明可能出现的情况的严重性。</p>\n<p>其实对于时间我们一般分为两种的应用方式</p>\n<ol>\n<li>在一段时间内的统计数据（时间段）</li>\n<li>某些时间点是否有指定动作完成或某个历史行为的发生的时间点</li>\n</ol>\n\n        <h3 id=\"服务器时间的维护方式以及问题\"   >\n          <a href=\"#服务器时间的维护方式以及问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>服务器时间的维护方式以及问题</h3>\n      <p>每个机器的时间可以通过两种方式来共同维护</p>\n<ol>\n<li>本地时间（通过主板的石英振荡器来维护）</li>\n<li>通过与一个准确的时间获取源来定是同步时间（NTP和Chrony就是服务于方面的协议）</li>\n</ol>\n<p>这两种的结合不一定能够保证这样的可信赖的分布式集群中的时间就必然是同步的</p>\n<ol>\n<li>本地时间本来每个节点都可能会出现偏差</li>\n<li>同步时间的时候必须通过网络来进行同步，而在我们上面提及的假设中，网络是不可靠的，因此可能会出现失败的情况。 </li>\n<li>NTP如果发现时间差别太大（实际生产中是时间差&gt;=10分钟的情况下）的话会拒绝同步（但是Chrony并没有此问题）</li>\n<li>闰秒的问题</li>\n</ol>\n<p>当然可以像Google维护Spanner集群那样采用高精度的原子钟加上GPS定位来保证错误在一定的可接受范围内运行（一般误差的单位为5微妙）。但是不是每个分布式系统都能够有如此之高的维护成本去使用这种方式来</p>\n\n        <h3 id=\"时钟的概念\"   >\n          <a href=\"#时钟的概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时钟的概念</h3>\n      <p>时钟可以分解为两个时钟的概念</p>\n<ol>\n<li>物理时钟<br>物理时钟:包括了两种一个是墙上时钟，一个是单调时钟。可以理解为可以通过系统时间相关的API进行获取的时钟。</li>\n<li>逻辑时钟<br>逻辑时钟：可以理解为分布式系统中全局的单调递增的事件ID，事件发生顺序与此相同。</li>\n</ol>\n\n        <h4 id=\"物理时钟\"   >\n          <a href=\"#物理时钟\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>物理时钟</h4>\n      <p>需要先引入一个时间调整的概念：</p>\n<!-- ![时间跳变说明图](/assets/img/posts/TimeJump.png)   -->\n<img src=\"/2019/08/21/intro-distributed-system/TimeJump.png\" class=\"\" title=\"时间跳变说明图\">\n<p>如果把时间以时间轴的方式来进行表达，往时间变大的方向调整为向前调整，往时间变小的方向调整的是向后调整。<br>只要发生了时间的变动，我们都可以称之为服务器发生了时间跳变。</p>\n<p><b><font color=\"\">1. 墙上时钟 </font> </b><br><br>根据日历返回当前的时钟，就是我们平时在Linux上直接使用date命令或者语言内置的时间相关的api的输出。<br>这种时钟可以与时间同步服务器后同步后进行修改，可能会出现向前调整或者向后调整的可能性</p>\n<p><b><font color=\"\">2. 单调时钟</font></b><br><br>用于： 适合测量持续的时间段<br>单调时钟的特性：<br>    1. 保证只会向前调整<br>    2. 不需要进行同步    </p>\n\n        <h4 id=\"计算和调整的方式\"   >\n          <a href=\"#计算和调整的方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>计算和调整的方式</h4>\n      <p>在一个时间点进行对单调时间的获取，然后完成某项工作后，再去检查时间。但是这段时间的差值并没有太大的意义。</p>\n\n        <h4 id=\"时间与事件的顺序问题\"   >\n          <a href=\"#时间与事件的顺序问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>时间与事件的顺序问题</h4>\n      <p>当两个客户端对于一个分布式的数据库（非Raft或者Paxos类型，如Riak）分别进行写入的情况下（此处假设先写入的客户端为A，晚写入的客户端为B）  </p>\n<!-- ![事件与时序冲突](/assets/img/posts/Time&EventMissmatch.png) -->\n<img src=\"/2019/08/21/intro-distributed-system/Time&EventMissmatch.png\" class=\"\" title=\"事件与时序冲突\">\n<p>当B虽然在发生的时间比A要晚，但是B在集群中同步完成的时间比A要早的情况写。即对外部来说A还未写入成功的情况下，先执行了B的操作，可能导致B的操作丢失（如果B的操作是依赖于A先写入的操作）。<br>上面是一个非常经典的关于分布式集群时间与事件的顺序问题。然而这种问题即使在时间同步服务精度再再提高的情况下，也无法保证它的执行的顺序与时间是一致的。  </p>\n\n        <h4 id=\"工作上发生过与物理时间相关的问题\"   >\n          <a href=\"#工作上发生过与物理时间相关的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>工作上发生过与物理时间相关的问题</h4>\n      <p><b>问题1： 发生时间跳变后，导致任务的调度器不再调度任务的情况  </b>  </p>\n<!-- ![调度器时间跳变问题](/assets/img/posts/SchdulerTimeJump.png)   -->\n<img src=\"/2019/08/21/intro-distributed-system/SchdulerTimeJump.png\" class=\"\" title=\"调度器时间跳变问题\">\n<pre><code>现象的描述： \n调度器默认应该定时把任务调度到线程上面，但是查看日志后发现任务并没有被调度   \n原因解释：    \n时间发生了向后的跳变，但是跳变的幅度大于调度的间隔，导致系统中认为调度成功，之后就没有追踪下面的状态（因为当时那部分代码的实现是再调度的时候修改调度的时间为last调度时间）    \n解决方法：    \n把时间从墙上时间更换为单调时间，然后添加检查执行的间隔即可。  </code></pre>\n<p><b>问题2：同步时间后，由于时间差溢出导致结果溢出的问题  </b><br><br>    现象描述：<br>    从Ceph Mgr获取单个采集数据的情况下，然后发现数据变得异常的大，是一个int64是随机数<br>    原因解释：<br>    因为采用的是墙上的时候，但是发生了时间的向后调变，导致计算出来的值发生异常<br>    解决方法：<br>    把墙上时间更换为单调时间  </p>\n\n        <h4 id=\"逻辑时钟\"   >\n          <a href=\"#逻辑时钟\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>逻辑时钟</h4>\n      <p>做法： 需要一个全局的单调递增的ID。<br>但是是否可以使用同步后的时间来做呢？<br>答： 不可以。因为还是时间精度的不确定性。</p>\n\n        <h2 id=\"节点本身的问题（硬件和软件）\"   >\n          <a href=\"#节点本身的问题（硬件和软件）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>节点本身的问题（硬件和软件）</h2>\n      <p>比较极端但是可能出现率比较高的场景是进程出现暂停的情况</p>\n<ol>\n<li>带GC的编程语言的GC(Garbage collection) halt</li>\n<li>虚拟化环境的虚拟机的暂停</li>\n<li>电脑发生休眠或者断电</li>\n<li>上下文切换的情况下卡住了</li>\n<li>执行同步磁盘的操作的时候（如fsync操作）</li>\n<li>接收到信号导致进程退出的情况下</li>\n</ol>\n\n        <h1 id=\"在不可靠硬件构建可靠软件需要满足的条件和假设\"   >\n          <a href=\"#在不可靠硬件构建可靠软件需要满足的条件和假设\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>#在不可靠硬件构建可靠软件需要满足的条件和假设</h1>\n      <p>此部分为DDIA第8章的描述总结，可以理解成为读书笔记    </p>\n\n        <h2 id=\"真相由多数决定（重要的判定条件）\"   >\n          <a href=\"#真相由多数决定（重要的判定条件）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>真相由多数决定（重要的判定条件）</h2>\n      <p>节点不能通过自己的信息来判断自身的状态。因为节点可能出现失效、假死、甚至无法恢复的状况.可能出现的场景如下</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 节点成功收到请求，但是因为路由问题，无法进行返回，超时后而被判失效</span><br><span class=\"line\">2. 半断开的节点发现自己的信息没有被其他节点所确认，意识到自己网络出现问题</span><br><span class=\"line\">3. GC halt导致无法接受请求，但是对于应用来说，切回到工作状态时候，自身状态没有变化</span><br></pre></td></tr></table></div></figure>\n<p>以上的多种情景都是实际出现问题，但是自身的状态并不会改变，因为没有收到其他节点的通知，它会一直维持原来的状态。<br>所以分布式的算法依赖节点间的相互投票与最小投票数（使用Quorum机制，m&gt;=(n+1)/2）进行对比来产生结果,由于一个集群不会存在两个多数在同事做出相互冲突的决定，减少对特定节点的依赖。</p>\n<p>基于上面所提及节点不能通过自己的信息来判断自己的状态，我们讨论一个比较常见的问题，主节点与锁是比较常见的使用方法</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可能的出现的场景</span><br><span class=\"line\">1. 只允许一个节点作为数据库分区的主节点（Multi-Raft是其中的一种实现）</span><br><span class=\"line\">2. 只允许一个事务或者客户端持有特定资源的锁，以防止同时并发写入带来的数据被破坏的问题</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"如果由自己的状态决定可能会出现的问题\"   >\n          <a href=\"#如果由自己的状态决定可能会出现的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如果由自己的状态决定可能会出现的问题</h3>\n      <p>但是此处我们的假设时在分布式系统中，那么有可能出现节点中间出现了角色的切换，但是如果不加以对状态的判断，可能会出现这样的问题<br>问题描述  </p>\n<!-- ![客户端锁问题](/assets/img/posts/lockingproblem.png)   -->\n<img src=\"/2019/08/21/intro-distributed-system/lockingproblem.png\" class=\"\" title=\"客户端锁问题\">\n<p>客户端写入存储的时候需要先从分布式服务中获取锁，有两个客户端在线，客户端A先从服务中获取锁，然后发生了进程halt状态（可能是GC或者其他的原因）<br>如果不加判断的情况下，在客户端A halt的状态的情况下，客户端B获得锁并且写入存储成功，然后客户端A从Halt状态中回复正常，客户端A认为锁还在，然后写入存储，<br>如果两个客户端写入的是同一个文件的话，数据可能会出现问题。  </p>\n\n        <h3 id=\"解决上面的问题\"   >\n          <a href=\"#解决上面的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>解决上面的问题</h3>\n      <p>对于上面的问题，我们可以使用一个Fencing令牌来解决这个问题。(此机制到后面的文章还会继续详细讲解)  </p>\n<!-- ![Fencing令牌解决锁问题](/assets/img/posts/lockingproblem2.png)   -->\n<img src=\"/2019/08/21/intro-distributed-system/lockingproblem2.png\" class=\"\" title=\"Fencing令牌解决锁问题\">\n<p>我们在客户端A获取锁的时候给令牌赋予一个值，为33。 在客户端B获取锁的时候赋予一个令牌值34。<br>当B写入完成后，存储会把已写入令牌改为34，下一次分发的令牌为35， 这样的话，如果A带上33的令牌写入的时候直接被拒绝，能够保证一致性。<br>实际上上面这种方法不仅加上了一个令牌，而且在服务器端会有一个关于令牌的校验。这种做法非常常见。</p>\n\n        <h2 id=\"理论系统模型与现实\"   >\n          <a href=\"#理论系统模型与现实\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>理论系统模型与现实</h2>\n      <p>对于一个在现实中能够容错的分布式系统，我们需要对预期的系统错误证明形式化的描述。我们通过定义部分的系统模型来形式化描述算法的前提条件。 </p>\n<h3><b><span class=\"thirdtitle\">计时模型</span></b></h3>\n#### 同步模型\n假定有上界网络延迟和上界进程的暂停和上界时钟误差。（但是这个模型一般不存在，因为以太网的不可靠性，除非使用更加稳定的网络介质，并且使用高精度时间设备同步）\n#### 部分同步模型\n大多数情况下像一个同步系统运行，但是会有超出网络延迟，进程暂停和时钟漂移的上界。这个就是比较现实的模型，就是上面我们提到的真实环境可能出现的情况的总和。而且大部分时间比较稳定，小部分时间会有背离，但是发生背离就会出现三者中的组合的情况出现。\n#### 异步模型\n\n\n<h3><b><span class=\"thirdtitle\">节点失效模型</span></b></h3>\n#### 崩溃-中止模型\n节点以一种特定的方式发生故障，故障后，出现系统崩溃，并且节点不会再添加进入集群中，无法恢复\n#### 崩溃-恢复模型\n节点可能会在任何时候发生崩溃，并且会在未知的时间长度来进行恢复。但是节点上只要持久性存储的数据都可以在恢复之后得以保存，内存的状态会消失。\n#### 拜占庭失效\n在非可信任的集群中进行共识的计算，可能会出现作弊、欺诈的操作（区块链上面的假设的环境）  \n所以满足我们实际生产环境（互联网或者企业内部的环境）的是 部分同步模型+ 崩溃恢复模型的组合。\n\n<p>我们目前的分布式的环境是 崩溃-恢复模型+ 部分同步的模型 </p>\n\n        <h3 id=\"分布式共识算法的正确性必须要有以下的性质\"   >\n          <a href=\"#分布式共识算法的正确性必须要有以下的性质\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识算法的正确性必须要有以下的性质</h3>\n      <ol>\n<li>唯一性<br>两个令牌不能获得相同的值  </li>\n<li>单调递增<br>如果请求x返回令牌tx， 请求y返回了令牌ty, 且x在y开始之前先完成，tx &lt; ty  </li>\n<li>可用性<br>请求令牌的节点如果不发生崩溃最终一定能收到响应（无论是对应用来说正确或者错误的回答）  </li>\n</ol>\n\n        <h4 id=\"分布式共识算法的安全性和活性\"   >\n          <a href=\"#分布式共识算法的安全性和活性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分布式共识算法的安全性和活性</h4>\n      <p>在正确性中其实可以再进行细分分为安全性和活性（理解上，并非准确的定义，准确的定义可以查看FLP的理论）：<br>安全性： 没有发生意外<br>活性： 预期的事情一定会发生（最终会发生）  </p>\n<p>如果违反了安全的属性，我们可以找到发生特定时间的时间点。但是违反安全属性的事件发生，必定不可逆，数据丢失。<br>活性的话无法明确具体发生的时间点，但是希望再未来某个时间点能够达到要求。  </p>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <p>PS: 文章中部分的图来源是来自于《数据密集型应用系统设计》，为PDF翻译的截图，截图的引用在<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/hyhlinux/DDIA/blob/master/ch8.md\" >此处</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>。如果涉及到版权的问题，请通知我，我会使用工具继续重画。</p>\n<ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.ibm.com/support/knowledgecenter/en/SSAL2T_8.2.0/com.ibm.cics.tx.doc/concepts/c_wht_is_distd_comptg.html\" >IBM Defination of Distributed System</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://book.douban.com/subject/30329536/\" >数据密集型应用系统设计</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/\" >FLP Impossibility</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://en.wikipedia.org/wiki/Byzantine_fault\" >拜占庭错误</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.usenix.org/legacy/events/osdi99/full_papers/castro/castro_html/castro.html\" >拜占庭容错</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/basho/riak_core\" >Riak</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n"},{"title":"Go语言切片技巧","date":"2019-09-03T02:07:38.000Z","_content":"\n\n<!-- ---\nlayout: post\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-09-03 10:07:38 +0800'\ncategory: go\nsummary: Go Slice \nthumbnail: go.png\n--- -->\n\n\n\n# 添加元素到切片中\n\n##  添加元素到尾部\n```\nvar a []int\n//  添加元素(后面的元素都需要解包）\nappend(a, 0)\n// 添加切片(后面的元素都需要解包）\nappend(a, []int{1,2,3}...)\n```\n\n## 添加元素到头部\n```\nvar a []int\n//  添加元素(后面的元素都需要解包）  \na = append([]int{1}, a...)\n// 添加切片(后面的元素都需要解包）  \na = append([]int{1,2,3}, a...)  \n```\n\n## 添加指定元素到切片中\n性能较低的方法（会产生中间过渡切片）  \n```\nvar a []int\na = append(a[:i], append([]int{1,2}, a[i:]...)...)  // 在第i个元素插入切片\na = append(a[:i], append([]int{1}, a[i:]...)...)     //  在第i个元素插入元素\n```\n\n性能较高的方法\n```\n//  插入单个元素\na = append(a, 0)\ncopy(a[i+1:],  a[i:])\na[i] = x \n\n//  添加多个元素(一个切片）\n//  b= []int{1,2,3}\na = append(a,b..)\ncopy(a[i+len(b):],  a[i:])\ncopy(a[i:], b) \n```\n\n\n# 删除切片元素\n\n## 删除结尾元素\n```\na = []int{1,2,3}\n// 删除单个元素\na = a[:len(a)-1]\n// 删除多个元素\na = a[:len(a)-N]\n```\n\n## 删除开头元素\n```\na = []int{1,2,3}\n// 删除单个元素\na = a[1:]\n// 删除多个元素\na = a[N:]\n```\n  \n不移动指针的方法(把后面元素往前移动)， 用到了空指针  \n```\na = []int{1,2,3}\n// 删除单个元素\na = append(a[:0], a[1:]...)  \n// 删除多个元素\na =  append(a[:0], a[N:]...)  \n\n//  使用Copy来进行处理\na = []int{1,2,3}\na = a[:copy(a, a[1:])]\na = a[:copy(a, a[N:])]\n```\n\n## 删除中间元素\n```\na = []int{1,2,3,4,5}\na = append(a[:i], a[i+1:]...)\na = append(a[:i], a[i+N:]...)\n\na = a[:i+copy(a[i:], a[i+1:])]\na = a[:i+copy(a[i:], a[i+N:])]\n```\n\n# 切片的实现原理及使用的注意事项  \n切片本质上是对底层数组的一个数据的引用。但是它是一个动态的结构。它的底层结构是这样的  \n```\ntype SliceHeader struct{\n    Data uintptr\n    Len   int  //  实际已经使用的容量\n    Cap   int  //  最大的容量\n}\n```\n\n<!-- ![goSlice](/assets/img/posts/GoSlice.png) -->\n{% asset_img GoSlice.png goSlice %}\n\n\n可以看出实际上这两个切片都是指向同一个数组的。但是如果当切片进行扩展后，会变成这样。  \n\n<!-- ![goSliceE](/assets/img/posts/GoSliceExtend.png) -->\n{% asset_img GoSliceExtend.png goSliceE %}\n\n  \n可以看出，因为原来的底层数组因为长度已经不足以Slice进行扩展，因此Slice会先去创建一个新的底层数组，并且把原来的元素加入到新创建的数组中，并且再把新插入的元素插入到新数组中。然后把原来指向的底层数组的Reference Count 减一。  \n\n## 使用的技巧\n1. 因为如果append进去切片的时候，len = cap 就会出现内存的申请和数据的复制，这样会使得比较慢。使用时尽量去减少触发内存分配的次数和分配内存的大小。\n2. 对于切片来说，即使是空切片，cap=0, len=0, 它实际上也不会是nil, 因此判断一个切片是否为空，应该使用len($slice_name) == 0 来继续判断。\n\n## 切片GC的问题\n一个比较经常的情况，对底层数组的某一个内存的引用，导致整个数组无法被GC。\n\n### 变量引用的情况\n```\nfunc FindPhoneNumber(filename string) []byte{\n\tb, _ := ioutil.ReadFile(filename)\n\treturn regexp.MustCompile(\"[0-9]+\").Find(b)\n}\n```\n\n上面的这段代码里面，因为返回的地方是一个切片引用了b的底层数组，导致b的底层数组会一直在内存中。  \n\n解决上面的问题，可以使用传值把需要用到的值传到一个新的切片里面，这样就能减少依赖。\n```\nfunc FindPhoneNumber(filename string) []byte{\n\tb, _ := ioutil.ReadFile(filename)\n\tb =  regexp.MustCompile(\"[0-9]+\").Find(b)\n    return append([]byte{}, b)\n}\n```\n\n### 删除变量的情况\n\n```\nvar a *[]int{1,2,3,4,4,5,6}\na = a[:len(a)-1] // 被删除的最后一个元素仍然被引用\n```\n\n保险的处理方法, 把需要删除的元素设置为nil，然后再去进行切片\n```\nvar a *[]int{1,2,3,4,4,5,6}\na[len(a)-1] = nil\na = a[:len(a)-1] // 被删除的最后一个元素仍然被引用\n```","source":"_posts/go-slice.md","raw":"---\ntitle: Go语言切片技巧\ndate: 2019-09-03 10:07:38\ntags: Go\n---\n\n\n<!-- ---\nlayout: post\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-09-03 10:07:38 +0800'\ncategory: go\nsummary: Go Slice \nthumbnail: go.png\n--- -->\n\n\n\n# 添加元素到切片中\n\n##  添加元素到尾部\n```\nvar a []int\n//  添加元素(后面的元素都需要解包）\nappend(a, 0)\n// 添加切片(后面的元素都需要解包）\nappend(a, []int{1,2,3}...)\n```\n\n## 添加元素到头部\n```\nvar a []int\n//  添加元素(后面的元素都需要解包）  \na = append([]int{1}, a...)\n// 添加切片(后面的元素都需要解包）  \na = append([]int{1,2,3}, a...)  \n```\n\n## 添加指定元素到切片中\n性能较低的方法（会产生中间过渡切片）  \n```\nvar a []int\na = append(a[:i], append([]int{1,2}, a[i:]...)...)  // 在第i个元素插入切片\na = append(a[:i], append([]int{1}, a[i:]...)...)     //  在第i个元素插入元素\n```\n\n性能较高的方法\n```\n//  插入单个元素\na = append(a, 0)\ncopy(a[i+1:],  a[i:])\na[i] = x \n\n//  添加多个元素(一个切片）\n//  b= []int{1,2,3}\na = append(a,b..)\ncopy(a[i+len(b):],  a[i:])\ncopy(a[i:], b) \n```\n\n\n# 删除切片元素\n\n## 删除结尾元素\n```\na = []int{1,2,3}\n// 删除单个元素\na = a[:len(a)-1]\n// 删除多个元素\na = a[:len(a)-N]\n```\n\n## 删除开头元素\n```\na = []int{1,2,3}\n// 删除单个元素\na = a[1:]\n// 删除多个元素\na = a[N:]\n```\n  \n不移动指针的方法(把后面元素往前移动)， 用到了空指针  \n```\na = []int{1,2,3}\n// 删除单个元素\na = append(a[:0], a[1:]...)  \n// 删除多个元素\na =  append(a[:0], a[N:]...)  \n\n//  使用Copy来进行处理\na = []int{1,2,3}\na = a[:copy(a, a[1:])]\na = a[:copy(a, a[N:])]\n```\n\n## 删除中间元素\n```\na = []int{1,2,3,4,5}\na = append(a[:i], a[i+1:]...)\na = append(a[:i], a[i+N:]...)\n\na = a[:i+copy(a[i:], a[i+1:])]\na = a[:i+copy(a[i:], a[i+N:])]\n```\n\n# 切片的实现原理及使用的注意事项  \n切片本质上是对底层数组的一个数据的引用。但是它是一个动态的结构。它的底层结构是这样的  \n```\ntype SliceHeader struct{\n    Data uintptr\n    Len   int  //  实际已经使用的容量\n    Cap   int  //  最大的容量\n}\n```\n\n<!-- ![goSlice](/assets/img/posts/GoSlice.png) -->\n{% asset_img GoSlice.png goSlice %}\n\n\n可以看出实际上这两个切片都是指向同一个数组的。但是如果当切片进行扩展后，会变成这样。  \n\n<!-- ![goSliceE](/assets/img/posts/GoSliceExtend.png) -->\n{% asset_img GoSliceExtend.png goSliceE %}\n\n  \n可以看出，因为原来的底层数组因为长度已经不足以Slice进行扩展，因此Slice会先去创建一个新的底层数组，并且把原来的元素加入到新创建的数组中，并且再把新插入的元素插入到新数组中。然后把原来指向的底层数组的Reference Count 减一。  \n\n## 使用的技巧\n1. 因为如果append进去切片的时候，len = cap 就会出现内存的申请和数据的复制，这样会使得比较慢。使用时尽量去减少触发内存分配的次数和分配内存的大小。\n2. 对于切片来说，即使是空切片，cap=0, len=0, 它实际上也不会是nil, 因此判断一个切片是否为空，应该使用len($slice_name) == 0 来继续判断。\n\n## 切片GC的问题\n一个比较经常的情况，对底层数组的某一个内存的引用，导致整个数组无法被GC。\n\n### 变量引用的情况\n```\nfunc FindPhoneNumber(filename string) []byte{\n\tb, _ := ioutil.ReadFile(filename)\n\treturn regexp.MustCompile(\"[0-9]+\").Find(b)\n}\n```\n\n上面的这段代码里面，因为返回的地方是一个切片引用了b的底层数组，导致b的底层数组会一直在内存中。  \n\n解决上面的问题，可以使用传值把需要用到的值传到一个新的切片里面，这样就能减少依赖。\n```\nfunc FindPhoneNumber(filename string) []byte{\n\tb, _ := ioutil.ReadFile(filename)\n\tb =  regexp.MustCompile(\"[0-9]+\").Find(b)\n    return append([]byte{}, b)\n}\n```\n\n### 删除变量的情况\n\n```\nvar a *[]int{1,2,3,4,4,5,6}\na = a[:len(a)-1] // 被删除的最后一个元素仍然被引用\n```\n\n保险的处理方法, 把需要删除的元素设置为nil，然后再去进行切片\n```\nvar a *[]int{1,2,3,4,4,5,6}\na[len(a)-1] = nil\na = a[:len(a)-1] // 被删除的最后一个元素仍然被引用\n```","slug":"go-slice","published":1,"updated":"2021-01-21T07:12:15.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6irar50001k9i59fu05t2q","content":"<!-- ---\nlayout: post\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-09-03 10:07:38 +0800'\ncategory: go\nsummary: Go Slice \nthumbnail: go.png\n--- -->\n\n\n\n\n        <h1 id=\"添加元素到切片中\"   >\n          <a href=\"#添加元素到切片中\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>添加元素到切片中</h1>\n      \n        <h2 id=\"添加元素到尾部\"   >\n          <a href=\"#添加元素到尾部\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>添加元素到尾部</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a []int</span><br><span class=\"line\">&#x2F;&#x2F;  添加元素(后面的元素都需要解包）</span><br><span class=\"line\">append(a, 0)</span><br><span class=\"line\">&#x2F;&#x2F; 添加切片(后面的元素都需要解包）</span><br><span class=\"line\">append(a, []int&#123;1,2,3&#125;...)</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"添加元素到头部\"   >\n          <a href=\"#添加元素到头部\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>添加元素到头部</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a []int</span><br><span class=\"line\">&#x2F;&#x2F;  添加元素(后面的元素都需要解包）  </span><br><span class=\"line\">a &#x3D; append([]int&#123;1&#125;, a...)</span><br><span class=\"line\">&#x2F;&#x2F; 添加切片(后面的元素都需要解包）  </span><br><span class=\"line\">a &#x3D; append([]int&#123;1,2,3&#125;, a...)  </span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"添加指定元素到切片中\"   >\n          <a href=\"#添加指定元素到切片中\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>添加指定元素到切片中</h2>\n      <p>性能较低的方法（会产生中间过渡切片）  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a []int</span><br><span class=\"line\">a &#x3D; append(a[:i], append([]int&#123;1,2&#125;, a[i:]...)...)  &#x2F;&#x2F; 在第i个元素插入切片</span><br><span class=\"line\">a &#x3D; append(a[:i], append([]int&#123;1&#125;, a[i:]...)...)     &#x2F;&#x2F;  在第i个元素插入元素</span><br></pre></td></tr></table></div></figure>\n<p>性能较高的方法</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;  插入单个元素</span><br><span class=\"line\">a &#x3D; append(a, 0)</span><br><span class=\"line\">copy(a[i+1:],  a[i:])</span><br><span class=\"line\">a[i] &#x3D; x </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;  添加多个元素(一个切片）</span><br><span class=\"line\">&#x2F;&#x2F;  b&#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">a &#x3D; append(a,b..)</span><br><span class=\"line\">copy(a[i+len(b):],  a[i:])</span><br><span class=\"line\">copy(a[i:], b) </span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"删除切片元素\"   >\n          <a href=\"#删除切片元素\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>删除切片元素</h1>\n      \n        <h2 id=\"删除结尾元素\"   >\n          <a href=\"#删除结尾元素\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>删除结尾元素</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 删除单个元素</span><br><span class=\"line\">a &#x3D; a[:len(a)-1]</span><br><span class=\"line\">&#x2F;&#x2F; 删除多个元素</span><br><span class=\"line\">a &#x3D; a[:len(a)-N]</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"删除开头元素\"   >\n          <a href=\"#删除开头元素\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>删除开头元素</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 删除单个元素</span><br><span class=\"line\">a &#x3D; a[1:]</span><br><span class=\"line\">&#x2F;&#x2F; 删除多个元素</span><br><span class=\"line\">a &#x3D; a[N:]</span><br></pre></td></tr></table></div></figure>\n\n<p>不移动指针的方法(把后面元素往前移动)， 用到了空指针  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 删除单个元素</span><br><span class=\"line\">a &#x3D; append(a[:0], a[1:]...)  </span><br><span class=\"line\">&#x2F;&#x2F; 删除多个元素</span><br><span class=\"line\">a &#x3D;  append(a[:0], a[N:]...)  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;  使用Copy来进行处理</span><br><span class=\"line\">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">a &#x3D; a[:copy(a, a[1:])]</span><br><span class=\"line\">a &#x3D; a[:copy(a, a[N:])]</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"删除中间元素\"   >\n          <a href=\"#删除中间元素\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>删除中间元素</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; []int&#123;1,2,3,4,5&#125;</span><br><span class=\"line\">a &#x3D; append(a[:i], a[i+1:]...)</span><br><span class=\"line\">a &#x3D; append(a[:i], a[i+N:]...)</span><br><span class=\"line\"></span><br><span class=\"line\">a &#x3D; a[:i+copy(a[i:], a[i+1:])]</span><br><span class=\"line\">a &#x3D; a[:i+copy(a[i:], a[i+N:])]</span><br></pre></td></tr></table></div></figure>\n\n        <h1 id=\"切片的实现原理及使用的注意事项\"   >\n          <a href=\"#切片的实现原理及使用的注意事项\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>切片的实现原理及使用的注意事项</h1>\n      <p>切片本质上是对底层数组的一个数据的引用。但是它是一个动态的结构。它的底层结构是这样的  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type SliceHeader struct&#123;</span><br><span class=\"line\">    Data uintptr</span><br><span class=\"line\">    Len   int  &#x2F;&#x2F;  实际已经使用的容量</span><br><span class=\"line\">    Cap   int  &#x2F;&#x2F;  最大的容量</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<!-- ![goSlice](/assets/img/posts/GoSlice.png) -->\n<img src=\"/2019/09/03/go-slice/GoSlice.png\" class=\"\" title=\"goSlice\">\n\n\n<p>可以看出实际上这两个切片都是指向同一个数组的。但是如果当切片进行扩展后，会变成这样。  </p>\n<!-- ![goSliceE](/assets/img/posts/GoSliceExtend.png) -->\n<img src=\"/2019/09/03/go-slice/GoSliceExtend.png\" class=\"\" title=\"goSliceE\">\n\n\n<p>可以看出，因为原来的底层数组因为长度已经不足以Slice进行扩展，因此Slice会先去创建一个新的底层数组，并且把原来的元素加入到新创建的数组中，并且再把新插入的元素插入到新数组中。然后把原来指向的底层数组的Reference Count 减一。  </p>\n\n        <h2 id=\"使用的技巧\"   >\n          <a href=\"#使用的技巧\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用的技巧</h2>\n      <ol>\n<li>因为如果append进去切片的时候，len = cap 就会出现内存的申请和数据的复制，这样会使得比较慢。使用时尽量去减少触发内存分配的次数和分配内存的大小。</li>\n<li>对于切片来说，即使是空切片，cap=0, len=0, 它实际上也不会是nil, 因此判断一个切片是否为空，应该使用len($slice_name) == 0 来继续判断。</li>\n</ol>\n\n        <h2 id=\"切片GC的问题\"   >\n          <a href=\"#切片GC的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>切片GC的问题</h2>\n      <p>一个比较经常的情况，对底层数组的某一个内存的引用，导致整个数组无法被GC。</p>\n\n        <h3 id=\"变量引用的情况\"   >\n          <a href=\"#变量引用的情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>变量引用的情况</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func FindPhoneNumber(filename string) []byte&#123;</span><br><span class=\"line\">\tb, _ :&#x3D; ioutil.ReadFile(filename)</span><br><span class=\"line\">\treturn regexp.MustCompile(&quot;[0-9]+&quot;).Find(b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>上面的这段代码里面，因为返回的地方是一个切片引用了b的底层数组，导致b的底层数组会一直在内存中。  </p>\n<p>解决上面的问题，可以使用传值把需要用到的值传到一个新的切片里面，这样就能减少依赖。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func FindPhoneNumber(filename string) []byte&#123;</span><br><span class=\"line\">\tb, _ :&#x3D; ioutil.ReadFile(filename)</span><br><span class=\"line\">\tb &#x3D;  regexp.MustCompile(&quot;[0-9]+&quot;).Find(b)</span><br><span class=\"line\">    return append([]byte&#123;&#125;, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"删除变量的情况\"   >\n          <a href=\"#删除变量的情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>删除变量的情况</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a *[]int&#123;1,2,3,4,4,5,6&#125;</span><br><span class=\"line\">a &#x3D; a[:len(a)-1] &#x2F;&#x2F; 被删除的最后一个元素仍然被引用</span><br></pre></td></tr></table></div></figure>\n<p>保险的处理方法, 把需要删除的元素设置为nil，然后再去进行切片</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a *[]int&#123;1,2,3,4,4,5,6&#125;</span><br><span class=\"line\">a[len(a)-1] &#x3D; nil</span><br><span class=\"line\">a &#x3D; a[:len(a)-1] &#x2F;&#x2F; 被删除的最后一个元素仍然被引用</span><br></pre></td></tr></table></div></figure>","site":{"data":{}},"excerpt":"","more":"<!-- ---\nlayout: post\ntitle: \nauthor: Ray Chan(ray1888)\ndate: '2019-09-03 10:07:38 +0800'\ncategory: go\nsummary: Go Slice \nthumbnail: go.png\n--- -->\n\n\n\n\n        <h1 id=\"添加元素到切片中\"   >\n          <a href=\"#添加元素到切片中\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>添加元素到切片中</h1>\n      \n        <h2 id=\"添加元素到尾部\"   >\n          <a href=\"#添加元素到尾部\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>添加元素到尾部</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a []int</span><br><span class=\"line\">&#x2F;&#x2F;  添加元素(后面的元素都需要解包）</span><br><span class=\"line\">append(a, 0)</span><br><span class=\"line\">&#x2F;&#x2F; 添加切片(后面的元素都需要解包）</span><br><span class=\"line\">append(a, []int&#123;1,2,3&#125;...)</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"添加元素到头部\"   >\n          <a href=\"#添加元素到头部\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>添加元素到头部</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a []int</span><br><span class=\"line\">&#x2F;&#x2F;  添加元素(后面的元素都需要解包）  </span><br><span class=\"line\">a &#x3D; append([]int&#123;1&#125;, a...)</span><br><span class=\"line\">&#x2F;&#x2F; 添加切片(后面的元素都需要解包）  </span><br><span class=\"line\">a &#x3D; append([]int&#123;1,2,3&#125;, a...)  </span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"添加指定元素到切片中\"   >\n          <a href=\"#添加指定元素到切片中\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>添加指定元素到切片中</h2>\n      <p>性能较低的方法（会产生中间过渡切片）  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a []int</span><br><span class=\"line\">a &#x3D; append(a[:i], append([]int&#123;1,2&#125;, a[i:]...)...)  &#x2F;&#x2F; 在第i个元素插入切片</span><br><span class=\"line\">a &#x3D; append(a[:i], append([]int&#123;1&#125;, a[i:]...)...)     &#x2F;&#x2F;  在第i个元素插入元素</span><br></pre></td></tr></table></div></figure>\n<p>性能较高的方法</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;  插入单个元素</span><br><span class=\"line\">a &#x3D; append(a, 0)</span><br><span class=\"line\">copy(a[i+1:],  a[i:])</span><br><span class=\"line\">a[i] &#x3D; x </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;  添加多个元素(一个切片）</span><br><span class=\"line\">&#x2F;&#x2F;  b&#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">a &#x3D; append(a,b..)</span><br><span class=\"line\">copy(a[i+len(b):],  a[i:])</span><br><span class=\"line\">copy(a[i:], b) </span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"删除切片元素\"   >\n          <a href=\"#删除切片元素\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>删除切片元素</h1>\n      \n        <h2 id=\"删除结尾元素\"   >\n          <a href=\"#删除结尾元素\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>删除结尾元素</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 删除单个元素</span><br><span class=\"line\">a &#x3D; a[:len(a)-1]</span><br><span class=\"line\">&#x2F;&#x2F; 删除多个元素</span><br><span class=\"line\">a &#x3D; a[:len(a)-N]</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"删除开头元素\"   >\n          <a href=\"#删除开头元素\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>删除开头元素</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 删除单个元素</span><br><span class=\"line\">a &#x3D; a[1:]</span><br><span class=\"line\">&#x2F;&#x2F; 删除多个元素</span><br><span class=\"line\">a &#x3D; a[N:]</span><br></pre></td></tr></table></div></figure>\n\n<p>不移动指针的方法(把后面元素往前移动)， 用到了空指针  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 删除单个元素</span><br><span class=\"line\">a &#x3D; append(a[:0], a[1:]...)  </span><br><span class=\"line\">&#x2F;&#x2F; 删除多个元素</span><br><span class=\"line\">a &#x3D;  append(a[:0], a[N:]...)  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;  使用Copy来进行处理</span><br><span class=\"line\">a &#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">a &#x3D; a[:copy(a, a[1:])]</span><br><span class=\"line\">a &#x3D; a[:copy(a, a[N:])]</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"删除中间元素\"   >\n          <a href=\"#删除中间元素\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>删除中间元素</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; []int&#123;1,2,3,4,5&#125;</span><br><span class=\"line\">a &#x3D; append(a[:i], a[i+1:]...)</span><br><span class=\"line\">a &#x3D; append(a[:i], a[i+N:]...)</span><br><span class=\"line\"></span><br><span class=\"line\">a &#x3D; a[:i+copy(a[i:], a[i+1:])]</span><br><span class=\"line\">a &#x3D; a[:i+copy(a[i:], a[i+N:])]</span><br></pre></td></tr></table></div></figure>\n\n        <h1 id=\"切片的实现原理及使用的注意事项\"   >\n          <a href=\"#切片的实现原理及使用的注意事项\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>切片的实现原理及使用的注意事项</h1>\n      <p>切片本质上是对底层数组的一个数据的引用。但是它是一个动态的结构。它的底层结构是这样的  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type SliceHeader struct&#123;</span><br><span class=\"line\">    Data uintptr</span><br><span class=\"line\">    Len   int  &#x2F;&#x2F;  实际已经使用的容量</span><br><span class=\"line\">    Cap   int  &#x2F;&#x2F;  最大的容量</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<!-- ![goSlice](/assets/img/posts/GoSlice.png) -->\n<img src=\"/2019/09/03/go-slice/GoSlice.png\" class=\"\" title=\"goSlice\">\n\n\n<p>可以看出实际上这两个切片都是指向同一个数组的。但是如果当切片进行扩展后，会变成这样。  </p>\n<!-- ![goSliceE](/assets/img/posts/GoSliceExtend.png) -->\n<img src=\"/2019/09/03/go-slice/GoSliceExtend.png\" class=\"\" title=\"goSliceE\">\n\n\n<p>可以看出，因为原来的底层数组因为长度已经不足以Slice进行扩展，因此Slice会先去创建一个新的底层数组，并且把原来的元素加入到新创建的数组中，并且再把新插入的元素插入到新数组中。然后把原来指向的底层数组的Reference Count 减一。  </p>\n\n        <h2 id=\"使用的技巧\"   >\n          <a href=\"#使用的技巧\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用的技巧</h2>\n      <ol>\n<li>因为如果append进去切片的时候，len = cap 就会出现内存的申请和数据的复制，这样会使得比较慢。使用时尽量去减少触发内存分配的次数和分配内存的大小。</li>\n<li>对于切片来说，即使是空切片，cap=0, len=0, 它实际上也不会是nil, 因此判断一个切片是否为空，应该使用len($slice_name) == 0 来继续判断。</li>\n</ol>\n\n        <h2 id=\"切片GC的问题\"   >\n          <a href=\"#切片GC的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>切片GC的问题</h2>\n      <p>一个比较经常的情况，对底层数组的某一个内存的引用，导致整个数组无法被GC。</p>\n\n        <h3 id=\"变量引用的情况\"   >\n          <a href=\"#变量引用的情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>变量引用的情况</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func FindPhoneNumber(filename string) []byte&#123;</span><br><span class=\"line\">\tb, _ :&#x3D; ioutil.ReadFile(filename)</span><br><span class=\"line\">\treturn regexp.MustCompile(&quot;[0-9]+&quot;).Find(b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>上面的这段代码里面，因为返回的地方是一个切片引用了b的底层数组，导致b的底层数组会一直在内存中。  </p>\n<p>解决上面的问题，可以使用传值把需要用到的值传到一个新的切片里面，这样就能减少依赖。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func FindPhoneNumber(filename string) []byte&#123;</span><br><span class=\"line\">\tb, _ :&#x3D; ioutil.ReadFile(filename)</span><br><span class=\"line\">\tb &#x3D;  regexp.MustCompile(&quot;[0-9]+&quot;).Find(b)</span><br><span class=\"line\">    return append([]byte&#123;&#125;, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"删除变量的情况\"   >\n          <a href=\"#删除变量的情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>删除变量的情况</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a *[]int&#123;1,2,3,4,4,5,6&#125;</span><br><span class=\"line\">a &#x3D; a[:len(a)-1] &#x2F;&#x2F; 被删除的最后一个元素仍然被引用</span><br></pre></td></tr></table></div></figure>\n<p>保险的处理方法, 把需要删除的元素设置为nil，然后再去进行切片</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a *[]int&#123;1,2,3,4,4,5,6&#125;</span><br><span class=\"line\">a[len(a)-1] &#x3D; nil</span><br><span class=\"line\">a &#x3D; a[:len(a)-1] &#x2F;&#x2F; 被删除的最后一个元素仍然被引用</span><br></pre></td></tr></table></div></figure>"},{"title":"sync.Map 源码阅读","date":"2020-12-10T08:07:38.000Z","_content":"\n\n<!-- ---\nlayout: post\ntitle: sync.Map源码圆度\nauthor: Ray Chan(ray1888)\ndate: '2020-12-10 16:07:38 +0800'\ncategory: Golang\nsummary: sync.Map implate \nthumbnail: go.png\n--- -->\n\n\n# 前言\nSync.Map  是Golang 官方提供的线程安全的 map类库，因为Golang 本身自带的map并不是线程安全的，因为会有sync.Map这个类库的存在\n\n# 实现\n## 基础元素\n```\ntype Map struct {\n    mu Mutex\n\n    // read contains the portion of the map's contents that are safe for\n    // concurrent access (with or without mu held).\n    //\n    // The read field itself is always safe to load, but must only be stored with\n    // mu held.\n    //\n    // Entries stored in read may be updated concurrently without mu, but updating\n    // a previously-expunged entry requires that the entry be copied to the dirty\n    // map and unexpunged with mu held.\n    read atomic.Value // readOnly\n\n    // dirty contains the portion of the map's contents that require mu to be\n    // held. To ensure that the dirty map can be promoted to the read map quickly,\n    // it also includes all of the non-expunged entries in the read map.\n    //\n    // Expunged entries are not stored in the dirty map. An expunged entry in the\n    // clean map must be unexpunged and added to the dirty map before a new value\n    // can be stored to it.\n    //\n    // If the dirty map is nil, the next write to the map will initialize it by\n    // making a shallow copy of the clean map, omitting stale entries.\n    dirty map[interface{}]*entry\n\n    // misses counts the number of loads since the read map was last updated that\n    // needed to lock mu to determine whether the key was present.\n    //\n    // Once enough misses have occurred to cover the cost of copying the dirty\n    // map, the dirty map will be promoted to the read map (in the unamended\n    // state) and the next store to the map will make a new dirty copy.\n    misses int\n}\n\n// readOnly is an immutable struct stored atomically in the Map.read field.\ntype readOnly struct {\n    m       map[interface{}]*entry\n    amended bool // true if the dirty map contains some key not in m.\n}\ntype entry struct {\n    // p points to the interface{} value stored for the entry.\n    //\n    // If p == nil, the entry has been deleted and m.dirty == nil.\n    //\n    // If p == expunged, the entry has been deleted, m.dirty != nil, and the entry\n    // is missing from m.dirty.\n    //\n    // Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty\n    // != nil, in m.dirty[key].\n    //\n    // An entry can be deleted by atomic replacement with nil: when m.dirty is\n    // next created, it will atomically replace nil with expunged and leave\n    // m.dirty[key] unset.\n    //\n    // An entry's associated value can be updated by atomic replacement, provided\n    // p != expunged. If p == expunged, an entry's associated value can be updated\n    // only after first setting m.dirty[key] = e so that lookups using the dirty\n    // map find the entry.\n    p unsafe.Pointer // *interface{}\n}\n```\n\nsync.Map 存储数据的分为两个部分：\n1.read元素，使用的是atomic.Value 把map 当成interface进行存储；\n2. dirty 一个golang中的一个Map，用于临时存储部分新的数据（具体场景会在后面进行描述）\n\n## 写流程\n```\n1.  判断Key是否再Read部分，如果在read部分，则直接采用cas来更换，更换成功则直接返回\n2.  否则就要加锁然后修改到dirty中，\n      有三种情况：\n      1. 在Read中，但是已经被修改，cas无法修改成功（会先把这个key对应的值与mark无效的指针做对比，如果是，则需要把这个更换了的key对应的放到dirty里面）\n      2. 在dirty 中，直接进行修改\n      3. 是一个新Key的情况下，如果dirty没有key不在read中，直接修改dirty,并且把需要读修正的Flag（read.amend = true置入）\n3. 解锁\n```\n因此 如果当key在Read中，是可以保证一个比较快的实现，因为用的是cas的比较方法，而不是直接加锁去防止竞争锁带来的性能损失。\n## 读流程\n1.  读取Read中是否存在此Key，若存在则直接返回\n2.  当发现key不存在于read，并且没有读修正的时候，直接返回\n3.  发现需要读修正的情况下，会顺便把dirty中的数据置入到read中，并且返回值\n\n## LoadORStore 读写一体流程\n\n\n# 用于阅读sync.Map的触发代码\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    // for testing sync.map work\n\n    var ma sync.Map\n    k, _ := ma.Load(\"a\")\n    fmt.Println(k)\n\n    ma.Store(\"a\", 1)\n    _, _ = ma.Load(\"a\")\n    ma.Store(\"b\", 2)\n    ma.Store(\"a\", 2)\n    ma.Store(\"a\", 3)\n    p, _ := ma.Load(\"a\")\n    fmt.Println(p)\n}\n\n```\n\n竞锁的情况\n```\n\n```\n\n\n\n","source":"_posts/golang-sync-map.md","raw":"---\ntitle: sync.Map 源码阅读\ndate: 2020-12-10 16:07:38\ntags: Go\n---\n\n\n<!-- ---\nlayout: post\ntitle: sync.Map源码圆度\nauthor: Ray Chan(ray1888)\ndate: '2020-12-10 16:07:38 +0800'\ncategory: Golang\nsummary: sync.Map implate \nthumbnail: go.png\n--- -->\n\n\n# 前言\nSync.Map  是Golang 官方提供的线程安全的 map类库，因为Golang 本身自带的map并不是线程安全的，因为会有sync.Map这个类库的存在\n\n# 实现\n## 基础元素\n```\ntype Map struct {\n    mu Mutex\n\n    // read contains the portion of the map's contents that are safe for\n    // concurrent access (with or without mu held).\n    //\n    // The read field itself is always safe to load, but must only be stored with\n    // mu held.\n    //\n    // Entries stored in read may be updated concurrently without mu, but updating\n    // a previously-expunged entry requires that the entry be copied to the dirty\n    // map and unexpunged with mu held.\n    read atomic.Value // readOnly\n\n    // dirty contains the portion of the map's contents that require mu to be\n    // held. To ensure that the dirty map can be promoted to the read map quickly,\n    // it also includes all of the non-expunged entries in the read map.\n    //\n    // Expunged entries are not stored in the dirty map. An expunged entry in the\n    // clean map must be unexpunged and added to the dirty map before a new value\n    // can be stored to it.\n    //\n    // If the dirty map is nil, the next write to the map will initialize it by\n    // making a shallow copy of the clean map, omitting stale entries.\n    dirty map[interface{}]*entry\n\n    // misses counts the number of loads since the read map was last updated that\n    // needed to lock mu to determine whether the key was present.\n    //\n    // Once enough misses have occurred to cover the cost of copying the dirty\n    // map, the dirty map will be promoted to the read map (in the unamended\n    // state) and the next store to the map will make a new dirty copy.\n    misses int\n}\n\n// readOnly is an immutable struct stored atomically in the Map.read field.\ntype readOnly struct {\n    m       map[interface{}]*entry\n    amended bool // true if the dirty map contains some key not in m.\n}\ntype entry struct {\n    // p points to the interface{} value stored for the entry.\n    //\n    // If p == nil, the entry has been deleted and m.dirty == nil.\n    //\n    // If p == expunged, the entry has been deleted, m.dirty != nil, and the entry\n    // is missing from m.dirty.\n    //\n    // Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty\n    // != nil, in m.dirty[key].\n    //\n    // An entry can be deleted by atomic replacement with nil: when m.dirty is\n    // next created, it will atomically replace nil with expunged and leave\n    // m.dirty[key] unset.\n    //\n    // An entry's associated value can be updated by atomic replacement, provided\n    // p != expunged. If p == expunged, an entry's associated value can be updated\n    // only after first setting m.dirty[key] = e so that lookups using the dirty\n    // map find the entry.\n    p unsafe.Pointer // *interface{}\n}\n```\n\nsync.Map 存储数据的分为两个部分：\n1.read元素，使用的是atomic.Value 把map 当成interface进行存储；\n2. dirty 一个golang中的一个Map，用于临时存储部分新的数据（具体场景会在后面进行描述）\n\n## 写流程\n```\n1.  判断Key是否再Read部分，如果在read部分，则直接采用cas来更换，更换成功则直接返回\n2.  否则就要加锁然后修改到dirty中，\n      有三种情况：\n      1. 在Read中，但是已经被修改，cas无法修改成功（会先把这个key对应的值与mark无效的指针做对比，如果是，则需要把这个更换了的key对应的放到dirty里面）\n      2. 在dirty 中，直接进行修改\n      3. 是一个新Key的情况下，如果dirty没有key不在read中，直接修改dirty,并且把需要读修正的Flag（read.amend = true置入）\n3. 解锁\n```\n因此 如果当key在Read中，是可以保证一个比较快的实现，因为用的是cas的比较方法，而不是直接加锁去防止竞争锁带来的性能损失。\n## 读流程\n1.  读取Read中是否存在此Key，若存在则直接返回\n2.  当发现key不存在于read，并且没有读修正的时候，直接返回\n3.  发现需要读修正的情况下，会顺便把dirty中的数据置入到read中，并且返回值\n\n## LoadORStore 读写一体流程\n\n\n# 用于阅读sync.Map的触发代码\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    // for testing sync.map work\n\n    var ma sync.Map\n    k, _ := ma.Load(\"a\")\n    fmt.Println(k)\n\n    ma.Store(\"a\", 1)\n    _, _ = ma.Load(\"a\")\n    ma.Store(\"b\", 2)\n    ma.Store(\"a\", 2)\n    ma.Store(\"a\", 3)\n    p, _ := ma.Load(\"a\")\n    fmt.Println(p)\n}\n\n```\n\n竞锁的情况\n```\n\n```\n\n\n\n","slug":"golang-sync-map","published":1,"updated":"2021-01-21T07:11:59.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6irar90003k9i55pq9f6d4","content":"<!-- ---\nlayout: post\ntitle: sync.Map源码圆度\nauthor: Ray Chan(ray1888)\ndate: '2020-12-10 16:07:38 +0800'\ncategory: Golang\nsummary: sync.Map implate \nthumbnail: go.png\n--- -->\n\n\n\n        <h1 id=\"前言\"   >\n          <a href=\"#前言\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>前言</h1>\n      <p>Sync.Map  是Golang 官方提供的线程安全的 map类库，因为Golang 本身自带的map并不是线程安全的，因为会有sync.Map这个类库的存在</p>\n\n        <h1 id=\"实现\"   >\n          <a href=\"#实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实现</h1>\n      \n        <h2 id=\"基础元素\"   >\n          <a href=\"#基础元素\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基础元素</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Map struct &#123;</span><br><span class=\"line\">    mu Mutex</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; read contains the portion of the map&#39;s contents that are safe for</span><br><span class=\"line\">    &#x2F;&#x2F; concurrent access (with or without mu held).</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; The read field itself is always safe to load, but must only be stored with</span><br><span class=\"line\">    &#x2F;&#x2F; mu held.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; Entries stored in read may be updated concurrently without mu, but updating</span><br><span class=\"line\">    &#x2F;&#x2F; a previously-expunged entry requires that the entry be copied to the dirty</span><br><span class=\"line\">    &#x2F;&#x2F; map and unexpunged with mu held.</span><br><span class=\"line\">    read atomic.Value &#x2F;&#x2F; readOnly</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; dirty contains the portion of the map&#39;s contents that require mu to be</span><br><span class=\"line\">    &#x2F;&#x2F; held. To ensure that the dirty map can be promoted to the read map quickly,</span><br><span class=\"line\">    &#x2F;&#x2F; it also includes all of the non-expunged entries in the read map.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; Expunged entries are not stored in the dirty map. An expunged entry in the</span><br><span class=\"line\">    &#x2F;&#x2F; clean map must be unexpunged and added to the dirty map before a new value</span><br><span class=\"line\">    &#x2F;&#x2F; can be stored to it.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; If the dirty map is nil, the next write to the map will initialize it by</span><br><span class=\"line\">    &#x2F;&#x2F; making a shallow copy of the clean map, omitting stale entries.</span><br><span class=\"line\">    dirty map[interface&#123;&#125;]*entry</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; misses counts the number of loads since the read map was last updated that</span><br><span class=\"line\">    &#x2F;&#x2F; needed to lock mu to determine whether the key was present.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; Once enough misses have occurred to cover the cost of copying the dirty</span><br><span class=\"line\">    &#x2F;&#x2F; map, the dirty map will be promoted to the read map (in the unamended</span><br><span class=\"line\">    &#x2F;&#x2F; state) and the next store to the map will make a new dirty copy.</span><br><span class=\"line\">    misses int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; readOnly is an immutable struct stored atomically in the Map.read field.</span><br><span class=\"line\">type readOnly struct &#123;</span><br><span class=\"line\">    m       map[interface&#123;&#125;]*entry</span><br><span class=\"line\">    amended bool &#x2F;&#x2F; true if the dirty map contains some key not in m.</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type entry struct &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; p points to the interface&#123;&#125; value stored for the entry.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; If p &#x3D;&#x3D; nil, the entry has been deleted and m.dirty &#x3D;&#x3D; nil.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; If p &#x3D;&#x3D; expunged, the entry has been deleted, m.dirty !&#x3D; nil, and the entry</span><br><span class=\"line\">    &#x2F;&#x2F; is missing from m.dirty.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty</span><br><span class=\"line\">    &#x2F;&#x2F; !&#x3D; nil, in m.dirty[key].</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; An entry can be deleted by atomic replacement with nil: when m.dirty is</span><br><span class=\"line\">    &#x2F;&#x2F; next created, it will atomically replace nil with expunged and leave</span><br><span class=\"line\">    &#x2F;&#x2F; m.dirty[key] unset.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; An entry&#39;s associated value can be updated by atomic replacement, provided</span><br><span class=\"line\">    &#x2F;&#x2F; p !&#x3D; expunged. If p &#x3D;&#x3D; expunged, an entry&#39;s associated value can be updated</span><br><span class=\"line\">    &#x2F;&#x2F; only after first setting m.dirty[key] &#x3D; e so that lookups using the dirty</span><br><span class=\"line\">    &#x2F;&#x2F; map find the entry.</span><br><span class=\"line\">    p unsafe.Pointer &#x2F;&#x2F; *interface&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>sync.Map 存储数据的分为两个部分：<br>1.read元素，使用的是atomic.Value 把map 当成interface进行存储；<br>2. dirty 一个golang中的一个Map，用于临时存储部分新的数据（具体场景会在后面进行描述）</p>\n\n        <h2 id=\"写流程\"   >\n          <a href=\"#写流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>写流程</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.  判断Key是否再Read部分，如果在read部分，则直接采用cas来更换，更换成功则直接返回</span><br><span class=\"line\">2.  否则就要加锁然后修改到dirty中，</span><br><span class=\"line\">      有三种情况：</span><br><span class=\"line\">      1. 在Read中，但是已经被修改，cas无法修改成功（会先把这个key对应的值与mark无效的指针做对比，如果是，则需要把这个更换了的key对应的放到dirty里面）</span><br><span class=\"line\">      2. 在dirty 中，直接进行修改</span><br><span class=\"line\">      3. 是一个新Key的情况下，如果dirty没有key不在read中，直接修改dirty,并且把需要读修正的Flag（read.amend &#x3D; true置入）</span><br><span class=\"line\">3. 解锁</span><br></pre></td></tr></table></div></figure>\n<p>因此 如果当key在Read中，是可以保证一个比较快的实现，因为用的是cas的比较方法，而不是直接加锁去防止竞争锁带来的性能损失。</p>\n\n        <h2 id=\"读流程\"   >\n          <a href=\"#读流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>读流程</h2>\n      <ol>\n<li> 读取Read中是否存在此Key，若存在则直接返回</li>\n<li> 当发现key不存在于read，并且没有读修正的时候，直接返回</li>\n<li> 发现需要读修正的情况下，会顺便把dirty中的数据置入到read中，并且返回值</li>\n</ol>\n\n        <h2 id=\"LoadORStore-读写一体流程\"   >\n          <a href=\"#LoadORStore-读写一体流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>LoadORStore 读写一体流程</h2>\n      \n        <h1 id=\"用于阅读sync-Map的触发代码\"   >\n          <a href=\"#用于阅读sync-Map的触发代码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>用于阅读sync.Map的触发代码</h1>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;sync&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; for testing sync.map work</span><br><span class=\"line\"></span><br><span class=\"line\">    var ma sync.Map</span><br><span class=\"line\">    k, _ :&#x3D; ma.Load(&quot;a&quot;)</span><br><span class=\"line\">    fmt.Println(k)</span><br><span class=\"line\"></span><br><span class=\"line\">    ma.Store(&quot;a&quot;, 1)</span><br><span class=\"line\">    _, _ &#x3D; ma.Load(&quot;a&quot;)</span><br><span class=\"line\">    ma.Store(&quot;b&quot;, 2)</span><br><span class=\"line\">    ma.Store(&quot;a&quot;, 2)</span><br><span class=\"line\">    ma.Store(&quot;a&quot;, 3)</span><br><span class=\"line\">    p, _ :&#x3D; ma.Load(&quot;a&quot;)</span><br><span class=\"line\">    fmt.Println(p)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>竞锁的情况</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<!-- ---\nlayout: post\ntitle: sync.Map源码圆度\nauthor: Ray Chan(ray1888)\ndate: '2020-12-10 16:07:38 +0800'\ncategory: Golang\nsummary: sync.Map implate \nthumbnail: go.png\n--- -->\n\n\n\n        <h1 id=\"前言\"   >\n          <a href=\"#前言\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>前言</h1>\n      <p>Sync.Map  是Golang 官方提供的线程安全的 map类库，因为Golang 本身自带的map并不是线程安全的，因为会有sync.Map这个类库的存在</p>\n\n        <h1 id=\"实现\"   >\n          <a href=\"#实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实现</h1>\n      \n        <h2 id=\"基础元素\"   >\n          <a href=\"#基础元素\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基础元素</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Map struct &#123;</span><br><span class=\"line\">    mu Mutex</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; read contains the portion of the map&#39;s contents that are safe for</span><br><span class=\"line\">    &#x2F;&#x2F; concurrent access (with or without mu held).</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; The read field itself is always safe to load, but must only be stored with</span><br><span class=\"line\">    &#x2F;&#x2F; mu held.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; Entries stored in read may be updated concurrently without mu, but updating</span><br><span class=\"line\">    &#x2F;&#x2F; a previously-expunged entry requires that the entry be copied to the dirty</span><br><span class=\"line\">    &#x2F;&#x2F; map and unexpunged with mu held.</span><br><span class=\"line\">    read atomic.Value &#x2F;&#x2F; readOnly</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; dirty contains the portion of the map&#39;s contents that require mu to be</span><br><span class=\"line\">    &#x2F;&#x2F; held. To ensure that the dirty map can be promoted to the read map quickly,</span><br><span class=\"line\">    &#x2F;&#x2F; it also includes all of the non-expunged entries in the read map.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; Expunged entries are not stored in the dirty map. An expunged entry in the</span><br><span class=\"line\">    &#x2F;&#x2F; clean map must be unexpunged and added to the dirty map before a new value</span><br><span class=\"line\">    &#x2F;&#x2F; can be stored to it.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; If the dirty map is nil, the next write to the map will initialize it by</span><br><span class=\"line\">    &#x2F;&#x2F; making a shallow copy of the clean map, omitting stale entries.</span><br><span class=\"line\">    dirty map[interface&#123;&#125;]*entry</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; misses counts the number of loads since the read map was last updated that</span><br><span class=\"line\">    &#x2F;&#x2F; needed to lock mu to determine whether the key was present.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; Once enough misses have occurred to cover the cost of copying the dirty</span><br><span class=\"line\">    &#x2F;&#x2F; map, the dirty map will be promoted to the read map (in the unamended</span><br><span class=\"line\">    &#x2F;&#x2F; state) and the next store to the map will make a new dirty copy.</span><br><span class=\"line\">    misses int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; readOnly is an immutable struct stored atomically in the Map.read field.</span><br><span class=\"line\">type readOnly struct &#123;</span><br><span class=\"line\">    m       map[interface&#123;&#125;]*entry</span><br><span class=\"line\">    amended bool &#x2F;&#x2F; true if the dirty map contains some key not in m.</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type entry struct &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; p points to the interface&#123;&#125; value stored for the entry.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; If p &#x3D;&#x3D; nil, the entry has been deleted and m.dirty &#x3D;&#x3D; nil.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; If p &#x3D;&#x3D; expunged, the entry has been deleted, m.dirty !&#x3D; nil, and the entry</span><br><span class=\"line\">    &#x2F;&#x2F; is missing from m.dirty.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty</span><br><span class=\"line\">    &#x2F;&#x2F; !&#x3D; nil, in m.dirty[key].</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; An entry can be deleted by atomic replacement with nil: when m.dirty is</span><br><span class=\"line\">    &#x2F;&#x2F; next created, it will atomically replace nil with expunged and leave</span><br><span class=\"line\">    &#x2F;&#x2F; m.dirty[key] unset.</span><br><span class=\"line\">    &#x2F;&#x2F;</span><br><span class=\"line\">    &#x2F;&#x2F; An entry&#39;s associated value can be updated by atomic replacement, provided</span><br><span class=\"line\">    &#x2F;&#x2F; p !&#x3D; expunged. If p &#x3D;&#x3D; expunged, an entry&#39;s associated value can be updated</span><br><span class=\"line\">    &#x2F;&#x2F; only after first setting m.dirty[key] &#x3D; e so that lookups using the dirty</span><br><span class=\"line\">    &#x2F;&#x2F; map find the entry.</span><br><span class=\"line\">    p unsafe.Pointer &#x2F;&#x2F; *interface&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>sync.Map 存储数据的分为两个部分：<br>1.read元素，使用的是atomic.Value 把map 当成interface进行存储；<br>2. dirty 一个golang中的一个Map，用于临时存储部分新的数据（具体场景会在后面进行描述）</p>\n\n        <h2 id=\"写流程\"   >\n          <a href=\"#写流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>写流程</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.  判断Key是否再Read部分，如果在read部分，则直接采用cas来更换，更换成功则直接返回</span><br><span class=\"line\">2.  否则就要加锁然后修改到dirty中，</span><br><span class=\"line\">      有三种情况：</span><br><span class=\"line\">      1. 在Read中，但是已经被修改，cas无法修改成功（会先把这个key对应的值与mark无效的指针做对比，如果是，则需要把这个更换了的key对应的放到dirty里面）</span><br><span class=\"line\">      2. 在dirty 中，直接进行修改</span><br><span class=\"line\">      3. 是一个新Key的情况下，如果dirty没有key不在read中，直接修改dirty,并且把需要读修正的Flag（read.amend &#x3D; true置入）</span><br><span class=\"line\">3. 解锁</span><br></pre></td></tr></table></div></figure>\n<p>因此 如果当key在Read中，是可以保证一个比较快的实现，因为用的是cas的比较方法，而不是直接加锁去防止竞争锁带来的性能损失。</p>\n\n        <h2 id=\"读流程\"   >\n          <a href=\"#读流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>读流程</h2>\n      <ol>\n<li> 读取Read中是否存在此Key，若存在则直接返回</li>\n<li> 当发现key不存在于read，并且没有读修正的时候，直接返回</li>\n<li> 发现需要读修正的情况下，会顺便把dirty中的数据置入到read中，并且返回值</li>\n</ol>\n\n        <h2 id=\"LoadORStore-读写一体流程\"   >\n          <a href=\"#LoadORStore-读写一体流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>LoadORStore 读写一体流程</h2>\n      \n        <h1 id=\"用于阅读sync-Map的触发代码\"   >\n          <a href=\"#用于阅读sync-Map的触发代码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>用于阅读sync.Map的触发代码</h1>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;sync&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; for testing sync.map work</span><br><span class=\"line\"></span><br><span class=\"line\">    var ma sync.Map</span><br><span class=\"line\">    k, _ :&#x3D; ma.Load(&quot;a&quot;)</span><br><span class=\"line\">    fmt.Println(k)</span><br><span class=\"line\"></span><br><span class=\"line\">    ma.Store(&quot;a&quot;, 1)</span><br><span class=\"line\">    _, _ &#x3D; ma.Load(&quot;a&quot;)</span><br><span class=\"line\">    ma.Store(&quot;b&quot;, 2)</span><br><span class=\"line\">    ma.Store(&quot;a&quot;, 2)</span><br><span class=\"line\">    ma.Store(&quot;a&quot;, 3)</span><br><span class=\"line\">    p, _ :&#x3D; ma.Load(&quot;a&quot;)</span><br><span class=\"line\">    fmt.Println(p)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>竞锁的情况</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n"},{"title":"MIT6.824课程的简介以及学习的原因","date":"2019-08-20T03:38:23.000Z","_content":"\n# MIT6.824 \nMIT6.824是一门对于分布式系统的讲解和实验的课程。\n\n## 课程自述\n```\n6.824 is a core 12-unit graduate subject with lectures, readings, programming labs, an optional project, a mid-term exam, and a final exam.\nIt will present abstractions and implementation techniques for engineering distributed systems.\nMajor topics include fault tolerance, replication, and consistency. Much of the class consists of studying \nand discussing case studies of distributed systems.\n\n翻译：\n6.824是一门集合了讲座、阅读、编程实验、附加课程、中期考试和期末考试的课程。他会展示能够为构建一个分布式系统的抽象和实现的技巧。本课程主要讨论的是容错、副本冗余、以及一致性相关的问题。大部分的课程都是由学习和讨论分布式系统的案例来组成的。\n```\n\n因此MIT6.824是一门学习分布式系统的一门比较好的课程。\n\n## 所需能力\n完成了整个实验之后，我总结了一下学习整个过程所需要的基础的能力（在后面的文章中也会继续提及到，此处只是为了做一个简单的Summary）\n\n1. 阅读论文的能力\n阅读论文不仅仅是快速阅读论文，掌握大意的能力，并且需要当实现遇到问题时，回顾论文是否能够找出代码实现中与论文描述的细节中是否一致的能力\n\n2. 根据日志进行Debug的能力\n因为在此实验中，Debug是不可能使用Ide来进行大量的打点操作来进行Debug。（实验中会有多个实例并且可能会出现多个并发操作的情况）因此需要学会在运行项目给的测试中去尝试打有用的Log来进行Debug。\n\n此外，还需要在脑中浮现出一个整个代码运行的逻辑图和实际代码执行的走向图的对比（如果暂时没用这种能力的话，可以先用纸和笔全部把它画出来。俗话说的好：好记性不如烂笔头），这样能快速定位到代码的问题可能会在哪一部分出现问题。\n\n3. 耐心&细致\n因为这其实是我第二次做这个实验，第一次只是做完lab2就已经放弃了。究其原因，一个很重要的部分是之前并没有仔细的阅读lab代码中的上面的很多注释和MITLab实验页的上面的Hint和注意的点。所以先把那些全部看完,然后全局思考完成之后再开始动手写代码的实现。\n\n并且遇到困难的时候，跑到失败的TestCase上面去详细的Debug问题是什么原因。本实验中可能出现很多的实现问题是与锁和Go Channel的使用相关的问题。\n\n## 课程中需要实现的代码\n1. 完成简易版的MapReduce\n2. 根据论文完成Raft的协议的实现（工业版的实现可以查看（2）Tikv和（3）Etcd上面的实现）\n3. 基于2中的Raft共识层，实现一个简易版的带副本冗余的KV数据库\n4. 基于2中的Raft共识层，实现一个带调度的Multi-raft的简易实现\n\n## ShareNote:\n1. [HomePage for MIT6.824](https://pdos.csail.mit.edu/6.824/)\n2. [tikv](https://github.com/tikv/tikv)\n3. [etcd](https://github.com/etcd-io/etcd)\n4. [知乎上关于分布式课程的推荐](https://www.zhihu.com/question/24750289/answer/111351130)\n5. [知乎上关于学习MIT6.824的建议](https://www.zhihu.com/question/29597104)\n","source":"_posts/mit-6824.md","raw":"---\ntitle: MIT6.824课程的简介以及学习的原因\ndate: 2019-08-20 11:38:23\ntags: distributed-system, mit6.824\n---\n\n# MIT6.824 \nMIT6.824是一门对于分布式系统的讲解和实验的课程。\n\n## 课程自述\n```\n6.824 is a core 12-unit graduate subject with lectures, readings, programming labs, an optional project, a mid-term exam, and a final exam.\nIt will present abstractions and implementation techniques for engineering distributed systems.\nMajor topics include fault tolerance, replication, and consistency. Much of the class consists of studying \nand discussing case studies of distributed systems.\n\n翻译：\n6.824是一门集合了讲座、阅读、编程实验、附加课程、中期考试和期末考试的课程。他会展示能够为构建一个分布式系统的抽象和实现的技巧。本课程主要讨论的是容错、副本冗余、以及一致性相关的问题。大部分的课程都是由学习和讨论分布式系统的案例来组成的。\n```\n\n因此MIT6.824是一门学习分布式系统的一门比较好的课程。\n\n## 所需能力\n完成了整个实验之后，我总结了一下学习整个过程所需要的基础的能力（在后面的文章中也会继续提及到，此处只是为了做一个简单的Summary）\n\n1. 阅读论文的能力\n阅读论文不仅仅是快速阅读论文，掌握大意的能力，并且需要当实现遇到问题时，回顾论文是否能够找出代码实现中与论文描述的细节中是否一致的能力\n\n2. 根据日志进行Debug的能力\n因为在此实验中，Debug是不可能使用Ide来进行大量的打点操作来进行Debug。（实验中会有多个实例并且可能会出现多个并发操作的情况）因此需要学会在运行项目给的测试中去尝试打有用的Log来进行Debug。\n\n此外，还需要在脑中浮现出一个整个代码运行的逻辑图和实际代码执行的走向图的对比（如果暂时没用这种能力的话，可以先用纸和笔全部把它画出来。俗话说的好：好记性不如烂笔头），这样能快速定位到代码的问题可能会在哪一部分出现问题。\n\n3. 耐心&细致\n因为这其实是我第二次做这个实验，第一次只是做完lab2就已经放弃了。究其原因，一个很重要的部分是之前并没有仔细的阅读lab代码中的上面的很多注释和MITLab实验页的上面的Hint和注意的点。所以先把那些全部看完,然后全局思考完成之后再开始动手写代码的实现。\n\n并且遇到困难的时候，跑到失败的TestCase上面去详细的Debug问题是什么原因。本实验中可能出现很多的实现问题是与锁和Go Channel的使用相关的问题。\n\n## 课程中需要实现的代码\n1. 完成简易版的MapReduce\n2. 根据论文完成Raft的协议的实现（工业版的实现可以查看（2）Tikv和（3）Etcd上面的实现）\n3. 基于2中的Raft共识层，实现一个简易版的带副本冗余的KV数据库\n4. 基于2中的Raft共识层，实现一个带调度的Multi-raft的简易实现\n\n## ShareNote:\n1. [HomePage for MIT6.824](https://pdos.csail.mit.edu/6.824/)\n2. [tikv](https://github.com/tikv/tikv)\n3. [etcd](https://github.com/etcd-io/etcd)\n4. [知乎上关于分布式课程的推荐](https://www.zhihu.com/question/24750289/answer/111351130)\n5. [知乎上关于学习MIT6.824的建议](https://www.zhihu.com/question/29597104)\n","slug":"mit-6824","published":1,"updated":"2021-01-21T06:32:13.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6irarc0005k9i5b6x757te","content":"\n        <h1 id=\"MIT6-824\"   >\n          <a href=\"#MIT6-824\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MIT6.824</h1>\n      <p>MIT6.824是一门对于分布式系统的讲解和实验的课程。</p>\n\n        <h2 id=\"课程自述\"   >\n          <a href=\"#课程自述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>课程自述</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6.824 is a core 12-unit graduate subject with lectures, readings, programming labs, an optional project, a mid-term exam, and a final exam.</span><br><span class=\"line\">It will present abstractions and implementation techniques for engineering distributed systems.</span><br><span class=\"line\">Major topics include fault tolerance, replication, and consistency. Much of the class consists of studying </span><br><span class=\"line\">and discussing case studies of distributed systems.</span><br><span class=\"line\"></span><br><span class=\"line\">翻译：</span><br><span class=\"line\">6.824是一门集合了讲座、阅读、编程实验、附加课程、中期考试和期末考试的课程。他会展示能够为构建一个分布式系统的抽象和实现的技巧。本课程主要讨论的是容错、副本冗余、以及一致性相关的问题。大部分的课程都是由学习和讨论分布式系统的案例来组成的。</span><br></pre></td></tr></table></div></figure>\n<p>因此MIT6.824是一门学习分布式系统的一门比较好的课程。</p>\n\n        <h2 id=\"所需能力\"   >\n          <a href=\"#所需能力\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>所需能力</h2>\n      <p>完成了整个实验之后，我总结了一下学习整个过程所需要的基础的能力（在后面的文章中也会继续提及到，此处只是为了做一个简单的Summary）</p>\n<ol>\n<li><p>阅读论文的能力<br>阅读论文不仅仅是快速阅读论文，掌握大意的能力，并且需要当实现遇到问题时，回顾论文是否能够找出代码实现中与论文描述的细节中是否一致的能力</p>\n</li>\n<li><p>根据日志进行Debug的能力<br>因为在此实验中，Debug是不可能使用Ide来进行大量的打点操作来进行Debug。（实验中会有多个实例并且可能会出现多个并发操作的情况）因此需要学会在运行项目给的测试中去尝试打有用的Log来进行Debug。</p>\n</li>\n</ol>\n<p>此外，还需要在脑中浮现出一个整个代码运行的逻辑图和实际代码执行的走向图的对比（如果暂时没用这种能力的话，可以先用纸和笔全部把它画出来。俗话说的好：好记性不如烂笔头），这样能快速定位到代码的问题可能会在哪一部分出现问题。</p>\n<ol start=\"3\">\n<li>耐心&amp;细致<br>因为这其实是我第二次做这个实验，第一次只是做完lab2就已经放弃了。究其原因，一个很重要的部分是之前并没有仔细的阅读lab代码中的上面的很多注释和MITLab实验页的上面的Hint和注意的点。所以先把那些全部看完,然后全局思考完成之后再开始动手写代码的实现。</li>\n</ol>\n<p>并且遇到困难的时候，跑到失败的TestCase上面去详细的Debug问题是什么原因。本实验中可能出现很多的实现问题是与锁和Go Channel的使用相关的问题。</p>\n\n        <h2 id=\"课程中需要实现的代码\"   >\n          <a href=\"#课程中需要实现的代码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>课程中需要实现的代码</h2>\n      <ol>\n<li>完成简易版的MapReduce</li>\n<li>根据论文完成Raft的协议的实现（工业版的实现可以查看（2）Tikv和（3）Etcd上面的实现）</li>\n<li>基于2中的Raft共识层，实现一个简易版的带副本冗余的KV数据库</li>\n<li>基于2中的Raft共识层，实现一个带调度的Multi-raft的简易实现</li>\n</ol>\n\n        <h2 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote:</h2>\n      <ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://pdos.csail.mit.edu/6.824/\" >HomePage for MIT6.824</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/tikv/tikv\" >tikv</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/etcd-io/etcd\" >etcd</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.zhihu.com/question/24750289/answer/111351130\" >知乎上关于分布式课程的推荐</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.zhihu.com/question/29597104\" >知乎上关于学习MIT6.824的建议</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"\n        <h1 id=\"MIT6-824\"   >\n          <a href=\"#MIT6-824\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MIT6.824</h1>\n      <p>MIT6.824是一门对于分布式系统的讲解和实验的课程。</p>\n\n        <h2 id=\"课程自述\"   >\n          <a href=\"#课程自述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>课程自述</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6.824 is a core 12-unit graduate subject with lectures, readings, programming labs, an optional project, a mid-term exam, and a final exam.</span><br><span class=\"line\">It will present abstractions and implementation techniques for engineering distributed systems.</span><br><span class=\"line\">Major topics include fault tolerance, replication, and consistency. Much of the class consists of studying </span><br><span class=\"line\">and discussing case studies of distributed systems.</span><br><span class=\"line\"></span><br><span class=\"line\">翻译：</span><br><span class=\"line\">6.824是一门集合了讲座、阅读、编程实验、附加课程、中期考试和期末考试的课程。他会展示能够为构建一个分布式系统的抽象和实现的技巧。本课程主要讨论的是容错、副本冗余、以及一致性相关的问题。大部分的课程都是由学习和讨论分布式系统的案例来组成的。</span><br></pre></td></tr></table></div></figure>\n<p>因此MIT6.824是一门学习分布式系统的一门比较好的课程。</p>\n\n        <h2 id=\"所需能力\"   >\n          <a href=\"#所需能力\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>所需能力</h2>\n      <p>完成了整个实验之后，我总结了一下学习整个过程所需要的基础的能力（在后面的文章中也会继续提及到，此处只是为了做一个简单的Summary）</p>\n<ol>\n<li><p>阅读论文的能力<br>阅读论文不仅仅是快速阅读论文，掌握大意的能力，并且需要当实现遇到问题时，回顾论文是否能够找出代码实现中与论文描述的细节中是否一致的能力</p>\n</li>\n<li><p>根据日志进行Debug的能力<br>因为在此实验中，Debug是不可能使用Ide来进行大量的打点操作来进行Debug。（实验中会有多个实例并且可能会出现多个并发操作的情况）因此需要学会在运行项目给的测试中去尝试打有用的Log来进行Debug。</p>\n</li>\n</ol>\n<p>此外，还需要在脑中浮现出一个整个代码运行的逻辑图和实际代码执行的走向图的对比（如果暂时没用这种能力的话，可以先用纸和笔全部把它画出来。俗话说的好：好记性不如烂笔头），这样能快速定位到代码的问题可能会在哪一部分出现问题。</p>\n<ol start=\"3\">\n<li>耐心&amp;细致<br>因为这其实是我第二次做这个实验，第一次只是做完lab2就已经放弃了。究其原因，一个很重要的部分是之前并没有仔细的阅读lab代码中的上面的很多注释和MITLab实验页的上面的Hint和注意的点。所以先把那些全部看完,然后全局思考完成之后再开始动手写代码的实现。</li>\n</ol>\n<p>并且遇到困难的时候，跑到失败的TestCase上面去详细的Debug问题是什么原因。本实验中可能出现很多的实现问题是与锁和Go Channel的使用相关的问题。</p>\n\n        <h2 id=\"课程中需要实现的代码\"   >\n          <a href=\"#课程中需要实现的代码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>课程中需要实现的代码</h2>\n      <ol>\n<li>完成简易版的MapReduce</li>\n<li>根据论文完成Raft的协议的实现（工业版的实现可以查看（2）Tikv和（3）Etcd上面的实现）</li>\n<li>基于2中的Raft共识层，实现一个简易版的带副本冗余的KV数据库</li>\n<li>基于2中的Raft共识层，实现一个带调度的Multi-raft的简易实现</li>\n</ol>\n\n        <h2 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote:</h2>\n      <ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://pdos.csail.mit.edu/6.824/\" >HomePage for MIT6.824</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/tikv/tikv\" >tikv</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://github.com/etcd-io/etcd\" >etcd</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.zhihu.com/question/24750289/answer/111351130\" >知乎上关于分布式课程的推荐</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.zhihu.com/question/29597104\" >知乎上关于学习MIT6.824的建议</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n"},{"title":"Prometheus(1)- 数据抓取源码阅读","date":"2019-10-06T07:31:38.000Z","_content":"\n<!-- ---\nlayout: post\ntitle: Prometheus数据抓取源码阅读\nauthor: Ray Chan(ray1888)\ndate: '2019-10-06 15:31:38 +0800'\ncategory: Prometheus\nsummary: Prometheus Scrape Module\nthumbnail: Prometheus.png\n--- -->\n\n\n# 目录\n1. 使用的目的\n2. 代码实现\n\n# 代码版本\n\n基于 prometheus项目的master branch的5a554df0855bf707a8c333c0dd830067d03422cf commit\n\n# 使用目的\n\nPrometheus 是一个基于Pull模型所进行数据采集的系统，因此，需要在主体项目中有一个抓取数据的模块，而Scrape就是这样的模块。因此这个也是Prometheus的一个主要部分。\n\n```\n入口代码部分\nmain.go\n// line 356\nscrapeManager = scrape.NewManager(log.With(logger, \"component\", \"scrape manager\"), fanoutStorage)\n// line 427\nscrapeManager.ApplyConfig\n// line 555\nerr := scrapeManager.Run(discoveryManagerScrape.SyncCh())\n```\n\n# 代码实现 \n\n## 整体的流程图\n\n<!-- ![ServiceDiscoveryModule](/assets/img/posts/prometheus/ScrapeModule.png) -->\n{% asset_img ScrapeModule.png ServiceDiscoveryModule %}\n\n## 目录结构\n```\n-rw-r--r-- 1 ray 197121  2239 9月  30 16:09 helpers_test.go\n-rw-r--r-- 1 ray 197121  7543 9月  30 16:09 manager.go   //主要的控制的模块Manager\n-rw-r--r-- 1 ray 197121 10727 9月  30 16:09 manager_test.go\n-rw-r--r-- 1 ray 197121 35749 9月  30 16:09 scrape.go    // 主要进行采集的模块\n-rw-r--r-- 1 ray 197121 40682 9月  30 16:09 scrape_test.go\n-rw-r--r-- 1 ray 197121 11743 9月  30 16:09 target.go    //  抓取的公用部分的逻辑\n-rw-r--r-- 1 ray 197121  9542 9月  30 16:09 target_test.go\n\n```\n\n## 重要数据结构描述\nScrapeManager 是管理所有抓取的一个抽象\n```\ntype Manager struct {\n\tlogger    log.Logger\n\tappend    Appendable\n\tgraceShut chan struct{}\n\n\tjitterSeed    uint64     // Global jitterSeed seed is used to spread scrape workload across HA setup.\n\tmtxScrape     sync.Mutex // Guards the fields below.\n\tscrapeConfigs map[string]*config.ScrapeConfig\n\tscrapePools   map[string]*scrapePool\n\ttargetSets    map[string][]*targetgroup.Group\n\n\ttriggerReload chan struct{}\n}\n```\n\nScrapePools 是单个的Job的抓取目标的工作单位\n```\nappendable Appendable\n\tlogger     log.Logger\n\n\tmtx    sync.RWMutex\n\tconfig *config.ScrapeConfig\n\tclient *http.Client\n\t// Targets and loops must always be synchronized to have the same\n\t// set of hashes.\n\tactiveTargets  map[uint64]*Target\n\tdroppedTargets []*Target\n\tloops          map[uint64]loop\n\tcancel         context.CancelFunc\n\n\t// Constructor for new scrape loops. This is settable for testing convenience.\n\tnewLoop func(scrapeLoopOptions) loop\n```\n\nloop是单个Target的执行单位，是一个接口。在这里主要使用的是ScrapeLoop的实例\n```\ntype loop interface {\n\trun(interval, timeout time.Duration, errc chan<- error)\n\tstop()\n}\n\ntype scrapeLoop struct {\n\tscraper         scraper\n\tl               log.Logger\n\tcache           *scrapeCache\n\tlastScrapeSize  int\n\tbuffers         *pool.Pool\n\tjitterSeed      uint64\n\thonorTimestamps bool\n\n\tappender            func() storage.Appender\n\tsampleMutator       labelsMutator\n\treportSampleMutator labelsMutator\n\n\tparentCtx context.Context\n\tctx       context.Context\n\tcancel    func()\n\tstopped   chan struct{}\n}\n\n```\n\nscraper接口时具体的执行单位，scrapeLoop也是调用scraper的方法来进行数据的抓取, Prometheus默认使用targetScraper去抓取数据\n\n```\ntype scraper interface {\n\tscrape(ctx context.Context, w io.Writer) (string, error) // 抓取数据的方法\n\treport(start time.Time, dur time.Duration, err error)    // 上报数据的方法\n\toffset(interval time.Duration, jitterSeed uint64) time.Duration // 记录数据偏移的方法\n}\n\ntype targetScraper struct {\n\t*Target  //包含了report和offset方法\n\n\tclient  *http.Client //因为Prometheus的exporter是以http接口进行数据的暴露的，所以会有httpclient的结构包含在里面\n\treq     *http.Request\n\ttimeout time.Duration\n\n\tgzipr *gzip.Reader\n\tbuf   *bufio.Reader\n}\n\n\n```\n\n## 主协程逻辑\n\n跟着调用的部分，我们先从初始化后的manager的ApplyConfig方法开始看起。\n```\nfunc (m *Manager) ApplyConfig(cfg *config.Config) error {\n\tm.mtxScrape.Lock()\n\tdefer m.mtxScrape.Unlock()\n\n\tc := make(map[string]*config.ScrapeConfig)\n    \n\tfor _, scfg := range cfg.ScrapeConfigs {\n\t\tc[scfg.JobName] = scfg\n\t}\n\tm.scrapeConfigs = c\n    // 使用全局配置来生成一个集群内不重复的seed\n\tif err := m.setJitterSeed(cfg.GlobalConfig.ExternalLabels); err != nil {\n\t\treturn err\n\t}\n\n\t// Cleanup and reload pool if the configuration has changed.\n\tvar failed bool\n    // 根据解析出来的配置生成对应的ScrapePool， 如果有并且数据没有改变的话，那就不进行操作，否则\n\tfor name, sp := range m.scrapePools {\n\t\tif cfg, ok := m.scrapeConfigs[name]; !ok {\n\t\t\tsp.stop()\n\t\t\tdelete(m.scrapePools, name)\n\t\t} else if !reflect.DeepEqual(sp.config, cfg) {\n\t\t\terr := sp.reload(cfg)\n\t\t\tif err != nil {\n\t\t\t\tlevel.Error(m.logger).Log(\"msg\", \"error reloading scrape pool\", \"err\", err, \"scrape_pool\", name)\n\t\t\t\tfailed = true\n\t\t\t}\n\t\t}\n\t}\n\n\tif failed {\n\t\treturn errors.New(\"failed to apply the new configuration\")\n\t}\n\treturn nil\n}\n\nfunc (sp *scrapePool) reload(cfg *config.ScrapeConfig) error {\n\ttargetScrapePoolReloads.Inc()\n\tstart := time.Now()\n\n\tsp.mtx.Lock()\n\tdefer sp.mtx.Unlock()\n\n\tclient, err := config_util.NewClientFromConfig(cfg.HTTPClientConfig, cfg.JobName, false)\n\tif err != nil {\n\t\ttargetScrapePoolReloadsFailed.Inc()\n\t\treturn errors.Wrap(err, \"error creating HTTP client\")\n\t}\n\tsp.config = cfg\n\toldClient := sp.client\n\tsp.client = client\n\n\tvar (\n\t\twg              sync.WaitGroup\n\t\tinterval        = time.Duration(sp.config.ScrapeInterval)\n\t\ttimeout         = time.Duration(sp.config.ScrapeTimeout)\n\t\tlimit           = int(sp.config.SampleLimit)\n\t\thonorLabels     = sp.config.HonorLabels\n\t\thonorTimestamps = sp.config.HonorTimestamps\n\t\tmrc             = sp.config.MetricRelabelConfigs\n\t)\n\n\tfor fp, oldLoop := range sp.loops {\n\t\tvar (\n\t\t\tt       = sp.activeTargets[fp]\n\t\t\ts       = &targetScraper{Target: t, client: sp.client, timeout: timeout}\n\t\t\tnewLoop = sp.newLoop(scrapeLoopOptions{\n\t\t\t\ttarget:          t,\n\t\t\t\tscraper:         s,\n\t\t\t\tlimit:           limit,\n\t\t\t\thonorLabels:     honorLabels,\n\t\t\t\thonorTimestamps: honorTimestamps,\n\t\t\t\tmrc:             mrc,\n\t\t\t})\n\t\t)\n\t\twg.Add(1)\n\n\t\tgo func(oldLoop, newLoop loop) {\n\t\t\toldLoop.stop()\n\t\t\twg.Done()\n\n\t\t\tgo newLoop.run(interval, timeout, nil)\n\t\t}(oldLoop, newLoop)\n\n\t\tsp.loops[fp] = newLoop\n\t}\n\n\twg.Wait()\n\toldClient.CloseIdleConnections()\n\ttargetReloadIntervalLength.WithLabelValues(interval.String()).Observe(\n\t\ttime.Since(start).Seconds(),\n\t)\n\treturn nil\n}\n\n```\n\n1. 把解析好的配置，遍历，变为一个jobName为key，配置值为Value的map\n2. 对比自己的配置，如果之前已经存在但是配置发生变动的，则去reload scraper pool的配置。\n3. （Reload） 如果需要reload配置的情况下，会重新生成scrapePool后，派生多一个线程去执行scraperPool.Sync()，知道Manager的targetSet被遍历完为止。Sync方法的内容会后面进行详细讲解。\n\nRun()方法\n```\nfunc (m *Manager) Run(tsets <-chan map[string][]*targetgroup.Group) error {\n\tgo m.reloader()\n\tfor {\n\t\tselect {\n\t\tcase ts := <-tsets:\n\t\t\tm.updateTsets(ts)\n\n\t\t\tselect {\n\t\t\tcase m.triggerReload <- struct{}{}:\n\t\t\tdefault:\n\t\t\t}\n\n\t\tcase <-m.graceShut:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n\nfunc (m *Manager) reloader() {\n\tticker := time.NewTicker(5 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-m.graceShut:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tselect {\n\t\t\tcase <-m.triggerReload:\n\t\t\t\tm.reload()\n\t\t\tcase <-m.graceShut:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n```\n功能：\n1. 等待从Main.go中传入的discoveryManager的SyncCh是否有变动，如果有变动，更新Targetset。\n2. 派生出了一个Reloader协程，Reloader协程会定时检查是否有关闭的信号或者Reload信号（triggerReload channel,就是外部给与主协程的刺激产生的二级信号），如果有，则执行reload操作。\n\n\n## 子协程逻辑\n\n### ScraperPool\n```\n// Sync converts target groups into actual scrape targets and synchronizes\n// the currently running scraper with the resulting set and returns all scraped and dropped targets.\nfunc (sp *scrapePool) Sync(tgs []*targetgroup.Group) {\n\tstart := time.Now()\n\n\tvar all []*Target\n\tsp.mtx.Lock()\n\tsp.droppedTargets = []*Target{}\n\tfor _, tg := range tgs {\n\t\ttargets, err := targetsFromGroup(tg, sp.config)\n\t\tif err != nil {\n\t\t\tlevel.Error(sp.logger).Log(\"msg\", \"creating targets failed\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tfor _, t := range targets {\n\t\t\tif t.Labels().Len() > 0 {\n\t\t\t\tall = append(all, t)\n\t\t\t} else if t.DiscoveredLabels().Len() > 0 {\n\t\t\t\tsp.droppedTargets = append(sp.droppedTargets, t)\n\t\t\t}\n\t\t}\n\t}\n\tsp.mtx.Unlock()\n\tsp.sync(all)\n\n\ttargetSyncIntervalLength.WithLabelValues(sp.config.JobName).Observe(\n\t\ttime.Since(start).Seconds(),\n\t)\n\ttargetScrapePoolSyncsCounter.WithLabelValues(sp.config.JobName).Inc()\n}\n```\n\nSync函数是一个对外暴露函数的接口：\n1. 把配置解析出来的target结构化。\n2. 调用内部方法sync()来进行数据抓取的执行\n3. 一些计数器添加计数\n\n值得注意的是Append方法，是一个封装了的方法，是同是进行对变量的修改，并且包含了采集到的数据持久化的操作。\n\n\n```\n// sync takes a list of potentially duplicated targets, deduplicates them, starts\n// scrape loops for new targets, and stops scrape loops for disappeared targets.\n// It returns after all stopped scrape loops terminated.\nfunc (sp *scrapePool) sync(targets []*Target) {\n\tsp.mtx.Lock()\n\tdefer sp.mtx.Unlock()\n\n\tvar (\n\t\tuniqueTargets   = map[uint64]struct{}{}\n\t\tinterval        = time.Duration(sp.config.ScrapeInterval)\n\t\ttimeout         = time.Duration(sp.config.ScrapeTimeout)\n\t\tlimit           = int(sp.config.SampleLimit)\n\t\thonorLabels     = sp.config.HonorLabels\n\t\thonorTimestamps = sp.config.HonorTimestamps\n\t\tmrc             = sp.config.MetricRelabelConfigs\n\t)\n\n\tfor _, t := range targets {\n\t\tt := t\n\t\thash := t.hash()\n\t\tuniqueTargets[hash] = struct{}{}\n\n\t\tif _, ok := sp.activeTargets[hash]; !ok {\n\t\t\ts := &targetScraper{Target: t, client: sp.client, timeout: timeout}\n\t\t\tl := sp.newLoop(scrapeLoopOptions{\n\t\t\t\ttarget:          t,\n\t\t\t\tscraper:         s,\n\t\t\t\tlimit:           limit,\n\t\t\t\thonorLabels:     honorLabels,\n\t\t\t\thonorTimestamps: honorTimestamps,\n\t\t\t\tmrc:             mrc,\n\t\t\t})\n\n\t\t\tsp.activeTargets[hash] = t\n\t\t\tsp.loops[hash] = l\n\n\t\t\tgo l.run(interval, timeout, nil)\n\t\t} else {\n\t\t\t// Need to keep the most updated labels information\n\t\t\t// for displaying it in the Service Discovery web page.\n\t\t\tsp.activeTargets[hash].SetDiscoveredLabels(t.DiscoveredLabels())\n\t\t}\n\t}\n\n\tvar wg sync.WaitGroup\n\n\t// Stop and remove old targets and scraper loops.\n\tfor hash := range sp.activeTargets {\n\t\tif _, ok := uniqueTargets[hash]; !ok {\n\t\t\twg.Add(1)\n\t\t\tgo func(l loop) {\n\n\t\t\t\tl.stop()\n\n\t\t\t\twg.Done()\n\t\t\t}(sp.loops[hash])\n\n\t\t\tdelete(sp.loops, hash)\n\t\t\tdelete(sp.activeTargets, hash)\n\t\t}\n\t}\n\n\t// Wait for all potentially stopped scrapers to terminate.\n\t// This covers the case of flapping targets. If the server is under high load, a new scraper\n\t// may be active and tries to insert. The old scraper that didn't terminate yet could still\n\t// be inserting a previous sample set.\n\twg.Wait()\n}\n```\n\n主要逻辑：\n1. 把传入的Target列表进行遍历\n   1.1 如果target不在active的map中， 生成targetScraper，然后把targetScraper放入Loop里面，调用Loop.run()在协程中进行逻辑\n   1.2 否则， 会先删除旧的协程，然后重新生成协程。\n\n### ScraperLoop\n\n```\nfunc (sl *scrapeLoop) run(interval, timeout time.Duration, errc chan<- error) {\n\tselect {\n\tcase <-time.After(sl.scraper.offset(interval, sl.jitterSeed)):\n\t\t// Continue after a scraping offset.\n\tcase <-sl.ctx.Done():\n\t\tclose(sl.stopped)\n\t\treturn\n\t}\n\n\tvar last time.Time\n\n\tticker := time.NewTicker(interval)\n\tdefer ticker.Stop()\n\nmainLoop:\n\tfor {\n\t\tselect {\n\t\tcase <-sl.parentCtx.Done():\n\t\t\tclose(sl.stopped)\n\t\t\treturn\n\t\tcase <-sl.ctx.Done():\n\t\t\tbreak mainLoop\n\t\tdefault:\n\t\t}\n\n\t\tvar (\n\t\t\tstart             = time.Now()\n\t\t\tscrapeCtx, cancel = context.WithTimeout(sl.ctx, timeout)\n\t\t)\n\n\t\t// Only record after the first scrape.\n\t\tif !last.IsZero() {\n\t\t\ttargetIntervalLength.WithLabelValues(interval.String()).Observe(\n\t\t\t\ttime.Since(last).Seconds(),\n\t\t\t)\n\t\t}\n\n\t\tb := sl.buffers.Get(sl.lastScrapeSize).([]byte)\n\t\tbuf := bytes.NewBuffer(b)\n\n\t\tcontentType, scrapeErr := sl.scraper.scrape(scrapeCtx, buf)\n\t\tcancel()\n\n\t\tif scrapeErr == nil {\n\t\t\tb = buf.Bytes()\n\t\t\t// NOTE: There were issues with misbehaving clients in the past\n\t\t\t// that occasionally returned empty results. We don't want those\n\t\t\t// to falsely reset our buffer size.\n\t\t\tif len(b) > 0 {\n\t\t\t\tsl.lastScrapeSize = len(b)\n\t\t\t}\n\t\t} else {\n\t\t\tlevel.Debug(sl.l).Log(\"msg\", \"Scrape failed\", \"err\", scrapeErr.Error())\n\t\t\tif errc != nil {\n\t\t\t\terrc <- scrapeErr\n\t\t\t}\n\t\t}\n\n\t\t// A failed scrape is the same as an empty scrape,\n\t\t// we still call sl.append to trigger stale markers.\n\t\ttotal, added, seriesAdded, appErr := sl.append(b, contentType, start)\n\t\tif appErr != nil {\n\t\t\tlevel.Warn(sl.l).Log(\"msg\", \"append failed\", \"err\", appErr)\n\t\t\t// The append failed, probably due to a parse error or sample limit.\n\t\t\t// Call sl.append again with an empty scrape to trigger stale markers.\n\t\t\tif _, _, _, err := sl.append([]byte{}, \"\", start); err != nil {\n\t\t\t\tlevel.Warn(sl.l).Log(\"msg\", \"append failed\", \"err\", err)\n\t\t\t}\n\t\t}\n\n\t\tsl.buffers.Put(b)\n\n\t\tif scrapeErr == nil {\n\t\t\tscrapeErr = appErr\n\t\t}\n\n\t\tif err := sl.report(start, time.Since(start), total, added, seriesAdded, scrapeErr); err != nil {\n\t\t\tlevel.Warn(sl.l).Log(\"msg\", \"appending scrape report failed\", \"err\", err)\n\t\t}\n\t\tlast = start\n\n\t\tselect {\n\t\tcase <-sl.parentCtx.Done():\n\t\t\tclose(sl.stopped)\n\t\t\treturn\n\t\tcase <-sl.ctx.Done():\n\t\t\tbreak mainLoop\n\t\tcase <-ticker.C:\n\t\t}\n\t}\n\n\tclose(sl.stopped)\n\n\tsl.endOfRunStaleness(last, ticker, interval)\n}\n```\n\nScraperLoop是单个Target进行获取的执行单位，协程使用死循环进行占用，然后调用scraper接口的Scrape方法去抓取数据，并且调用Stroage模块的Appender的接口金属数据的持久化，然后继续定时休眠的过程。我们需要更加具体的看一下实例Scraper的Scrape方法。\n\nScraperLoop把Scraper抽象出来的三个接口都进行了调用：\n1. 开始部分的Select代码段中的Offset是用于控制第一次执行的时候等待的间隔\n2. Scrape方法就是直接进行数据的抓取，下面有详细解析\n3. report方法，修改Scraper中Target自己保存的状态。\n\n\n\n### TargerScraper\n```\nfunc (s *targetScraper) scrape(ctx context.Context, w io.Writer) (string, error) {\n\tif s.req == nil {\n\t\treq, err := http.NewRequest(\"GET\", s.URL().String(), nil)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treq.Header.Add(\"Accept\", acceptHeader)\n\t\treq.Header.Add(\"Accept-Encoding\", \"gzip\")\n\t\treq.Header.Set(\"User-Agent\", userAgentHeader)\n\t\treq.Header.Set(\"X-Prometheus-Scrape-Timeout-Seconds\", fmt.Sprintf(\"%f\", s.timeout.Seconds()))\n\n\t\ts.req = req\n\t}\n\n\tresp, err := s.client.Do(s.req.WithContext(ctx))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer func() {\n\t\tio.Copy(ioutil.Discard, resp.Body)\n\t\tresp.Body.Close()\n\t}()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", errors.Errorf(\"server returned HTTP status %s\", resp.Status)\n\t}\n\n\tif resp.Header.Get(\"Content-Encoding\") != \"gzip\" {\n\t\t_, err = io.Copy(w, resp.Body)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn resp.Header.Get(\"Content-Type\"), nil\n\t}\n\n\tif s.gzipr == nil {\n\t\ts.buf = bufio.NewReader(resp.Body)\n\t\ts.gzipr, err = gzip.NewReader(s.buf)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t} else {\n\t\ts.buf.Reset(resp.Body)\n\t\tif err = s.gzipr.Reset(s.buf); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\t_, err = io.Copy(w, s.gzipr)\n\ts.gzipr.Close()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn resp.Header.Get(\"Content-Type\"), nil\n}\n\n```\n\nScrape方法是使用HttpClient进行对target url 的数据抓取，抓取的内容在context中进行传递，得到返回后，继续解析，返回给ScraperLoop的Run方法使用。","source":"_posts/prometheus-scrape.md","raw":"---\ntitle:  Prometheus(1)- 数据抓取源码阅读\ndate: 2019-10-06 15:31:38\ntags: Prometheus\n---\n\n<!-- ---\nlayout: post\ntitle: Prometheus数据抓取源码阅读\nauthor: Ray Chan(ray1888)\ndate: '2019-10-06 15:31:38 +0800'\ncategory: Prometheus\nsummary: Prometheus Scrape Module\nthumbnail: Prometheus.png\n--- -->\n\n\n# 目录\n1. 使用的目的\n2. 代码实现\n\n# 代码版本\n\n基于 prometheus项目的master branch的5a554df0855bf707a8c333c0dd830067d03422cf commit\n\n# 使用目的\n\nPrometheus 是一个基于Pull模型所进行数据采集的系统，因此，需要在主体项目中有一个抓取数据的模块，而Scrape就是这样的模块。因此这个也是Prometheus的一个主要部分。\n\n```\n入口代码部分\nmain.go\n// line 356\nscrapeManager = scrape.NewManager(log.With(logger, \"component\", \"scrape manager\"), fanoutStorage)\n// line 427\nscrapeManager.ApplyConfig\n// line 555\nerr := scrapeManager.Run(discoveryManagerScrape.SyncCh())\n```\n\n# 代码实现 \n\n## 整体的流程图\n\n<!-- ![ServiceDiscoveryModule](/assets/img/posts/prometheus/ScrapeModule.png) -->\n{% asset_img ScrapeModule.png ServiceDiscoveryModule %}\n\n## 目录结构\n```\n-rw-r--r-- 1 ray 197121  2239 9月  30 16:09 helpers_test.go\n-rw-r--r-- 1 ray 197121  7543 9月  30 16:09 manager.go   //主要的控制的模块Manager\n-rw-r--r-- 1 ray 197121 10727 9月  30 16:09 manager_test.go\n-rw-r--r-- 1 ray 197121 35749 9月  30 16:09 scrape.go    // 主要进行采集的模块\n-rw-r--r-- 1 ray 197121 40682 9月  30 16:09 scrape_test.go\n-rw-r--r-- 1 ray 197121 11743 9月  30 16:09 target.go    //  抓取的公用部分的逻辑\n-rw-r--r-- 1 ray 197121  9542 9月  30 16:09 target_test.go\n\n```\n\n## 重要数据结构描述\nScrapeManager 是管理所有抓取的一个抽象\n```\ntype Manager struct {\n\tlogger    log.Logger\n\tappend    Appendable\n\tgraceShut chan struct{}\n\n\tjitterSeed    uint64     // Global jitterSeed seed is used to spread scrape workload across HA setup.\n\tmtxScrape     sync.Mutex // Guards the fields below.\n\tscrapeConfigs map[string]*config.ScrapeConfig\n\tscrapePools   map[string]*scrapePool\n\ttargetSets    map[string][]*targetgroup.Group\n\n\ttriggerReload chan struct{}\n}\n```\n\nScrapePools 是单个的Job的抓取目标的工作单位\n```\nappendable Appendable\n\tlogger     log.Logger\n\n\tmtx    sync.RWMutex\n\tconfig *config.ScrapeConfig\n\tclient *http.Client\n\t// Targets and loops must always be synchronized to have the same\n\t// set of hashes.\n\tactiveTargets  map[uint64]*Target\n\tdroppedTargets []*Target\n\tloops          map[uint64]loop\n\tcancel         context.CancelFunc\n\n\t// Constructor for new scrape loops. This is settable for testing convenience.\n\tnewLoop func(scrapeLoopOptions) loop\n```\n\nloop是单个Target的执行单位，是一个接口。在这里主要使用的是ScrapeLoop的实例\n```\ntype loop interface {\n\trun(interval, timeout time.Duration, errc chan<- error)\n\tstop()\n}\n\ntype scrapeLoop struct {\n\tscraper         scraper\n\tl               log.Logger\n\tcache           *scrapeCache\n\tlastScrapeSize  int\n\tbuffers         *pool.Pool\n\tjitterSeed      uint64\n\thonorTimestamps bool\n\n\tappender            func() storage.Appender\n\tsampleMutator       labelsMutator\n\treportSampleMutator labelsMutator\n\n\tparentCtx context.Context\n\tctx       context.Context\n\tcancel    func()\n\tstopped   chan struct{}\n}\n\n```\n\nscraper接口时具体的执行单位，scrapeLoop也是调用scraper的方法来进行数据的抓取, Prometheus默认使用targetScraper去抓取数据\n\n```\ntype scraper interface {\n\tscrape(ctx context.Context, w io.Writer) (string, error) // 抓取数据的方法\n\treport(start time.Time, dur time.Duration, err error)    // 上报数据的方法\n\toffset(interval time.Duration, jitterSeed uint64) time.Duration // 记录数据偏移的方法\n}\n\ntype targetScraper struct {\n\t*Target  //包含了report和offset方法\n\n\tclient  *http.Client //因为Prometheus的exporter是以http接口进行数据的暴露的，所以会有httpclient的结构包含在里面\n\treq     *http.Request\n\ttimeout time.Duration\n\n\tgzipr *gzip.Reader\n\tbuf   *bufio.Reader\n}\n\n\n```\n\n## 主协程逻辑\n\n跟着调用的部分，我们先从初始化后的manager的ApplyConfig方法开始看起。\n```\nfunc (m *Manager) ApplyConfig(cfg *config.Config) error {\n\tm.mtxScrape.Lock()\n\tdefer m.mtxScrape.Unlock()\n\n\tc := make(map[string]*config.ScrapeConfig)\n    \n\tfor _, scfg := range cfg.ScrapeConfigs {\n\t\tc[scfg.JobName] = scfg\n\t}\n\tm.scrapeConfigs = c\n    // 使用全局配置来生成一个集群内不重复的seed\n\tif err := m.setJitterSeed(cfg.GlobalConfig.ExternalLabels); err != nil {\n\t\treturn err\n\t}\n\n\t// Cleanup and reload pool if the configuration has changed.\n\tvar failed bool\n    // 根据解析出来的配置生成对应的ScrapePool， 如果有并且数据没有改变的话，那就不进行操作，否则\n\tfor name, sp := range m.scrapePools {\n\t\tif cfg, ok := m.scrapeConfigs[name]; !ok {\n\t\t\tsp.stop()\n\t\t\tdelete(m.scrapePools, name)\n\t\t} else if !reflect.DeepEqual(sp.config, cfg) {\n\t\t\terr := sp.reload(cfg)\n\t\t\tif err != nil {\n\t\t\t\tlevel.Error(m.logger).Log(\"msg\", \"error reloading scrape pool\", \"err\", err, \"scrape_pool\", name)\n\t\t\t\tfailed = true\n\t\t\t}\n\t\t}\n\t}\n\n\tif failed {\n\t\treturn errors.New(\"failed to apply the new configuration\")\n\t}\n\treturn nil\n}\n\nfunc (sp *scrapePool) reload(cfg *config.ScrapeConfig) error {\n\ttargetScrapePoolReloads.Inc()\n\tstart := time.Now()\n\n\tsp.mtx.Lock()\n\tdefer sp.mtx.Unlock()\n\n\tclient, err := config_util.NewClientFromConfig(cfg.HTTPClientConfig, cfg.JobName, false)\n\tif err != nil {\n\t\ttargetScrapePoolReloadsFailed.Inc()\n\t\treturn errors.Wrap(err, \"error creating HTTP client\")\n\t}\n\tsp.config = cfg\n\toldClient := sp.client\n\tsp.client = client\n\n\tvar (\n\t\twg              sync.WaitGroup\n\t\tinterval        = time.Duration(sp.config.ScrapeInterval)\n\t\ttimeout         = time.Duration(sp.config.ScrapeTimeout)\n\t\tlimit           = int(sp.config.SampleLimit)\n\t\thonorLabels     = sp.config.HonorLabels\n\t\thonorTimestamps = sp.config.HonorTimestamps\n\t\tmrc             = sp.config.MetricRelabelConfigs\n\t)\n\n\tfor fp, oldLoop := range sp.loops {\n\t\tvar (\n\t\t\tt       = sp.activeTargets[fp]\n\t\t\ts       = &targetScraper{Target: t, client: sp.client, timeout: timeout}\n\t\t\tnewLoop = sp.newLoop(scrapeLoopOptions{\n\t\t\t\ttarget:          t,\n\t\t\t\tscraper:         s,\n\t\t\t\tlimit:           limit,\n\t\t\t\thonorLabels:     honorLabels,\n\t\t\t\thonorTimestamps: honorTimestamps,\n\t\t\t\tmrc:             mrc,\n\t\t\t})\n\t\t)\n\t\twg.Add(1)\n\n\t\tgo func(oldLoop, newLoop loop) {\n\t\t\toldLoop.stop()\n\t\t\twg.Done()\n\n\t\t\tgo newLoop.run(interval, timeout, nil)\n\t\t}(oldLoop, newLoop)\n\n\t\tsp.loops[fp] = newLoop\n\t}\n\n\twg.Wait()\n\toldClient.CloseIdleConnections()\n\ttargetReloadIntervalLength.WithLabelValues(interval.String()).Observe(\n\t\ttime.Since(start).Seconds(),\n\t)\n\treturn nil\n}\n\n```\n\n1. 把解析好的配置，遍历，变为一个jobName为key，配置值为Value的map\n2. 对比自己的配置，如果之前已经存在但是配置发生变动的，则去reload scraper pool的配置。\n3. （Reload） 如果需要reload配置的情况下，会重新生成scrapePool后，派生多一个线程去执行scraperPool.Sync()，知道Manager的targetSet被遍历完为止。Sync方法的内容会后面进行详细讲解。\n\nRun()方法\n```\nfunc (m *Manager) Run(tsets <-chan map[string][]*targetgroup.Group) error {\n\tgo m.reloader()\n\tfor {\n\t\tselect {\n\t\tcase ts := <-tsets:\n\t\t\tm.updateTsets(ts)\n\n\t\t\tselect {\n\t\t\tcase m.triggerReload <- struct{}{}:\n\t\t\tdefault:\n\t\t\t}\n\n\t\tcase <-m.graceShut:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n\nfunc (m *Manager) reloader() {\n\tticker := time.NewTicker(5 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-m.graceShut:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tselect {\n\t\t\tcase <-m.triggerReload:\n\t\t\t\tm.reload()\n\t\t\tcase <-m.graceShut:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n```\n功能：\n1. 等待从Main.go中传入的discoveryManager的SyncCh是否有变动，如果有变动，更新Targetset。\n2. 派生出了一个Reloader协程，Reloader协程会定时检查是否有关闭的信号或者Reload信号（triggerReload channel,就是外部给与主协程的刺激产生的二级信号），如果有，则执行reload操作。\n\n\n## 子协程逻辑\n\n### ScraperPool\n```\n// Sync converts target groups into actual scrape targets and synchronizes\n// the currently running scraper with the resulting set and returns all scraped and dropped targets.\nfunc (sp *scrapePool) Sync(tgs []*targetgroup.Group) {\n\tstart := time.Now()\n\n\tvar all []*Target\n\tsp.mtx.Lock()\n\tsp.droppedTargets = []*Target{}\n\tfor _, tg := range tgs {\n\t\ttargets, err := targetsFromGroup(tg, sp.config)\n\t\tif err != nil {\n\t\t\tlevel.Error(sp.logger).Log(\"msg\", \"creating targets failed\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tfor _, t := range targets {\n\t\t\tif t.Labels().Len() > 0 {\n\t\t\t\tall = append(all, t)\n\t\t\t} else if t.DiscoveredLabels().Len() > 0 {\n\t\t\t\tsp.droppedTargets = append(sp.droppedTargets, t)\n\t\t\t}\n\t\t}\n\t}\n\tsp.mtx.Unlock()\n\tsp.sync(all)\n\n\ttargetSyncIntervalLength.WithLabelValues(sp.config.JobName).Observe(\n\t\ttime.Since(start).Seconds(),\n\t)\n\ttargetScrapePoolSyncsCounter.WithLabelValues(sp.config.JobName).Inc()\n}\n```\n\nSync函数是一个对外暴露函数的接口：\n1. 把配置解析出来的target结构化。\n2. 调用内部方法sync()来进行数据抓取的执行\n3. 一些计数器添加计数\n\n值得注意的是Append方法，是一个封装了的方法，是同是进行对变量的修改，并且包含了采集到的数据持久化的操作。\n\n\n```\n// sync takes a list of potentially duplicated targets, deduplicates them, starts\n// scrape loops for new targets, and stops scrape loops for disappeared targets.\n// It returns after all stopped scrape loops terminated.\nfunc (sp *scrapePool) sync(targets []*Target) {\n\tsp.mtx.Lock()\n\tdefer sp.mtx.Unlock()\n\n\tvar (\n\t\tuniqueTargets   = map[uint64]struct{}{}\n\t\tinterval        = time.Duration(sp.config.ScrapeInterval)\n\t\ttimeout         = time.Duration(sp.config.ScrapeTimeout)\n\t\tlimit           = int(sp.config.SampleLimit)\n\t\thonorLabels     = sp.config.HonorLabels\n\t\thonorTimestamps = sp.config.HonorTimestamps\n\t\tmrc             = sp.config.MetricRelabelConfigs\n\t)\n\n\tfor _, t := range targets {\n\t\tt := t\n\t\thash := t.hash()\n\t\tuniqueTargets[hash] = struct{}{}\n\n\t\tif _, ok := sp.activeTargets[hash]; !ok {\n\t\t\ts := &targetScraper{Target: t, client: sp.client, timeout: timeout}\n\t\t\tl := sp.newLoop(scrapeLoopOptions{\n\t\t\t\ttarget:          t,\n\t\t\t\tscraper:         s,\n\t\t\t\tlimit:           limit,\n\t\t\t\thonorLabels:     honorLabels,\n\t\t\t\thonorTimestamps: honorTimestamps,\n\t\t\t\tmrc:             mrc,\n\t\t\t})\n\n\t\t\tsp.activeTargets[hash] = t\n\t\t\tsp.loops[hash] = l\n\n\t\t\tgo l.run(interval, timeout, nil)\n\t\t} else {\n\t\t\t// Need to keep the most updated labels information\n\t\t\t// for displaying it in the Service Discovery web page.\n\t\t\tsp.activeTargets[hash].SetDiscoveredLabels(t.DiscoveredLabels())\n\t\t}\n\t}\n\n\tvar wg sync.WaitGroup\n\n\t// Stop and remove old targets and scraper loops.\n\tfor hash := range sp.activeTargets {\n\t\tif _, ok := uniqueTargets[hash]; !ok {\n\t\t\twg.Add(1)\n\t\t\tgo func(l loop) {\n\n\t\t\t\tl.stop()\n\n\t\t\t\twg.Done()\n\t\t\t}(sp.loops[hash])\n\n\t\t\tdelete(sp.loops, hash)\n\t\t\tdelete(sp.activeTargets, hash)\n\t\t}\n\t}\n\n\t// Wait for all potentially stopped scrapers to terminate.\n\t// This covers the case of flapping targets. If the server is under high load, a new scraper\n\t// may be active and tries to insert. The old scraper that didn't terminate yet could still\n\t// be inserting a previous sample set.\n\twg.Wait()\n}\n```\n\n主要逻辑：\n1. 把传入的Target列表进行遍历\n   1.1 如果target不在active的map中， 生成targetScraper，然后把targetScraper放入Loop里面，调用Loop.run()在协程中进行逻辑\n   1.2 否则， 会先删除旧的协程，然后重新生成协程。\n\n### ScraperLoop\n\n```\nfunc (sl *scrapeLoop) run(interval, timeout time.Duration, errc chan<- error) {\n\tselect {\n\tcase <-time.After(sl.scraper.offset(interval, sl.jitterSeed)):\n\t\t// Continue after a scraping offset.\n\tcase <-sl.ctx.Done():\n\t\tclose(sl.stopped)\n\t\treturn\n\t}\n\n\tvar last time.Time\n\n\tticker := time.NewTicker(interval)\n\tdefer ticker.Stop()\n\nmainLoop:\n\tfor {\n\t\tselect {\n\t\tcase <-sl.parentCtx.Done():\n\t\t\tclose(sl.stopped)\n\t\t\treturn\n\t\tcase <-sl.ctx.Done():\n\t\t\tbreak mainLoop\n\t\tdefault:\n\t\t}\n\n\t\tvar (\n\t\t\tstart             = time.Now()\n\t\t\tscrapeCtx, cancel = context.WithTimeout(sl.ctx, timeout)\n\t\t)\n\n\t\t// Only record after the first scrape.\n\t\tif !last.IsZero() {\n\t\t\ttargetIntervalLength.WithLabelValues(interval.String()).Observe(\n\t\t\t\ttime.Since(last).Seconds(),\n\t\t\t)\n\t\t}\n\n\t\tb := sl.buffers.Get(sl.lastScrapeSize).([]byte)\n\t\tbuf := bytes.NewBuffer(b)\n\n\t\tcontentType, scrapeErr := sl.scraper.scrape(scrapeCtx, buf)\n\t\tcancel()\n\n\t\tif scrapeErr == nil {\n\t\t\tb = buf.Bytes()\n\t\t\t// NOTE: There were issues with misbehaving clients in the past\n\t\t\t// that occasionally returned empty results. We don't want those\n\t\t\t// to falsely reset our buffer size.\n\t\t\tif len(b) > 0 {\n\t\t\t\tsl.lastScrapeSize = len(b)\n\t\t\t}\n\t\t} else {\n\t\t\tlevel.Debug(sl.l).Log(\"msg\", \"Scrape failed\", \"err\", scrapeErr.Error())\n\t\t\tif errc != nil {\n\t\t\t\terrc <- scrapeErr\n\t\t\t}\n\t\t}\n\n\t\t// A failed scrape is the same as an empty scrape,\n\t\t// we still call sl.append to trigger stale markers.\n\t\ttotal, added, seriesAdded, appErr := sl.append(b, contentType, start)\n\t\tif appErr != nil {\n\t\t\tlevel.Warn(sl.l).Log(\"msg\", \"append failed\", \"err\", appErr)\n\t\t\t// The append failed, probably due to a parse error or sample limit.\n\t\t\t// Call sl.append again with an empty scrape to trigger stale markers.\n\t\t\tif _, _, _, err := sl.append([]byte{}, \"\", start); err != nil {\n\t\t\t\tlevel.Warn(sl.l).Log(\"msg\", \"append failed\", \"err\", err)\n\t\t\t}\n\t\t}\n\n\t\tsl.buffers.Put(b)\n\n\t\tif scrapeErr == nil {\n\t\t\tscrapeErr = appErr\n\t\t}\n\n\t\tif err := sl.report(start, time.Since(start), total, added, seriesAdded, scrapeErr); err != nil {\n\t\t\tlevel.Warn(sl.l).Log(\"msg\", \"appending scrape report failed\", \"err\", err)\n\t\t}\n\t\tlast = start\n\n\t\tselect {\n\t\tcase <-sl.parentCtx.Done():\n\t\t\tclose(sl.stopped)\n\t\t\treturn\n\t\tcase <-sl.ctx.Done():\n\t\t\tbreak mainLoop\n\t\tcase <-ticker.C:\n\t\t}\n\t}\n\n\tclose(sl.stopped)\n\n\tsl.endOfRunStaleness(last, ticker, interval)\n}\n```\n\nScraperLoop是单个Target进行获取的执行单位，协程使用死循环进行占用，然后调用scraper接口的Scrape方法去抓取数据，并且调用Stroage模块的Appender的接口金属数据的持久化，然后继续定时休眠的过程。我们需要更加具体的看一下实例Scraper的Scrape方法。\n\nScraperLoop把Scraper抽象出来的三个接口都进行了调用：\n1. 开始部分的Select代码段中的Offset是用于控制第一次执行的时候等待的间隔\n2. Scrape方法就是直接进行数据的抓取，下面有详细解析\n3. report方法，修改Scraper中Target自己保存的状态。\n\n\n\n### TargerScraper\n```\nfunc (s *targetScraper) scrape(ctx context.Context, w io.Writer) (string, error) {\n\tif s.req == nil {\n\t\treq, err := http.NewRequest(\"GET\", s.URL().String(), nil)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treq.Header.Add(\"Accept\", acceptHeader)\n\t\treq.Header.Add(\"Accept-Encoding\", \"gzip\")\n\t\treq.Header.Set(\"User-Agent\", userAgentHeader)\n\t\treq.Header.Set(\"X-Prometheus-Scrape-Timeout-Seconds\", fmt.Sprintf(\"%f\", s.timeout.Seconds()))\n\n\t\ts.req = req\n\t}\n\n\tresp, err := s.client.Do(s.req.WithContext(ctx))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer func() {\n\t\tio.Copy(ioutil.Discard, resp.Body)\n\t\tresp.Body.Close()\n\t}()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", errors.Errorf(\"server returned HTTP status %s\", resp.Status)\n\t}\n\n\tif resp.Header.Get(\"Content-Encoding\") != \"gzip\" {\n\t\t_, err = io.Copy(w, resp.Body)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn resp.Header.Get(\"Content-Type\"), nil\n\t}\n\n\tif s.gzipr == nil {\n\t\ts.buf = bufio.NewReader(resp.Body)\n\t\ts.gzipr, err = gzip.NewReader(s.buf)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t} else {\n\t\ts.buf.Reset(resp.Body)\n\t\tif err = s.gzipr.Reset(s.buf); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\t_, err = io.Copy(w, s.gzipr)\n\ts.gzipr.Close()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn resp.Header.Get(\"Content-Type\"), nil\n}\n\n```\n\nScrape方法是使用HttpClient进行对target url 的数据抓取，抓取的内容在context中进行传递，得到返回后，继续解析，返回给ScraperLoop的Run方法使用。","slug":"prometheus-scrape","published":1,"updated":"2021-01-21T07:08:38.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6irard0006k9i5gsd7bfrr","content":"<!-- ---\nlayout: post\ntitle: Prometheus数据抓取源码阅读\nauthor: Ray Chan(ray1888)\ndate: '2019-10-06 15:31:38 +0800'\ncategory: Prometheus\nsummary: Prometheus Scrape Module\nthumbnail: Prometheus.png\n--- -->\n\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li>使用的目的</li>\n<li>代码实现</li>\n</ol>\n\n        <h1 id=\"代码版本\"   >\n          <a href=\"#代码版本\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码版本</h1>\n      <p>基于 prometheus项目的master branch的5a554df0855bf707a8c333c0dd830067d03422cf commit</p>\n\n        <h1 id=\"使用目的\"   >\n          <a href=\"#使用目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用目的</h1>\n      <p>Prometheus 是一个基于Pull模型所进行数据采集的系统，因此，需要在主体项目中有一个抓取数据的模块，而Scrape就是这样的模块。因此这个也是Prometheus的一个主要部分。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">入口代码部分</span><br><span class=\"line\">main.go</span><br><span class=\"line\">&#x2F;&#x2F; line 356</span><br><span class=\"line\">scrapeManager &#x3D; scrape.NewManager(log.With(logger, &quot;component&quot;, &quot;scrape manager&quot;), fanoutStorage)</span><br><span class=\"line\">&#x2F;&#x2F; line 427</span><br><span class=\"line\">scrapeManager.ApplyConfig</span><br><span class=\"line\">&#x2F;&#x2F; line 555</span><br><span class=\"line\">err :&#x3D; scrapeManager.Run(discoveryManagerScrape.SyncCh())</span><br></pre></td></tr></table></div></figure>\n\n        <h1 id=\"代码实现\"   >\n          <a href=\"#代码实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码实现</h1>\n      \n        <h2 id=\"整体的流程图\"   >\n          <a href=\"#整体的流程图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>整体的流程图</h2>\n      <!-- ![ServiceDiscoveryModule](/assets/img/posts/prometheus/ScrapeModule.png) -->\n<img src=\"/2019/10/06/prometheus-scrape/ScrapeModule.png\" class=\"\" title=\"ServiceDiscoveryModule\">\n\n\n        <h2 id=\"目录结构\"   >\n          <a href=\"#目录结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录结构</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 ray 197121  2239 9月  30 16:09 helpers_test.go</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121  7543 9月  30 16:09 manager.go   &#x2F;&#x2F;主要的控制的模块Manager</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121 10727 9月  30 16:09 manager_test.go</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121 35749 9月  30 16:09 scrape.go    &#x2F;&#x2F; 主要进行采集的模块</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121 40682 9月  30 16:09 scrape_test.go</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121 11743 9月  30 16:09 target.go    &#x2F;&#x2F;  抓取的公用部分的逻辑</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121  9542 9月  30 16:09 target_test.go</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"重要数据结构描述\"   >\n          <a href=\"#重要数据结构描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>重要数据结构描述</h2>\n      <p>ScrapeManager 是管理所有抓取的一个抽象</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Manager struct &#123;</span><br><span class=\"line\">\tlogger    log.Logger</span><br><span class=\"line\">\tappend    Appendable</span><br><span class=\"line\">\tgraceShut chan struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tjitterSeed    uint64     &#x2F;&#x2F; Global jitterSeed seed is used to spread scrape workload across HA setup.</span><br><span class=\"line\">\tmtxScrape     sync.Mutex &#x2F;&#x2F; Guards the fields below.</span><br><span class=\"line\">\tscrapeConfigs map[string]*config.ScrapeConfig</span><br><span class=\"line\">\tscrapePools   map[string]*scrapePool</span><br><span class=\"line\">\ttargetSets    map[string][]*targetgroup.Group</span><br><span class=\"line\"></span><br><span class=\"line\">\ttriggerReload chan struct&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>ScrapePools 是单个的Job的抓取目标的工作单位</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendable Appendable</span><br><span class=\"line\">\tlogger     log.Logger</span><br><span class=\"line\"></span><br><span class=\"line\">\tmtx    sync.RWMutex</span><br><span class=\"line\">\tconfig *config.ScrapeConfig</span><br><span class=\"line\">\tclient *http.Client</span><br><span class=\"line\">\t&#x2F;&#x2F; Targets and loops must always be synchronized to have the same</span><br><span class=\"line\">\t&#x2F;&#x2F; set of hashes.</span><br><span class=\"line\">\tactiveTargets  map[uint64]*Target</span><br><span class=\"line\">\tdroppedTargets []*Target</span><br><span class=\"line\">\tloops          map[uint64]loop</span><br><span class=\"line\">\tcancel         context.CancelFunc</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Constructor for new scrape loops. This is settable for testing convenience.</span><br><span class=\"line\">\tnewLoop func(scrapeLoopOptions) loop</span><br></pre></td></tr></table></div></figure>\n<p>loop是单个Target的执行单位，是一个接口。在这里主要使用的是ScrapeLoop的实例</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type loop interface &#123;</span><br><span class=\"line\">\trun(interval, timeout time.Duration, errc chan&lt;- error)</span><br><span class=\"line\">\tstop()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type scrapeLoop struct &#123;</span><br><span class=\"line\">\tscraper         scraper</span><br><span class=\"line\">\tl               log.Logger</span><br><span class=\"line\">\tcache           *scrapeCache</span><br><span class=\"line\">\tlastScrapeSize  int</span><br><span class=\"line\">\tbuffers         *pool.Pool</span><br><span class=\"line\">\tjitterSeed      uint64</span><br><span class=\"line\">\thonorTimestamps bool</span><br><span class=\"line\"></span><br><span class=\"line\">\tappender            func() storage.Appender</span><br><span class=\"line\">\tsampleMutator       labelsMutator</span><br><span class=\"line\">\treportSampleMutator labelsMutator</span><br><span class=\"line\"></span><br><span class=\"line\">\tparentCtx context.Context</span><br><span class=\"line\">\tctx       context.Context</span><br><span class=\"line\">\tcancel    func()</span><br><span class=\"line\">\tstopped   chan struct&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>scraper接口时具体的执行单位，scrapeLoop也是调用scraper的方法来进行数据的抓取, Prometheus默认使用targetScraper去抓取数据</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type scraper interface &#123;</span><br><span class=\"line\">\tscrape(ctx context.Context, w io.Writer) (string, error) &#x2F;&#x2F; 抓取数据的方法</span><br><span class=\"line\">\treport(start time.Time, dur time.Duration, err error)    &#x2F;&#x2F; 上报数据的方法</span><br><span class=\"line\">\toffset(interval time.Duration, jitterSeed uint64) time.Duration &#x2F;&#x2F; 记录数据偏移的方法</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type targetScraper struct &#123;</span><br><span class=\"line\">\t*Target  &#x2F;&#x2F;包含了report和offset方法</span><br><span class=\"line\"></span><br><span class=\"line\">\tclient  *http.Client &#x2F;&#x2F;因为Prometheus的exporter是以http接口进行数据的暴露的，所以会有httpclient的结构包含在里面</span><br><span class=\"line\">\treq     *http.Request</span><br><span class=\"line\">\ttimeout time.Duration</span><br><span class=\"line\"></span><br><span class=\"line\">\tgzipr *gzip.Reader</span><br><span class=\"line\">\tbuf   *bufio.Reader</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"主协程逻辑\"   >\n          <a href=\"#主协程逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>主协程逻辑</h2>\n      <p>跟着调用的部分，我们先从初始化后的manager的ApplyConfig方法开始看起。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (m *Manager) ApplyConfig(cfg *config.Config) error &#123;</span><br><span class=\"line\">\tm.mtxScrape.Lock()</span><br><span class=\"line\">\tdefer m.mtxScrape.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tc :&#x3D; make(map[string]*config.ScrapeConfig)</span><br><span class=\"line\">    </span><br><span class=\"line\">\tfor _, scfg :&#x3D; range cfg.ScrapeConfigs &#123;</span><br><span class=\"line\">\t\tc[scfg.JobName] &#x3D; scfg</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tm.scrapeConfigs &#x3D; c</span><br><span class=\"line\">    &#x2F;&#x2F; 使用全局配置来生成一个集群内不重复的seed</span><br><span class=\"line\">\tif err :&#x3D; m.setJitterSeed(cfg.GlobalConfig.ExternalLabels); err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Cleanup and reload pool if the configuration has changed.</span><br><span class=\"line\">\tvar failed bool</span><br><span class=\"line\">    &#x2F;&#x2F; 根据解析出来的配置生成对应的ScrapePool， 如果有并且数据没有改变的话，那就不进行操作，否则</span><br><span class=\"line\">\tfor name, sp :&#x3D; range m.scrapePools &#123;</span><br><span class=\"line\">\t\tif cfg, ok :&#x3D; m.scrapeConfigs[name]; !ok &#123;</span><br><span class=\"line\">\t\t\tsp.stop()</span><br><span class=\"line\">\t\t\tdelete(m.scrapePools, name)</span><br><span class=\"line\">\t\t&#125; else if !reflect.DeepEqual(sp.config, cfg) &#123;</span><br><span class=\"line\">\t\t\terr :&#x3D; sp.reload(cfg)</span><br><span class=\"line\">\t\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\tlevel.Error(m.logger).Log(&quot;msg&quot;, &quot;error reloading scrape pool&quot;, &quot;err&quot;, err, &quot;scrape_pool&quot;, name)</span><br><span class=\"line\">\t\t\t\tfailed &#x3D; true</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif failed &#123;</span><br><span class=\"line\">\t\treturn errors.New(&quot;failed to apply the new configuration&quot;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (sp *scrapePool) reload(cfg *config.ScrapeConfig) error &#123;</span><br><span class=\"line\">\ttargetScrapePoolReloads.Inc()</span><br><span class=\"line\">\tstart :&#x3D; time.Now()</span><br><span class=\"line\"></span><br><span class=\"line\">\tsp.mtx.Lock()</span><br><span class=\"line\">\tdefer sp.mtx.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tclient, err :&#x3D; config_util.NewClientFromConfig(cfg.HTTPClientConfig, cfg.JobName, false)</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\ttargetScrapePoolReloadsFailed.Inc()</span><br><span class=\"line\">\t\treturn errors.Wrap(err, &quot;error creating HTTP client&quot;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsp.config &#x3D; cfg</span><br><span class=\"line\">\toldClient :&#x3D; sp.client</span><br><span class=\"line\">\tsp.client &#x3D; client</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar (</span><br><span class=\"line\">\t\twg              sync.WaitGroup</span><br><span class=\"line\">\t\tinterval        &#x3D; time.Duration(sp.config.ScrapeInterval)</span><br><span class=\"line\">\t\ttimeout         &#x3D; time.Duration(sp.config.ScrapeTimeout)</span><br><span class=\"line\">\t\tlimit           &#x3D; int(sp.config.SampleLimit)</span><br><span class=\"line\">\t\thonorLabels     &#x3D; sp.config.HonorLabels</span><br><span class=\"line\">\t\thonorTimestamps &#x3D; sp.config.HonorTimestamps</span><br><span class=\"line\">\t\tmrc             &#x3D; sp.config.MetricRelabelConfigs</span><br><span class=\"line\">\t)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor fp, oldLoop :&#x3D; range sp.loops &#123;</span><br><span class=\"line\">\t\tvar (</span><br><span class=\"line\">\t\t\tt       &#x3D; sp.activeTargets[fp]</span><br><span class=\"line\">\t\t\ts       &#x3D; &amp;targetScraper&#123;Target: t, client: sp.client, timeout: timeout&#125;</span><br><span class=\"line\">\t\t\tnewLoop &#x3D; sp.newLoop(scrapeLoopOptions&#123;</span><br><span class=\"line\">\t\t\t\ttarget:          t,</span><br><span class=\"line\">\t\t\t\tscraper:         s,</span><br><span class=\"line\">\t\t\t\tlimit:           limit,</span><br><span class=\"line\">\t\t\t\thonorLabels:     honorLabels,</span><br><span class=\"line\">\t\t\t\thonorTimestamps: honorTimestamps,</span><br><span class=\"line\">\t\t\t\tmrc:             mrc,</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t\twg.Add(1)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tgo func(oldLoop, newLoop loop) &#123;</span><br><span class=\"line\">\t\t\toldLoop.stop()</span><br><span class=\"line\">\t\t\twg.Done()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tgo newLoop.run(interval, timeout, nil)</span><br><span class=\"line\">\t\t&#125;(oldLoop, newLoop)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsp.loops[fp] &#x3D; newLoop</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">\toldClient.CloseIdleConnections()</span><br><span class=\"line\">\ttargetReloadIntervalLength.WithLabelValues(interval.String()).Observe(</span><br><span class=\"line\">\t\ttime.Since(start).Seconds(),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\treturn nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<ol>\n<li>把解析好的配置，遍历，变为一个jobName为key，配置值为Value的map</li>\n<li>对比自己的配置，如果之前已经存在但是配置发生变动的，则去reload scraper pool的配置。</li>\n<li>（Reload） 如果需要reload配置的情况下，会重新生成scrapePool后，派生多一个线程去执行scraperPool.Sync()，知道Manager的targetSet被遍历完为止。Sync方法的内容会后面进行详细讲解。</li>\n</ol>\n<p>Run()方法</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (m *Manager) Run(tsets &lt;-chan map[string][]*targetgroup.Group) error &#123;</span><br><span class=\"line\">\tgo m.reloader()</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase ts :&#x3D; &lt;-tsets:</span><br><span class=\"line\">\t\t\tm.updateTsets(ts)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\tcase m.triggerReload &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcase &lt;-m.graceShut:</span><br><span class=\"line\">\t\t\treturn nil</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">func (m *Manager) reloader() &#123;</span><br><span class=\"line\">\tticker :&#x3D; time.NewTicker(5 * time.Second)</span><br><span class=\"line\">\tdefer ticker.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-m.graceShut:</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase &lt;-ticker.C:</span><br><span class=\"line\">\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\tcase &lt;-m.triggerReload:</span><br><span class=\"line\">\t\t\t\tm.reload()</span><br><span class=\"line\">\t\t\tcase &lt;-m.graceShut:</span><br><span class=\"line\">\t\t\t\treturn</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>功能：</p>\n<ol>\n<li>等待从Main.go中传入的discoveryManager的SyncCh是否有变动，如果有变动，更新Targetset。</li>\n<li>派生出了一个Reloader协程，Reloader协程会定时检查是否有关闭的信号或者Reload信号（triggerReload channel,就是外部给与主协程的刺激产生的二级信号），如果有，则执行reload操作。</li>\n</ol>\n\n        <h2 id=\"子协程逻辑\"   >\n          <a href=\"#子协程逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>子协程逻辑</h2>\n      \n        <h3 id=\"ScraperPool\"   >\n          <a href=\"#ScraperPool\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ScraperPool</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Sync converts target groups into actual scrape targets and synchronizes</span><br><span class=\"line\">&#x2F;&#x2F; the currently running scraper with the resulting set and returns all scraped and dropped targets.</span><br><span class=\"line\">func (sp *scrapePool) Sync(tgs []*targetgroup.Group) &#123;</span><br><span class=\"line\">\tstart :&#x3D; time.Now()</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar all []*Target</span><br><span class=\"line\">\tsp.mtx.Lock()</span><br><span class=\"line\">\tsp.droppedTargets &#x3D; []*Target&#123;&#125;</span><br><span class=\"line\">\tfor _, tg :&#x3D; range tgs &#123;</span><br><span class=\"line\">\t\ttargets, err :&#x3D; targetsFromGroup(tg, sp.config)</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tlevel.Error(sp.logger).Log(&quot;msg&quot;, &quot;creating targets failed&quot;, &quot;err&quot;, err)</span><br><span class=\"line\">\t\t\tcontinue</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor _, t :&#x3D; range targets &#123;</span><br><span class=\"line\">\t\t\tif t.Labels().Len() &gt; 0 &#123;</span><br><span class=\"line\">\t\t\t\tall &#x3D; append(all, t)</span><br><span class=\"line\">\t\t\t&#125; else if t.DiscoveredLabels().Len() &gt; 0 &#123;</span><br><span class=\"line\">\t\t\t\tsp.droppedTargets &#x3D; append(sp.droppedTargets, t)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsp.mtx.Unlock()</span><br><span class=\"line\">\tsp.sync(all)</span><br><span class=\"line\"></span><br><span class=\"line\">\ttargetSyncIntervalLength.WithLabelValues(sp.config.JobName).Observe(</span><br><span class=\"line\">\t\ttime.Since(start).Seconds(),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\ttargetScrapePoolSyncsCounter.WithLabelValues(sp.config.JobName).Inc()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Sync函数是一个对外暴露函数的接口：</p>\n<ol>\n<li>把配置解析出来的target结构化。</li>\n<li>调用内部方法sync()来进行数据抓取的执行</li>\n<li>一些计数器添加计数</li>\n</ol>\n<p>值得注意的是Append方法，是一个封装了的方法，是同是进行对变量的修改，并且包含了采集到的数据持久化的操作。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; sync takes a list of potentially duplicated targets, deduplicates them, starts</span><br><span class=\"line\">&#x2F;&#x2F; scrape loops for new targets, and stops scrape loops for disappeared targets.</span><br><span class=\"line\">&#x2F;&#x2F; It returns after all stopped scrape loops terminated.</span><br><span class=\"line\">func (sp *scrapePool) sync(targets []*Target) &#123;</span><br><span class=\"line\">\tsp.mtx.Lock()</span><br><span class=\"line\">\tdefer sp.mtx.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar (</span><br><span class=\"line\">\t\tuniqueTargets   &#x3D; map[uint64]struct&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\tinterval        &#x3D; time.Duration(sp.config.ScrapeInterval)</span><br><span class=\"line\">\t\ttimeout         &#x3D; time.Duration(sp.config.ScrapeTimeout)</span><br><span class=\"line\">\t\tlimit           &#x3D; int(sp.config.SampleLimit)</span><br><span class=\"line\">\t\thonorLabels     &#x3D; sp.config.HonorLabels</span><br><span class=\"line\">\t\thonorTimestamps &#x3D; sp.config.HonorTimestamps</span><br><span class=\"line\">\t\tmrc             &#x3D; sp.config.MetricRelabelConfigs</span><br><span class=\"line\">\t)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor _, t :&#x3D; range targets &#123;</span><br><span class=\"line\">\t\tt :&#x3D; t</span><br><span class=\"line\">\t\thash :&#x3D; t.hash()</span><br><span class=\"line\">\t\tuniqueTargets[hash] &#x3D; struct&#123;&#125;&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif _, ok :&#x3D; sp.activeTargets[hash]; !ok &#123;</span><br><span class=\"line\">\t\t\ts :&#x3D; &amp;targetScraper&#123;Target: t, client: sp.client, timeout: timeout&#125;</span><br><span class=\"line\">\t\t\tl :&#x3D; sp.newLoop(scrapeLoopOptions&#123;</span><br><span class=\"line\">\t\t\t\ttarget:          t,</span><br><span class=\"line\">\t\t\t\tscraper:         s,</span><br><span class=\"line\">\t\t\t\tlimit:           limit,</span><br><span class=\"line\">\t\t\t\thonorLabels:     honorLabels,</span><br><span class=\"line\">\t\t\t\thonorTimestamps: honorTimestamps,</span><br><span class=\"line\">\t\t\t\tmrc:             mrc,</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tsp.activeTargets[hash] &#x3D; t</span><br><span class=\"line\">\t\t\tsp.loops[hash] &#x3D; l</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tgo l.run(interval, timeout, nil)</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Need to keep the most updated labels information</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; for displaying it in the Service Discovery web page.</span><br><span class=\"line\">\t\t\tsp.activeTargets[hash].SetDiscoveredLabels(t.DiscoveredLabels())</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Stop and remove old targets and scraper loops.</span><br><span class=\"line\">\tfor hash :&#x3D; range sp.activeTargets &#123;</span><br><span class=\"line\">\t\tif _, ok :&#x3D; uniqueTargets[hash]; !ok &#123;</span><br><span class=\"line\">\t\t\twg.Add(1)</span><br><span class=\"line\">\t\t\tgo func(l loop) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tl.stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\twg.Done()</span><br><span class=\"line\">\t\t\t&#125;(sp.loops[hash])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tdelete(sp.loops, hash)</span><br><span class=\"line\">\t\t\tdelete(sp.activeTargets, hash)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Wait for all potentially stopped scrapers to terminate.</span><br><span class=\"line\">\t&#x2F;&#x2F; This covers the case of flapping targets. If the server is under high load, a new scraper</span><br><span class=\"line\">\t&#x2F;&#x2F; may be active and tries to insert. The old scraper that didn&#39;t terminate yet could still</span><br><span class=\"line\">\t&#x2F;&#x2F; be inserting a previous sample set.</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>主要逻辑：</p>\n<ol>\n<li>把传入的Target列表进行遍历<br>1.1 如果target不在active的map中， 生成targetScraper，然后把targetScraper放入Loop里面，调用Loop.run()在协程中进行逻辑<br>1.2 否则， 会先删除旧的协程，然后重新生成协程。</li>\n</ol>\n\n        <h3 id=\"ScraperLoop\"   >\n          <a href=\"#ScraperLoop\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ScraperLoop</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (sl *scrapeLoop) run(interval, timeout time.Duration, errc chan&lt;- error) &#123;</span><br><span class=\"line\">\tselect &#123;</span><br><span class=\"line\">\tcase &lt;-time.After(sl.scraper.offset(interval, sl.jitterSeed)):</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Continue after a scraping offset.</span><br><span class=\"line\">\tcase &lt;-sl.ctx.Done():</span><br><span class=\"line\">\t\tclose(sl.stopped)</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar last time.Time</span><br><span class=\"line\"></span><br><span class=\"line\">\tticker :&#x3D; time.NewTicker(interval)</span><br><span class=\"line\">\tdefer ticker.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">mainLoop:</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-sl.parentCtx.Done():</span><br><span class=\"line\">\t\t\tclose(sl.stopped)</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase &lt;-sl.ctx.Done():</span><br><span class=\"line\">\t\t\tbreak mainLoop</span><br><span class=\"line\">\t\tdefault:</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar (</span><br><span class=\"line\">\t\t\tstart             &#x3D; time.Now()</span><br><span class=\"line\">\t\t\tscrapeCtx, cancel &#x3D; context.WithTimeout(sl.ctx, timeout)</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F; Only record after the first scrape.</span><br><span class=\"line\">\t\tif !last.IsZero() &#123;</span><br><span class=\"line\">\t\t\ttargetIntervalLength.WithLabelValues(interval.String()).Observe(</span><br><span class=\"line\">\t\t\t\ttime.Since(last).Seconds(),</span><br><span class=\"line\">\t\t\t)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tb :&#x3D; sl.buffers.Get(sl.lastScrapeSize).([]byte)</span><br><span class=\"line\">\t\tbuf :&#x3D; bytes.NewBuffer(b)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcontentType, scrapeErr :&#x3D; sl.scraper.scrape(scrapeCtx, buf)</span><br><span class=\"line\">\t\tcancel()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif scrapeErr &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tb &#x3D; buf.Bytes()</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; NOTE: There were issues with misbehaving clients in the past</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; that occasionally returned empty results. We don&#39;t want those</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; to falsely reset our buffer size.</span><br><span class=\"line\">\t\t\tif len(b) &gt; 0 &#123;</span><br><span class=\"line\">\t\t\t\tsl.lastScrapeSize &#x3D; len(b)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tlevel.Debug(sl.l).Log(&quot;msg&quot;, &quot;Scrape failed&quot;, &quot;err&quot;, scrapeErr.Error())</span><br><span class=\"line\">\t\t\tif errc !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\terrc &lt;- scrapeErr</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F; A failed scrape is the same as an empty scrape,</span><br><span class=\"line\">\t\t&#x2F;&#x2F; we still call sl.append to trigger stale markers.</span><br><span class=\"line\">\t\ttotal, added, seriesAdded, appErr :&#x3D; sl.append(b, contentType, start)</span><br><span class=\"line\">\t\tif appErr !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tlevel.Warn(sl.l).Log(&quot;msg&quot;, &quot;append failed&quot;, &quot;err&quot;, appErr)</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; The append failed, probably due to a parse error or sample limit.</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Call sl.append again with an empty scrape to trigger stale markers.</span><br><span class=\"line\">\t\t\tif _, _, _, err :&#x3D; sl.append([]byte&#123;&#125;, &quot;&quot;, start); err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\tlevel.Warn(sl.l).Log(&quot;msg&quot;, &quot;append failed&quot;, &quot;err&quot;, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsl.buffers.Put(b)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif scrapeErr &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tscrapeErr &#x3D; appErr</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif err :&#x3D; sl.report(start, time.Since(start), total, added, seriesAdded, scrapeErr); err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tlevel.Warn(sl.l).Log(&quot;msg&quot;, &quot;appending scrape report failed&quot;, &quot;err&quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlast &#x3D; start</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-sl.parentCtx.Done():</span><br><span class=\"line\">\t\t\tclose(sl.stopped)</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase &lt;-sl.ctx.Done():</span><br><span class=\"line\">\t\t\tbreak mainLoop</span><br><span class=\"line\">\t\tcase &lt;-ticker.C:</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tclose(sl.stopped)</span><br><span class=\"line\"></span><br><span class=\"line\">\tsl.endOfRunStaleness(last, ticker, interval)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>ScraperLoop是单个Target进行获取的执行单位，协程使用死循环进行占用，然后调用scraper接口的Scrape方法去抓取数据，并且调用Stroage模块的Appender的接口金属数据的持久化，然后继续定时休眠的过程。我们需要更加具体的看一下实例Scraper的Scrape方法。</p>\n<p>ScraperLoop把Scraper抽象出来的三个接口都进行了调用：</p>\n<ol>\n<li>开始部分的Select代码段中的Offset是用于控制第一次执行的时候等待的间隔</li>\n<li>Scrape方法就是直接进行数据的抓取，下面有详细解析</li>\n<li>report方法，修改Scraper中Target自己保存的状态。</li>\n</ol>\n\n        <h3 id=\"TargerScraper\"   >\n          <a href=\"#TargerScraper\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>TargerScraper</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (s *targetScraper) scrape(ctx context.Context, w io.Writer) (string, error) &#123;</span><br><span class=\"line\">\tif s.req &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\treq, err :&#x3D; http.NewRequest(&quot;GET&quot;, s.URL().String(), nil)</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treq.Header.Add(&quot;Accept&quot;, acceptHeader)</span><br><span class=\"line\">\t\treq.Header.Add(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</span><br><span class=\"line\">\t\treq.Header.Set(&quot;User-Agent&quot;, userAgentHeader)</span><br><span class=\"line\">\t\treq.Header.Set(&quot;X-Prometheus-Scrape-Timeout-Seconds&quot;, fmt.Sprintf(&quot;%f&quot;, s.timeout.Seconds()))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts.req &#x3D; req</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tresp, err :&#x3D; s.client.Do(s.req.WithContext(ctx))</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tio.Copy(ioutil.Discard, resp.Body)</span><br><span class=\"line\">\t\tresp.Body.Close()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tif resp.StatusCode !&#x3D; http.StatusOK &#123;</span><br><span class=\"line\">\t\treturn &quot;&quot;, errors.Errorf(&quot;server returned HTTP status %s&quot;, resp.Status)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif resp.Header.Get(&quot;Content-Encoding&quot;) !&#x3D; &quot;gzip&quot; &#123;</span><br><span class=\"line\">\t\t_, err &#x3D; io.Copy(w, resp.Body)</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn resp.Header.Get(&quot;Content-Type&quot;), nil</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif s.gzipr &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\ts.buf &#x3D; bufio.NewReader(resp.Body)</span><br><span class=\"line\">\t\ts.gzipr, err &#x3D; gzip.NewReader(s.buf)</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\ts.buf.Reset(resp.Body)</span><br><span class=\"line\">\t\tif err &#x3D; s.gzipr.Reset(s.buf); err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t_, err &#x3D; io.Copy(w, s.gzipr)</span><br><span class=\"line\">\ts.gzipr.Close()</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn resp.Header.Get(&quot;Content-Type&quot;), nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>Scrape方法是使用HttpClient进行对target url 的数据抓取，抓取的内容在context中进行传递，得到返回后，继续解析，返回给ScraperLoop的Run方法使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<!-- ---\nlayout: post\ntitle: Prometheus数据抓取源码阅读\nauthor: Ray Chan(ray1888)\ndate: '2019-10-06 15:31:38 +0800'\ncategory: Prometheus\nsummary: Prometheus Scrape Module\nthumbnail: Prometheus.png\n--- -->\n\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li>使用的目的</li>\n<li>代码实现</li>\n</ol>\n\n        <h1 id=\"代码版本\"   >\n          <a href=\"#代码版本\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码版本</h1>\n      <p>基于 prometheus项目的master branch的5a554df0855bf707a8c333c0dd830067d03422cf commit</p>\n\n        <h1 id=\"使用目的\"   >\n          <a href=\"#使用目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用目的</h1>\n      <p>Prometheus 是一个基于Pull模型所进行数据采集的系统，因此，需要在主体项目中有一个抓取数据的模块，而Scrape就是这样的模块。因此这个也是Prometheus的一个主要部分。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">入口代码部分</span><br><span class=\"line\">main.go</span><br><span class=\"line\">&#x2F;&#x2F; line 356</span><br><span class=\"line\">scrapeManager &#x3D; scrape.NewManager(log.With(logger, &quot;component&quot;, &quot;scrape manager&quot;), fanoutStorage)</span><br><span class=\"line\">&#x2F;&#x2F; line 427</span><br><span class=\"line\">scrapeManager.ApplyConfig</span><br><span class=\"line\">&#x2F;&#x2F; line 555</span><br><span class=\"line\">err :&#x3D; scrapeManager.Run(discoveryManagerScrape.SyncCh())</span><br></pre></td></tr></table></div></figure>\n\n        <h1 id=\"代码实现\"   >\n          <a href=\"#代码实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码实现</h1>\n      \n        <h2 id=\"整体的流程图\"   >\n          <a href=\"#整体的流程图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>整体的流程图</h2>\n      <!-- ![ServiceDiscoveryModule](/assets/img/posts/prometheus/ScrapeModule.png) -->\n<img src=\"/2019/10/06/prometheus-scrape/ScrapeModule.png\" class=\"\" title=\"ServiceDiscoveryModule\">\n\n\n        <h2 id=\"目录结构\"   >\n          <a href=\"#目录结构\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录结构</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 ray 197121  2239 9月  30 16:09 helpers_test.go</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121  7543 9月  30 16:09 manager.go   &#x2F;&#x2F;主要的控制的模块Manager</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121 10727 9月  30 16:09 manager_test.go</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121 35749 9月  30 16:09 scrape.go    &#x2F;&#x2F; 主要进行采集的模块</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121 40682 9月  30 16:09 scrape_test.go</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121 11743 9月  30 16:09 target.go    &#x2F;&#x2F;  抓取的公用部分的逻辑</span><br><span class=\"line\">-rw-r--r-- 1 ray 197121  9542 9月  30 16:09 target_test.go</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"重要数据结构描述\"   >\n          <a href=\"#重要数据结构描述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>重要数据结构描述</h2>\n      <p>ScrapeManager 是管理所有抓取的一个抽象</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Manager struct &#123;</span><br><span class=\"line\">\tlogger    log.Logger</span><br><span class=\"line\">\tappend    Appendable</span><br><span class=\"line\">\tgraceShut chan struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tjitterSeed    uint64     &#x2F;&#x2F; Global jitterSeed seed is used to spread scrape workload across HA setup.</span><br><span class=\"line\">\tmtxScrape     sync.Mutex &#x2F;&#x2F; Guards the fields below.</span><br><span class=\"line\">\tscrapeConfigs map[string]*config.ScrapeConfig</span><br><span class=\"line\">\tscrapePools   map[string]*scrapePool</span><br><span class=\"line\">\ttargetSets    map[string][]*targetgroup.Group</span><br><span class=\"line\"></span><br><span class=\"line\">\ttriggerReload chan struct&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>ScrapePools 是单个的Job的抓取目标的工作单位</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendable Appendable</span><br><span class=\"line\">\tlogger     log.Logger</span><br><span class=\"line\"></span><br><span class=\"line\">\tmtx    sync.RWMutex</span><br><span class=\"line\">\tconfig *config.ScrapeConfig</span><br><span class=\"line\">\tclient *http.Client</span><br><span class=\"line\">\t&#x2F;&#x2F; Targets and loops must always be synchronized to have the same</span><br><span class=\"line\">\t&#x2F;&#x2F; set of hashes.</span><br><span class=\"line\">\tactiveTargets  map[uint64]*Target</span><br><span class=\"line\">\tdroppedTargets []*Target</span><br><span class=\"line\">\tloops          map[uint64]loop</span><br><span class=\"line\">\tcancel         context.CancelFunc</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Constructor for new scrape loops. This is settable for testing convenience.</span><br><span class=\"line\">\tnewLoop func(scrapeLoopOptions) loop</span><br></pre></td></tr></table></div></figure>\n<p>loop是单个Target的执行单位，是一个接口。在这里主要使用的是ScrapeLoop的实例</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type loop interface &#123;</span><br><span class=\"line\">\trun(interval, timeout time.Duration, errc chan&lt;- error)</span><br><span class=\"line\">\tstop()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type scrapeLoop struct &#123;</span><br><span class=\"line\">\tscraper         scraper</span><br><span class=\"line\">\tl               log.Logger</span><br><span class=\"line\">\tcache           *scrapeCache</span><br><span class=\"line\">\tlastScrapeSize  int</span><br><span class=\"line\">\tbuffers         *pool.Pool</span><br><span class=\"line\">\tjitterSeed      uint64</span><br><span class=\"line\">\thonorTimestamps bool</span><br><span class=\"line\"></span><br><span class=\"line\">\tappender            func() storage.Appender</span><br><span class=\"line\">\tsampleMutator       labelsMutator</span><br><span class=\"line\">\treportSampleMutator labelsMutator</span><br><span class=\"line\"></span><br><span class=\"line\">\tparentCtx context.Context</span><br><span class=\"line\">\tctx       context.Context</span><br><span class=\"line\">\tcancel    func()</span><br><span class=\"line\">\tstopped   chan struct&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>scraper接口时具体的执行单位，scrapeLoop也是调用scraper的方法来进行数据的抓取, Prometheus默认使用targetScraper去抓取数据</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type scraper interface &#123;</span><br><span class=\"line\">\tscrape(ctx context.Context, w io.Writer) (string, error) &#x2F;&#x2F; 抓取数据的方法</span><br><span class=\"line\">\treport(start time.Time, dur time.Duration, err error)    &#x2F;&#x2F; 上报数据的方法</span><br><span class=\"line\">\toffset(interval time.Duration, jitterSeed uint64) time.Duration &#x2F;&#x2F; 记录数据偏移的方法</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type targetScraper struct &#123;</span><br><span class=\"line\">\t*Target  &#x2F;&#x2F;包含了report和offset方法</span><br><span class=\"line\"></span><br><span class=\"line\">\tclient  *http.Client &#x2F;&#x2F;因为Prometheus的exporter是以http接口进行数据的暴露的，所以会有httpclient的结构包含在里面</span><br><span class=\"line\">\treq     *http.Request</span><br><span class=\"line\">\ttimeout time.Duration</span><br><span class=\"line\"></span><br><span class=\"line\">\tgzipr *gzip.Reader</span><br><span class=\"line\">\tbuf   *bufio.Reader</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"主协程逻辑\"   >\n          <a href=\"#主协程逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>主协程逻辑</h2>\n      <p>跟着调用的部分，我们先从初始化后的manager的ApplyConfig方法开始看起。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (m *Manager) ApplyConfig(cfg *config.Config) error &#123;</span><br><span class=\"line\">\tm.mtxScrape.Lock()</span><br><span class=\"line\">\tdefer m.mtxScrape.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tc :&#x3D; make(map[string]*config.ScrapeConfig)</span><br><span class=\"line\">    </span><br><span class=\"line\">\tfor _, scfg :&#x3D; range cfg.ScrapeConfigs &#123;</span><br><span class=\"line\">\t\tc[scfg.JobName] &#x3D; scfg</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tm.scrapeConfigs &#x3D; c</span><br><span class=\"line\">    &#x2F;&#x2F; 使用全局配置来生成一个集群内不重复的seed</span><br><span class=\"line\">\tif err :&#x3D; m.setJitterSeed(cfg.GlobalConfig.ExternalLabels); err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Cleanup and reload pool if the configuration has changed.</span><br><span class=\"line\">\tvar failed bool</span><br><span class=\"line\">    &#x2F;&#x2F; 根据解析出来的配置生成对应的ScrapePool， 如果有并且数据没有改变的话，那就不进行操作，否则</span><br><span class=\"line\">\tfor name, sp :&#x3D; range m.scrapePools &#123;</span><br><span class=\"line\">\t\tif cfg, ok :&#x3D; m.scrapeConfigs[name]; !ok &#123;</span><br><span class=\"line\">\t\t\tsp.stop()</span><br><span class=\"line\">\t\t\tdelete(m.scrapePools, name)</span><br><span class=\"line\">\t\t&#125; else if !reflect.DeepEqual(sp.config, cfg) &#123;</span><br><span class=\"line\">\t\t\terr :&#x3D; sp.reload(cfg)</span><br><span class=\"line\">\t\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\tlevel.Error(m.logger).Log(&quot;msg&quot;, &quot;error reloading scrape pool&quot;, &quot;err&quot;, err, &quot;scrape_pool&quot;, name)</span><br><span class=\"line\">\t\t\t\tfailed &#x3D; true</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif failed &#123;</span><br><span class=\"line\">\t\treturn errors.New(&quot;failed to apply the new configuration&quot;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (sp *scrapePool) reload(cfg *config.ScrapeConfig) error &#123;</span><br><span class=\"line\">\ttargetScrapePoolReloads.Inc()</span><br><span class=\"line\">\tstart :&#x3D; time.Now()</span><br><span class=\"line\"></span><br><span class=\"line\">\tsp.mtx.Lock()</span><br><span class=\"line\">\tdefer sp.mtx.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tclient, err :&#x3D; config_util.NewClientFromConfig(cfg.HTTPClientConfig, cfg.JobName, false)</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\ttargetScrapePoolReloadsFailed.Inc()</span><br><span class=\"line\">\t\treturn errors.Wrap(err, &quot;error creating HTTP client&quot;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsp.config &#x3D; cfg</span><br><span class=\"line\">\toldClient :&#x3D; sp.client</span><br><span class=\"line\">\tsp.client &#x3D; client</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar (</span><br><span class=\"line\">\t\twg              sync.WaitGroup</span><br><span class=\"line\">\t\tinterval        &#x3D; time.Duration(sp.config.ScrapeInterval)</span><br><span class=\"line\">\t\ttimeout         &#x3D; time.Duration(sp.config.ScrapeTimeout)</span><br><span class=\"line\">\t\tlimit           &#x3D; int(sp.config.SampleLimit)</span><br><span class=\"line\">\t\thonorLabels     &#x3D; sp.config.HonorLabels</span><br><span class=\"line\">\t\thonorTimestamps &#x3D; sp.config.HonorTimestamps</span><br><span class=\"line\">\t\tmrc             &#x3D; sp.config.MetricRelabelConfigs</span><br><span class=\"line\">\t)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor fp, oldLoop :&#x3D; range sp.loops &#123;</span><br><span class=\"line\">\t\tvar (</span><br><span class=\"line\">\t\t\tt       &#x3D; sp.activeTargets[fp]</span><br><span class=\"line\">\t\t\ts       &#x3D; &amp;targetScraper&#123;Target: t, client: sp.client, timeout: timeout&#125;</span><br><span class=\"line\">\t\t\tnewLoop &#x3D; sp.newLoop(scrapeLoopOptions&#123;</span><br><span class=\"line\">\t\t\t\ttarget:          t,</span><br><span class=\"line\">\t\t\t\tscraper:         s,</span><br><span class=\"line\">\t\t\t\tlimit:           limit,</span><br><span class=\"line\">\t\t\t\thonorLabels:     honorLabels,</span><br><span class=\"line\">\t\t\t\thonorTimestamps: honorTimestamps,</span><br><span class=\"line\">\t\t\t\tmrc:             mrc,</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t\twg.Add(1)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tgo func(oldLoop, newLoop loop) &#123;</span><br><span class=\"line\">\t\t\toldLoop.stop()</span><br><span class=\"line\">\t\t\twg.Done()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tgo newLoop.run(interval, timeout, nil)</span><br><span class=\"line\">\t\t&#125;(oldLoop, newLoop)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsp.loops[fp] &#x3D; newLoop</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">\toldClient.CloseIdleConnections()</span><br><span class=\"line\">\ttargetReloadIntervalLength.WithLabelValues(interval.String()).Observe(</span><br><span class=\"line\">\t\ttime.Since(start).Seconds(),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\treturn nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<ol>\n<li>把解析好的配置，遍历，变为一个jobName为key，配置值为Value的map</li>\n<li>对比自己的配置，如果之前已经存在但是配置发生变动的，则去reload scraper pool的配置。</li>\n<li>（Reload） 如果需要reload配置的情况下，会重新生成scrapePool后，派生多一个线程去执行scraperPool.Sync()，知道Manager的targetSet被遍历完为止。Sync方法的内容会后面进行详细讲解。</li>\n</ol>\n<p>Run()方法</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (m *Manager) Run(tsets &lt;-chan map[string][]*targetgroup.Group) error &#123;</span><br><span class=\"line\">\tgo m.reloader()</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase ts :&#x3D; &lt;-tsets:</span><br><span class=\"line\">\t\t\tm.updateTsets(ts)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\tcase m.triggerReload &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcase &lt;-m.graceShut:</span><br><span class=\"line\">\t\t\treturn nil</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">func (m *Manager) reloader() &#123;</span><br><span class=\"line\">\tticker :&#x3D; time.NewTicker(5 * time.Second)</span><br><span class=\"line\">\tdefer ticker.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-m.graceShut:</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase &lt;-ticker.C:</span><br><span class=\"line\">\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\tcase &lt;-m.triggerReload:</span><br><span class=\"line\">\t\t\t\tm.reload()</span><br><span class=\"line\">\t\t\tcase &lt;-m.graceShut:</span><br><span class=\"line\">\t\t\t\treturn</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>功能：</p>\n<ol>\n<li>等待从Main.go中传入的discoveryManager的SyncCh是否有变动，如果有变动，更新Targetset。</li>\n<li>派生出了一个Reloader协程，Reloader协程会定时检查是否有关闭的信号或者Reload信号（triggerReload channel,就是外部给与主协程的刺激产生的二级信号），如果有，则执行reload操作。</li>\n</ol>\n\n        <h2 id=\"子协程逻辑\"   >\n          <a href=\"#子协程逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>子协程逻辑</h2>\n      \n        <h3 id=\"ScraperPool\"   >\n          <a href=\"#ScraperPool\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ScraperPool</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Sync converts target groups into actual scrape targets and synchronizes</span><br><span class=\"line\">&#x2F;&#x2F; the currently running scraper with the resulting set and returns all scraped and dropped targets.</span><br><span class=\"line\">func (sp *scrapePool) Sync(tgs []*targetgroup.Group) &#123;</span><br><span class=\"line\">\tstart :&#x3D; time.Now()</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar all []*Target</span><br><span class=\"line\">\tsp.mtx.Lock()</span><br><span class=\"line\">\tsp.droppedTargets &#x3D; []*Target&#123;&#125;</span><br><span class=\"line\">\tfor _, tg :&#x3D; range tgs &#123;</span><br><span class=\"line\">\t\ttargets, err :&#x3D; targetsFromGroup(tg, sp.config)</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tlevel.Error(sp.logger).Log(&quot;msg&quot;, &quot;creating targets failed&quot;, &quot;err&quot;, err)</span><br><span class=\"line\">\t\t\tcontinue</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor _, t :&#x3D; range targets &#123;</span><br><span class=\"line\">\t\t\tif t.Labels().Len() &gt; 0 &#123;</span><br><span class=\"line\">\t\t\t\tall &#x3D; append(all, t)</span><br><span class=\"line\">\t\t\t&#125; else if t.DiscoveredLabels().Len() &gt; 0 &#123;</span><br><span class=\"line\">\t\t\t\tsp.droppedTargets &#x3D; append(sp.droppedTargets, t)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsp.mtx.Unlock()</span><br><span class=\"line\">\tsp.sync(all)</span><br><span class=\"line\"></span><br><span class=\"line\">\ttargetSyncIntervalLength.WithLabelValues(sp.config.JobName).Observe(</span><br><span class=\"line\">\t\ttime.Since(start).Seconds(),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\ttargetScrapePoolSyncsCounter.WithLabelValues(sp.config.JobName).Inc()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Sync函数是一个对外暴露函数的接口：</p>\n<ol>\n<li>把配置解析出来的target结构化。</li>\n<li>调用内部方法sync()来进行数据抓取的执行</li>\n<li>一些计数器添加计数</li>\n</ol>\n<p>值得注意的是Append方法，是一个封装了的方法，是同是进行对变量的修改，并且包含了采集到的数据持久化的操作。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; sync takes a list of potentially duplicated targets, deduplicates them, starts</span><br><span class=\"line\">&#x2F;&#x2F; scrape loops for new targets, and stops scrape loops for disappeared targets.</span><br><span class=\"line\">&#x2F;&#x2F; It returns after all stopped scrape loops terminated.</span><br><span class=\"line\">func (sp *scrapePool) sync(targets []*Target) &#123;</span><br><span class=\"line\">\tsp.mtx.Lock()</span><br><span class=\"line\">\tdefer sp.mtx.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar (</span><br><span class=\"line\">\t\tuniqueTargets   &#x3D; map[uint64]struct&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\tinterval        &#x3D; time.Duration(sp.config.ScrapeInterval)</span><br><span class=\"line\">\t\ttimeout         &#x3D; time.Duration(sp.config.ScrapeTimeout)</span><br><span class=\"line\">\t\tlimit           &#x3D; int(sp.config.SampleLimit)</span><br><span class=\"line\">\t\thonorLabels     &#x3D; sp.config.HonorLabels</span><br><span class=\"line\">\t\thonorTimestamps &#x3D; sp.config.HonorTimestamps</span><br><span class=\"line\">\t\tmrc             &#x3D; sp.config.MetricRelabelConfigs</span><br><span class=\"line\">\t)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor _, t :&#x3D; range targets &#123;</span><br><span class=\"line\">\t\tt :&#x3D; t</span><br><span class=\"line\">\t\thash :&#x3D; t.hash()</span><br><span class=\"line\">\t\tuniqueTargets[hash] &#x3D; struct&#123;&#125;&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif _, ok :&#x3D; sp.activeTargets[hash]; !ok &#123;</span><br><span class=\"line\">\t\t\ts :&#x3D; &amp;targetScraper&#123;Target: t, client: sp.client, timeout: timeout&#125;</span><br><span class=\"line\">\t\t\tl :&#x3D; sp.newLoop(scrapeLoopOptions&#123;</span><br><span class=\"line\">\t\t\t\ttarget:          t,</span><br><span class=\"line\">\t\t\t\tscraper:         s,</span><br><span class=\"line\">\t\t\t\tlimit:           limit,</span><br><span class=\"line\">\t\t\t\thonorLabels:     honorLabels,</span><br><span class=\"line\">\t\t\t\thonorTimestamps: honorTimestamps,</span><br><span class=\"line\">\t\t\t\tmrc:             mrc,</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tsp.activeTargets[hash] &#x3D; t</span><br><span class=\"line\">\t\t\tsp.loops[hash] &#x3D; l</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tgo l.run(interval, timeout, nil)</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Need to keep the most updated labels information</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; for displaying it in the Service Discovery web page.</span><br><span class=\"line\">\t\t\tsp.activeTargets[hash].SetDiscoveredLabels(t.DiscoveredLabels())</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Stop and remove old targets and scraper loops.</span><br><span class=\"line\">\tfor hash :&#x3D; range sp.activeTargets &#123;</span><br><span class=\"line\">\t\tif _, ok :&#x3D; uniqueTargets[hash]; !ok &#123;</span><br><span class=\"line\">\t\t\twg.Add(1)</span><br><span class=\"line\">\t\t\tgo func(l loop) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tl.stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\twg.Done()</span><br><span class=\"line\">\t\t\t&#125;(sp.loops[hash])</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tdelete(sp.loops, hash)</span><br><span class=\"line\">\t\t\tdelete(sp.activeTargets, hash)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; Wait for all potentially stopped scrapers to terminate.</span><br><span class=\"line\">\t&#x2F;&#x2F; This covers the case of flapping targets. If the server is under high load, a new scraper</span><br><span class=\"line\">\t&#x2F;&#x2F; may be active and tries to insert. The old scraper that didn&#39;t terminate yet could still</span><br><span class=\"line\">\t&#x2F;&#x2F; be inserting a previous sample set.</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>主要逻辑：</p>\n<ol>\n<li>把传入的Target列表进行遍历<br>1.1 如果target不在active的map中， 生成targetScraper，然后把targetScraper放入Loop里面，调用Loop.run()在协程中进行逻辑<br>1.2 否则， 会先删除旧的协程，然后重新生成协程。</li>\n</ol>\n\n        <h3 id=\"ScraperLoop\"   >\n          <a href=\"#ScraperLoop\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ScraperLoop</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (sl *scrapeLoop) run(interval, timeout time.Duration, errc chan&lt;- error) &#123;</span><br><span class=\"line\">\tselect &#123;</span><br><span class=\"line\">\tcase &lt;-time.After(sl.scraper.offset(interval, sl.jitterSeed)):</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Continue after a scraping offset.</span><br><span class=\"line\">\tcase &lt;-sl.ctx.Done():</span><br><span class=\"line\">\t\tclose(sl.stopped)</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar last time.Time</span><br><span class=\"line\"></span><br><span class=\"line\">\tticker :&#x3D; time.NewTicker(interval)</span><br><span class=\"line\">\tdefer ticker.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">mainLoop:</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-sl.parentCtx.Done():</span><br><span class=\"line\">\t\t\tclose(sl.stopped)</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase &lt;-sl.ctx.Done():</span><br><span class=\"line\">\t\t\tbreak mainLoop</span><br><span class=\"line\">\t\tdefault:</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar (</span><br><span class=\"line\">\t\t\tstart             &#x3D; time.Now()</span><br><span class=\"line\">\t\t\tscrapeCtx, cancel &#x3D; context.WithTimeout(sl.ctx, timeout)</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F; Only record after the first scrape.</span><br><span class=\"line\">\t\tif !last.IsZero() &#123;</span><br><span class=\"line\">\t\t\ttargetIntervalLength.WithLabelValues(interval.String()).Observe(</span><br><span class=\"line\">\t\t\t\ttime.Since(last).Seconds(),</span><br><span class=\"line\">\t\t\t)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tb :&#x3D; sl.buffers.Get(sl.lastScrapeSize).([]byte)</span><br><span class=\"line\">\t\tbuf :&#x3D; bytes.NewBuffer(b)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcontentType, scrapeErr :&#x3D; sl.scraper.scrape(scrapeCtx, buf)</span><br><span class=\"line\">\t\tcancel()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif scrapeErr &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tb &#x3D; buf.Bytes()</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; NOTE: There were issues with misbehaving clients in the past</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; that occasionally returned empty results. We don&#39;t want those</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; to falsely reset our buffer size.</span><br><span class=\"line\">\t\t\tif len(b) &gt; 0 &#123;</span><br><span class=\"line\">\t\t\t\tsl.lastScrapeSize &#x3D; len(b)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tlevel.Debug(sl.l).Log(&quot;msg&quot;, &quot;Scrape failed&quot;, &quot;err&quot;, scrapeErr.Error())</span><br><span class=\"line\">\t\t\tif errc !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\terrc &lt;- scrapeErr</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F; A failed scrape is the same as an empty scrape,</span><br><span class=\"line\">\t\t&#x2F;&#x2F; we still call sl.append to trigger stale markers.</span><br><span class=\"line\">\t\ttotal, added, seriesAdded, appErr :&#x3D; sl.append(b, contentType, start)</span><br><span class=\"line\">\t\tif appErr !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tlevel.Warn(sl.l).Log(&quot;msg&quot;, &quot;append failed&quot;, &quot;err&quot;, appErr)</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; The append failed, probably due to a parse error or sample limit.</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Call sl.append again with an empty scrape to trigger stale markers.</span><br><span class=\"line\">\t\t\tif _, _, _, err :&#x3D; sl.append([]byte&#123;&#125;, &quot;&quot;, start); err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\tlevel.Warn(sl.l).Log(&quot;msg&quot;, &quot;append failed&quot;, &quot;err&quot;, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsl.buffers.Put(b)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif scrapeErr &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tscrapeErr &#x3D; appErr</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif err :&#x3D; sl.report(start, time.Since(start), total, added, seriesAdded, scrapeErr); err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tlevel.Warn(sl.l).Log(&quot;msg&quot;, &quot;appending scrape report failed&quot;, &quot;err&quot;, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlast &#x3D; start</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-sl.parentCtx.Done():</span><br><span class=\"line\">\t\t\tclose(sl.stopped)</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase &lt;-sl.ctx.Done():</span><br><span class=\"line\">\t\t\tbreak mainLoop</span><br><span class=\"line\">\t\tcase &lt;-ticker.C:</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tclose(sl.stopped)</span><br><span class=\"line\"></span><br><span class=\"line\">\tsl.endOfRunStaleness(last, ticker, interval)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>ScraperLoop是单个Target进行获取的执行单位，协程使用死循环进行占用，然后调用scraper接口的Scrape方法去抓取数据，并且调用Stroage模块的Appender的接口金属数据的持久化，然后继续定时休眠的过程。我们需要更加具体的看一下实例Scraper的Scrape方法。</p>\n<p>ScraperLoop把Scraper抽象出来的三个接口都进行了调用：</p>\n<ol>\n<li>开始部分的Select代码段中的Offset是用于控制第一次执行的时候等待的间隔</li>\n<li>Scrape方法就是直接进行数据的抓取，下面有详细解析</li>\n<li>report方法，修改Scraper中Target自己保存的状态。</li>\n</ol>\n\n        <h3 id=\"TargerScraper\"   >\n          <a href=\"#TargerScraper\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>TargerScraper</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (s *targetScraper) scrape(ctx context.Context, w io.Writer) (string, error) &#123;</span><br><span class=\"line\">\tif s.req &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\treq, err :&#x3D; http.NewRequest(&quot;GET&quot;, s.URL().String(), nil)</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treq.Header.Add(&quot;Accept&quot;, acceptHeader)</span><br><span class=\"line\">\t\treq.Header.Add(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</span><br><span class=\"line\">\t\treq.Header.Set(&quot;User-Agent&quot;, userAgentHeader)</span><br><span class=\"line\">\t\treq.Header.Set(&quot;X-Prometheus-Scrape-Timeout-Seconds&quot;, fmt.Sprintf(&quot;%f&quot;, s.timeout.Seconds()))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts.req &#x3D; req</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tresp, err :&#x3D; s.client.Do(s.req.WithContext(ctx))</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tio.Copy(ioutil.Discard, resp.Body)</span><br><span class=\"line\">\t\tresp.Body.Close()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tif resp.StatusCode !&#x3D; http.StatusOK &#123;</span><br><span class=\"line\">\t\treturn &quot;&quot;, errors.Errorf(&quot;server returned HTTP status %s&quot;, resp.Status)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif resp.Header.Get(&quot;Content-Encoding&quot;) !&#x3D; &quot;gzip&quot; &#123;</span><br><span class=\"line\">\t\t_, err &#x3D; io.Copy(w, resp.Body)</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn resp.Header.Get(&quot;Content-Type&quot;), nil</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif s.gzipr &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\ts.buf &#x3D; bufio.NewReader(resp.Body)</span><br><span class=\"line\">\t\ts.gzipr, err &#x3D; gzip.NewReader(s.buf)</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\ts.buf.Reset(resp.Body)</span><br><span class=\"line\">\t\tif err &#x3D; s.gzipr.Reset(s.buf); err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t_, err &#x3D; io.Copy(w, s.gzipr)</span><br><span class=\"line\">\ts.gzipr.Close()</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\treturn &quot;&quot;, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn resp.Header.Get(&quot;Content-Type&quot;), nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>Scrape方法是使用HttpClient进行对target url 的数据抓取，抓取的内容在context中进行传递，得到返回后，继续解析，返回给ScraperLoop的Run方法使用。</p>\n"},{"title":"Prometheus服务发现源码阅读","date":"2019-10-05T12:51:38.000Z","_content":"\n\n<!-- ---\nlayout: post\ntitle: Prometheus服务发现源码阅读\nauthor: Ray Chan(ray1888)\ndate: '2019-10-05 20:51:38 +0800'\ncategory: Prometheus\nsummary: Prometheus Service Discovery Module\nthumbnail: Prometheus.png\n--- -->\n\n# 目录\n1. 使用的目的  \n2. 代码实现  \n   2.1 主协程逻辑  \n   2.2 子协程逻辑\n\n# 代码版本\n\n基于 prometheus项目的master branch的5a554df0855bf707a8c333c0dd830067d03422cf commit\n\n# 使用目的\n服务发现是Prometheus中最重要的功能之一，因为它是支撑Prometheus可以在容器的环境下的最重要的功能。因为应用的容器部署的弹性和有效的时长远与传统的基于服务器（无论是实体机还是虚拟机[OpenStack]这一类的机器）部署， 都会变动的更加快。因此为了适应这种弹性大、变化快的环境，它需要基于不同平台来支持服务发现这个功能。\n\nPrometheus的服务发现模块是在prometheus/discovery的目录下面，它在Prometheus中的体系支撑了采集器的发现和AlertManager的发现。\n可以看下面的代码。\n\n```\n//  此代码在cmd/main.go中的 350-352行\n\tctxScrape, cancelScrape = context.WithCancel(context.Background())\n\tdiscoveryManagerScrape  = discovery.NewManager(ctxScrape, log.With(logger, \"component\", \"discovery manager scrape\"), discovery.Name(\"scrape\"))\n\n\tctxNotify, cancelNotify = context.WithCancel(context.Background())\n\tdiscoveryManagerNotify  = discovery.NewManager(ctxNotify, log.With(logger, \"component\", \"discovery manager notify\"), discovery.Name(\"notify\"))\n\n//  具体注入到两个功能的使用\n/* \n\tcmd/main.go line 555, 把Manager的输出的信道传递给scrapeManager，然后后面就会去restore scrape的方式。\n\t后面会有单独文章写Scrape（抓取数据）的部分\n\t*/\nerr := scrapeManager.Run(discoveryManagerScrape.SyncCh())\n\n/* \n\tcmd/main.go line 726, 把Manager的输出的信道传递给notifierManager，然后后面就会去获取更新alertManager组件的方式。\n\t后面会有单独文章写Notifer（抓取数据）的部分\n\t*/\nnotifierManager.Run(discoveryManagerNotify.SyncCh())\n\n// 在main.go line 735, run Group 会执行上面注册在g 里面的这两个discoveryManager的Run方法。\n```\n\n所以整体的代码执行的入口流程\n1. 在main.go实例化两个discoveryManager来进行服务发现的操作\n2. 把注入的discovery config进行解析，并且生成对应的Provider协程\n3. 主协程执行上面两个discoveryManager的Run方法\n\n# 代码实现\n\n## 模块的运行逻辑图\n\n<!-- ![ServiceDiscoveryModule](/assets/img/posts/prometheus/DiscoverManager.png) -->\n{% asset_img DiscoverManager.png ServiceDiscoveryModule %}\n\n## 主协程的逻辑\n1. 先去读取服务发现相关的配置，调用ApplyConfig()读取存在的service discovery的方式，并且加载到NewManager的结构体中。可以同同时支持多个service Discovery的方式。使用add函数把配置变为Providers结构体。\n```\nadd := func(cfg interface{}, newDiscoverer func() (Discoverer, error)) {\n\t\tt := reflect.TypeOf(cfg).String()\n\t\tfor _, p := range m.providers {\n\t\t\tif reflect.DeepEqual(cfg, p.config) {\n\t\t\t\tp.subs = append(p.subs, setName)\n\t\t\t\tadded = true\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\td, err := newDiscoverer()\n\t\tif err != nil {\n\t\t\tlevel.Error(m.logger).Log(\"msg\", \"Cannot create service discovery\", \"err\", err, \"type\", t)\n\t\t\tfailedCount++\n\t\t\treturn\n\t\t}\n\n\t\tprovider := provider{\n\t\t\tname:   fmt.Sprintf(\"%s/%d\", t, len(m.providers)),\n\t\t\td:      d,\n\t\t\tconfig: cfg,\n\t\t\tsubs:   []string{setName},\n\t\t}\n\t\tm.providers = append(m.providers, &provider)\n\t\tadded = true\n\t}\n// 支持多种方式的配置 具体可以看代码的discovery/manager.go 356-417行\n```\n\n2. 然后为每个Provider生成两个协程去进行服务发现的功能。 \n```\n\t// discovery/manager.go line 223-226\n\tfunc (m *Manager) startProvider(ctx context.Context, p *provider) {\n\t\tlevel.Debug(m.logger).Log(\"msg\", \"Starting provider\", \"provider\", p.name, \"subs\", fmt.Sprintf(\"%v\", p.subs))\n\t\tctx, cancel := context.WithCancel(ctx)\n\t\t// 此处Update是执行协程与主协程的交流通道，传输Watch的变动\n\t\tupdates := make(chan []*targetgroup.Group)\n\t\tm.discoverCancel = append(m.discoverCancel, cancel)\n\n\t\t//  执行服务发现的Watch\n\t\tgo p.d.Run(ctx, updates)\n\t\t// 把每个协程生成的updates放入到Manager中，使得子协程中发现到服务的变动的时候可以通知到主协程\n\t\tgo m.updater(ctx, p, updates)\n\t}\n\n\t// discovery/manager.go line 205-207\n\tfor _, prov := range m.providers {\n\t\t\tm.startProvider(m.ctx, prov)\n\t}\n```\n\nApplyConfig完成后，Run方法如下\n```\n\tfunc (m *Manager) Run() error {\n\t\tgo m.sender()\n\t\tfor range m.ctx.Done() {\n\t\t\tm.cancelDiscoverers()\n\t\t\treturn m.ctx.Err()\n\t\t}\n\t\treturn nil\n\t}\n```\n\nManager会派生多一个协程去定时检查配置的变动，本质上是检查上面派生的updater协程时候有传入信号到triggerchan中,主协程就是为了防止泄露一直去遍历context的是否done，保持主协程阻塞，维持这个模块的运行。我们主要看一下Manager.Updater()和Manager.Sender()这两个函数。\n\n此处 Manager.trigglechan is 长度为1的buffered channel。updates := make(chan []*targetgroup.Group), 是unbuffered channel \n```\n\tfunc (m *Manager) updater(ctx context.Context, p *provider, updates chan []*targetgroup.Group) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase tgs, ok := <-updates:\n\t\t\t\treceivedUpdates.WithLabelValues(m.name).Inc()\n\t\t\t\tif !ok {\n\t\t\t\t\tlevel.Debug(m.logger).Log(\"msg\", \"discoverer channel closed\", \"provider\", p.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tfor _, s := range p.subs {\n\t\t\t\t\tm.updateGroup(poolKey{setName: s, provider: p.name}, tgs)\n\t\t\t\t}\n\n\t\t\t\tselect {\n\t\t\t\tcase m.triggerSend <- struct{}{}:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunc (m *Manager) sender() {\n\t\tticker := time.NewTicker(m.updatert)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-m.ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-ticker.C: // Some discoverers send updates too often so we throttle these with the ticker.\n\t\t\t\tselect {\n\t\t\t\tcase <-m.triggerSend:\n\t\t\t\t\tsentUpdates.WithLabelValues(m.name).Inc()\n\t\t\t\t\tselect {\n\t\t\t\t\tcase m.syncCh <- m.allGroups():\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tdelayedUpdates.WithLabelValues(m.name).Inc()\n\t\t\t\t\t\tlevel.Debug(m.logger).Log(\"msg\", \"discovery receiver's channel was full so will retry the next cycle\")\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase m.triggerSend <- struct{}{}:\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n\n步骤\n1. Provider 传入变化了的update到update channel中\n2. Manager.Updater协程收集到了变化的内容后，修改Manager里面Group的内容。塞入信号到triggerSend channel中\n3. Manager.Sender协程定时去进行获取通知，检查到triggerSend Channel中可以获取之后，就会尝试塞到syncCh中，使得订阅者可以收到这个消息。(即Main里面的两个放入syncCh方法的ScrapeManager和NotiferManager可以收到)\n\n然后整个的流程就是这样\n\n## 派生协程的逻辑  \n### Provider协程的逻辑  \n```\ntype Discoverer interface {\n\t// Run hands a channel to the discovery provider (Consul, DNS etc) through which it can send\n\t// updated target groups.\n\t// Must returns if the context gets canceled. It should not close the update\n\t// channel on returning.\n\tRun(ctx context.Context, up chan<- []*targetgroup.Group)\n}\n```\nProvider协程主要时根据具体注入的配置来生成出与对应的系统进行服务发现的能力。每个Provider中的Discoverer都实现了自己对应的Run方法即上面p.d.Run()的方法。（如何生成上面已经描述，此处不再复述）\n\n下面我们简单的看一下其中两个Provider，基于配置文件的Provider和基于zookeeper的Provider来看看具体的流程是怎样处理的。\n对于Provider，我们可以理解为一个watch&notify的模型，但是是基于不同平台给予的Api继续watch&notify的操作。\n\n#### FileProvider执行\n\nFileProvider支持解析json和yaml的格式内容  \n```\n// discovery/file/file.go line 39-46\nvar (\n\tpatFileSDName = regexp.MustCompile(`^[^*]*(\\*[^/]*)?\\.(json|yml|yaml|JSON|YML|YAML)$`)\n\n\t// DefaultSDConfig is the default file SD configuration.\n\tDefaultSDConfig = SDConfig{\n\t\tRefreshInterval: model.Duration(5 * time.Minute),\n\t}\n)\n```\n\n下面我们看看主要实现Discoverer的Run方法的逻辑\n```\nfunc (d *Discovery) Run(ctx context.Context, ch chan<- []*targetgroup.Group) {\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlevel.Error(d.logger).Log(\"msg\", \"Error adding file watcher\", \"err\", err)\n\t\treturn\n\t}\n\td.watcher = watcher\n\tdefer d.stop()\n\n    //  协程内第一次执行把conf添加到discoverer中\n\td.refresh(ctx, ch)\n\n\tticker := time.NewTicker(d.interval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\n\t\tcase event := <-d.watcher.Events:\n\t\t\t// fsnotify sometimes sends a bunch of events without name or operation.\n\t\t\t// It's unclear what they are and why they are sent - filter them out.\n\t\t\tif len(event.Name) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Everything but a chmod requires rereading.\n\t\t\tif event.Op^fsnotify.Chmod == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Changes to a file can spawn various sequences of events with\n\t\t\t// different combinations of operations. For all practical purposes\n\t\t\t// this is inaccurate.\n\t\t\t// The most reliable solution is to reload everything if anything happens.\n\t\t\td.refresh(ctx, ch)\n\n\t\tcase <-ticker.C:\n\t\t\t// Setting a new watch after an update might fail. Make sure we don't lose\n\t\t\t// those files forever.\n\t\t\td.refresh(ctx, ch)\n\n\t\tcase err := <-d.watcher.Errors:\n\t\t\tif err != nil {\n\t\t\t\tlevel.Error(d.logger).Log(\"msg\", \"Error watching file\", \"err\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n上面的死循环可以看出，对于File Discoverer， 它支持两种的Watch的方式，一个是定时监控(ticker.C)，一个是事件触发监控（event := <-d.watcher.Events)。\n\n所以重点是在于Refresh函数，本质上就是一个重新解析并且检查文件内容是否有变动的函数，解析完文件之后就可以传出配置到对应的update channel中。\n```\nfunc (d *Discovery) refresh(ctx context.Context, ch chan<- []*targetgroup.Group) {\n\tt0 := time.Now()\n\tdefer func() {\n\t\tfileSDScanDuration.Observe(time.Since(t0).Seconds())\n\t}()\n\tref := map[string]int{}\n\t// 把初始化传入的配置的路径进行检查\n\tfor _, p := range d.listFiles() {\n\t\t//  把单个文件进行解析，获取出里面的targets\n\t\ttgroups, err := d.readFile(p)\n\t\tif err != nil {\n\t\t\tfileSDReadErrorsCount.Inc()\n\n\t\t\tlevel.Error(d.logger).Log(\"msg\", \"Error reading file\", \"path\", p, \"err\", err)\n\t\t\t// Prevent deletion down below.\n\t\t\tref[p] = d.lastRefresh[p]\n\t\t\tcontinue\n\t\t}\n\t\tselect {\n\t\t\t// 把新传入的传入到Update中\n\t\tcase ch <- tgroups:\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\n\t\tref[p] = len(tgroups)\n\t}\n\t// Send empty updates for sources that disappeared.\n\tfor f, n := range d.lastRefresh {\n\t\tm, ok := ref[f]\n\t\tif !ok || n > m {\n\t\t\tlevel.Debug(d.logger).Log(\"msg\", \"file_sd refresh found file that should be removed\", \"file\", f)\n\t\t\td.deleteTimestamp(f)\n\t\t\tfor i := m; i < n; i++ {\n\t\t\t\tselect {\n\t\t\t\tcase ch <- []*targetgroup.Group{{Source: fileSource(f, i)}}:\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\td.lastRefresh = ref\n\n\td.watchFiles()\n}\n```\n\n#### zookeeperProvider执行\n\nZookeeper的Provider与上面的模式类似，差别在于：\n1. 初始化的时候需要创建zookeeper的链接（配置中需要传入配置好zookeeper相关的配置）\n2. 分为了ServerSetPoint和NerveEndPoint两个类型的Discovery，因此抽象了一个Discovery的结构体\n3. 没有了定时检查（因为不存在文件系统问题的）这种检查的方式\n\n```\n\ttype Discovery struct {\n\t\tconn *zk.Conn\n\n\t\tsources map[string]*targetgroup.Group\n\n\t\tupdates     chan treecache.ZookeeperTreeCacheEvent\n\t\tpathUpdates []chan treecache.ZookeeperTreeCacheEvent\n\t\ttreeCaches  []*treecache.ZookeeperTreeCache\n\n\t\tparse  func(data []byte, path string) (model.LabelSet, error)\n\t\tlogger log.Logger\n\t}\n\n\tfunc (d *Discovery) Run(ctx context.Context, ch chan<- []*targetgroup.Group) {\n\t\tdefer func() {\n\t\t\tfor _, tc := range d.treeCaches {\n\t\t\t\ttc.Stop()\n\t\t\t}\n\t\t\tfor _, pathUpdate := range d.pathUpdates {\n\t\t\t\t// Drain event channel in case the treecache leaks goroutines otherwise.\n\t\t\t\tfor range pathUpdate {\n\t\t\t\t}\n\t\t\t}\n\t\t\td.conn.Close()\n\t\t}()\n\n\t\tfor _, pathUpdate := range d.pathUpdates {\n\t\t\tgo func(update chan treecache.ZookeeperTreeCacheEvent) {\n\t\t\t\tfor event := range update {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase d.updates <- event:\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(pathUpdate)\n\t\t}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase event := <-d.updates:\n\t\t\t\ttg := &targetgroup.Group{\n\t\t\t\t\tSource: event.Path,\n\t\t\t\t}\n\t\t\t\tif event.Data != nil {\n\t\t\t\t\tlabelSet, err := d.parse(*event.Data, event.Path)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\ttg.Targets = []model.LabelSet{labelSet}\n\t\t\t\t\t\td.sources[event.Path] = tg\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete(d.sources, event.Path)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdelete(d.sources, event.Path)\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase ch <- []*targetgroup.Group{tg}:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n\nRun的流程\n1. 给每一个需要检查的路径派生一个协程\n2. 死循环获取是否有更新\n3. 如果有，则使用传入的parse函数去进行解析，然后把结果发送到update的channel中，即ch变量中","source":"_posts/prometheus-service-discovery.md","raw":"---\ntitle:  Prometheus服务发现源码阅读\ndate: 2019-10-05 20:51:38\ntags: Prometheus\n---\n\n\n<!-- ---\nlayout: post\ntitle: Prometheus服务发现源码阅读\nauthor: Ray Chan(ray1888)\ndate: '2019-10-05 20:51:38 +0800'\ncategory: Prometheus\nsummary: Prometheus Service Discovery Module\nthumbnail: Prometheus.png\n--- -->\n\n# 目录\n1. 使用的目的  \n2. 代码实现  \n   2.1 主协程逻辑  \n   2.2 子协程逻辑\n\n# 代码版本\n\n基于 prometheus项目的master branch的5a554df0855bf707a8c333c0dd830067d03422cf commit\n\n# 使用目的\n服务发现是Prometheus中最重要的功能之一，因为它是支撑Prometheus可以在容器的环境下的最重要的功能。因为应用的容器部署的弹性和有效的时长远与传统的基于服务器（无论是实体机还是虚拟机[OpenStack]这一类的机器）部署， 都会变动的更加快。因此为了适应这种弹性大、变化快的环境，它需要基于不同平台来支持服务发现这个功能。\n\nPrometheus的服务发现模块是在prometheus/discovery的目录下面，它在Prometheus中的体系支撑了采集器的发现和AlertManager的发现。\n可以看下面的代码。\n\n```\n//  此代码在cmd/main.go中的 350-352行\n\tctxScrape, cancelScrape = context.WithCancel(context.Background())\n\tdiscoveryManagerScrape  = discovery.NewManager(ctxScrape, log.With(logger, \"component\", \"discovery manager scrape\"), discovery.Name(\"scrape\"))\n\n\tctxNotify, cancelNotify = context.WithCancel(context.Background())\n\tdiscoveryManagerNotify  = discovery.NewManager(ctxNotify, log.With(logger, \"component\", \"discovery manager notify\"), discovery.Name(\"notify\"))\n\n//  具体注入到两个功能的使用\n/* \n\tcmd/main.go line 555, 把Manager的输出的信道传递给scrapeManager，然后后面就会去restore scrape的方式。\n\t后面会有单独文章写Scrape（抓取数据）的部分\n\t*/\nerr := scrapeManager.Run(discoveryManagerScrape.SyncCh())\n\n/* \n\tcmd/main.go line 726, 把Manager的输出的信道传递给notifierManager，然后后面就会去获取更新alertManager组件的方式。\n\t后面会有单独文章写Notifer（抓取数据）的部分\n\t*/\nnotifierManager.Run(discoveryManagerNotify.SyncCh())\n\n// 在main.go line 735, run Group 会执行上面注册在g 里面的这两个discoveryManager的Run方法。\n```\n\n所以整体的代码执行的入口流程\n1. 在main.go实例化两个discoveryManager来进行服务发现的操作\n2. 把注入的discovery config进行解析，并且生成对应的Provider协程\n3. 主协程执行上面两个discoveryManager的Run方法\n\n# 代码实现\n\n## 模块的运行逻辑图\n\n<!-- ![ServiceDiscoveryModule](/assets/img/posts/prometheus/DiscoverManager.png) -->\n{% asset_img DiscoverManager.png ServiceDiscoveryModule %}\n\n## 主协程的逻辑\n1. 先去读取服务发现相关的配置，调用ApplyConfig()读取存在的service discovery的方式，并且加载到NewManager的结构体中。可以同同时支持多个service Discovery的方式。使用add函数把配置变为Providers结构体。\n```\nadd := func(cfg interface{}, newDiscoverer func() (Discoverer, error)) {\n\t\tt := reflect.TypeOf(cfg).String()\n\t\tfor _, p := range m.providers {\n\t\t\tif reflect.DeepEqual(cfg, p.config) {\n\t\t\t\tp.subs = append(p.subs, setName)\n\t\t\t\tadded = true\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\td, err := newDiscoverer()\n\t\tif err != nil {\n\t\t\tlevel.Error(m.logger).Log(\"msg\", \"Cannot create service discovery\", \"err\", err, \"type\", t)\n\t\t\tfailedCount++\n\t\t\treturn\n\t\t}\n\n\t\tprovider := provider{\n\t\t\tname:   fmt.Sprintf(\"%s/%d\", t, len(m.providers)),\n\t\t\td:      d,\n\t\t\tconfig: cfg,\n\t\t\tsubs:   []string{setName},\n\t\t}\n\t\tm.providers = append(m.providers, &provider)\n\t\tadded = true\n\t}\n// 支持多种方式的配置 具体可以看代码的discovery/manager.go 356-417行\n```\n\n2. 然后为每个Provider生成两个协程去进行服务发现的功能。 \n```\n\t// discovery/manager.go line 223-226\n\tfunc (m *Manager) startProvider(ctx context.Context, p *provider) {\n\t\tlevel.Debug(m.logger).Log(\"msg\", \"Starting provider\", \"provider\", p.name, \"subs\", fmt.Sprintf(\"%v\", p.subs))\n\t\tctx, cancel := context.WithCancel(ctx)\n\t\t// 此处Update是执行协程与主协程的交流通道，传输Watch的变动\n\t\tupdates := make(chan []*targetgroup.Group)\n\t\tm.discoverCancel = append(m.discoverCancel, cancel)\n\n\t\t//  执行服务发现的Watch\n\t\tgo p.d.Run(ctx, updates)\n\t\t// 把每个协程生成的updates放入到Manager中，使得子协程中发现到服务的变动的时候可以通知到主协程\n\t\tgo m.updater(ctx, p, updates)\n\t}\n\n\t// discovery/manager.go line 205-207\n\tfor _, prov := range m.providers {\n\t\t\tm.startProvider(m.ctx, prov)\n\t}\n```\n\nApplyConfig完成后，Run方法如下\n```\n\tfunc (m *Manager) Run() error {\n\t\tgo m.sender()\n\t\tfor range m.ctx.Done() {\n\t\t\tm.cancelDiscoverers()\n\t\t\treturn m.ctx.Err()\n\t\t}\n\t\treturn nil\n\t}\n```\n\nManager会派生多一个协程去定时检查配置的变动，本质上是检查上面派生的updater协程时候有传入信号到triggerchan中,主协程就是为了防止泄露一直去遍历context的是否done，保持主协程阻塞，维持这个模块的运行。我们主要看一下Manager.Updater()和Manager.Sender()这两个函数。\n\n此处 Manager.trigglechan is 长度为1的buffered channel。updates := make(chan []*targetgroup.Group), 是unbuffered channel \n```\n\tfunc (m *Manager) updater(ctx context.Context, p *provider, updates chan []*targetgroup.Group) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase tgs, ok := <-updates:\n\t\t\t\treceivedUpdates.WithLabelValues(m.name).Inc()\n\t\t\t\tif !ok {\n\t\t\t\t\tlevel.Debug(m.logger).Log(\"msg\", \"discoverer channel closed\", \"provider\", p.name)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tfor _, s := range p.subs {\n\t\t\t\t\tm.updateGroup(poolKey{setName: s, provider: p.name}, tgs)\n\t\t\t\t}\n\n\t\t\t\tselect {\n\t\t\t\tcase m.triggerSend <- struct{}{}:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunc (m *Manager) sender() {\n\t\tticker := time.NewTicker(m.updatert)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-m.ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-ticker.C: // Some discoverers send updates too often so we throttle these with the ticker.\n\t\t\t\tselect {\n\t\t\t\tcase <-m.triggerSend:\n\t\t\t\t\tsentUpdates.WithLabelValues(m.name).Inc()\n\t\t\t\t\tselect {\n\t\t\t\t\tcase m.syncCh <- m.allGroups():\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tdelayedUpdates.WithLabelValues(m.name).Inc()\n\t\t\t\t\t\tlevel.Debug(m.logger).Log(\"msg\", \"discovery receiver's channel was full so will retry the next cycle\")\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase m.triggerSend <- struct{}{}:\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n\n步骤\n1. Provider 传入变化了的update到update channel中\n2. Manager.Updater协程收集到了变化的内容后，修改Manager里面Group的内容。塞入信号到triggerSend channel中\n3. Manager.Sender协程定时去进行获取通知，检查到triggerSend Channel中可以获取之后，就会尝试塞到syncCh中，使得订阅者可以收到这个消息。(即Main里面的两个放入syncCh方法的ScrapeManager和NotiferManager可以收到)\n\n然后整个的流程就是这样\n\n## 派生协程的逻辑  \n### Provider协程的逻辑  \n```\ntype Discoverer interface {\n\t// Run hands a channel to the discovery provider (Consul, DNS etc) through which it can send\n\t// updated target groups.\n\t// Must returns if the context gets canceled. It should not close the update\n\t// channel on returning.\n\tRun(ctx context.Context, up chan<- []*targetgroup.Group)\n}\n```\nProvider协程主要时根据具体注入的配置来生成出与对应的系统进行服务发现的能力。每个Provider中的Discoverer都实现了自己对应的Run方法即上面p.d.Run()的方法。（如何生成上面已经描述，此处不再复述）\n\n下面我们简单的看一下其中两个Provider，基于配置文件的Provider和基于zookeeper的Provider来看看具体的流程是怎样处理的。\n对于Provider，我们可以理解为一个watch&notify的模型，但是是基于不同平台给予的Api继续watch&notify的操作。\n\n#### FileProvider执行\n\nFileProvider支持解析json和yaml的格式内容  \n```\n// discovery/file/file.go line 39-46\nvar (\n\tpatFileSDName = regexp.MustCompile(`^[^*]*(\\*[^/]*)?\\.(json|yml|yaml|JSON|YML|YAML)$`)\n\n\t// DefaultSDConfig is the default file SD configuration.\n\tDefaultSDConfig = SDConfig{\n\t\tRefreshInterval: model.Duration(5 * time.Minute),\n\t}\n)\n```\n\n下面我们看看主要实现Discoverer的Run方法的逻辑\n```\nfunc (d *Discovery) Run(ctx context.Context, ch chan<- []*targetgroup.Group) {\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlevel.Error(d.logger).Log(\"msg\", \"Error adding file watcher\", \"err\", err)\n\t\treturn\n\t}\n\td.watcher = watcher\n\tdefer d.stop()\n\n    //  协程内第一次执行把conf添加到discoverer中\n\td.refresh(ctx, ch)\n\n\tticker := time.NewTicker(d.interval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\n\t\tcase event := <-d.watcher.Events:\n\t\t\t// fsnotify sometimes sends a bunch of events without name or operation.\n\t\t\t// It's unclear what they are and why they are sent - filter them out.\n\t\t\tif len(event.Name) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Everything but a chmod requires rereading.\n\t\t\tif event.Op^fsnotify.Chmod == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Changes to a file can spawn various sequences of events with\n\t\t\t// different combinations of operations. For all practical purposes\n\t\t\t// this is inaccurate.\n\t\t\t// The most reliable solution is to reload everything if anything happens.\n\t\t\td.refresh(ctx, ch)\n\n\t\tcase <-ticker.C:\n\t\t\t// Setting a new watch after an update might fail. Make sure we don't lose\n\t\t\t// those files forever.\n\t\t\td.refresh(ctx, ch)\n\n\t\tcase err := <-d.watcher.Errors:\n\t\t\tif err != nil {\n\t\t\t\tlevel.Error(d.logger).Log(\"msg\", \"Error watching file\", \"err\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n上面的死循环可以看出，对于File Discoverer， 它支持两种的Watch的方式，一个是定时监控(ticker.C)，一个是事件触发监控（event := <-d.watcher.Events)。\n\n所以重点是在于Refresh函数，本质上就是一个重新解析并且检查文件内容是否有变动的函数，解析完文件之后就可以传出配置到对应的update channel中。\n```\nfunc (d *Discovery) refresh(ctx context.Context, ch chan<- []*targetgroup.Group) {\n\tt0 := time.Now()\n\tdefer func() {\n\t\tfileSDScanDuration.Observe(time.Since(t0).Seconds())\n\t}()\n\tref := map[string]int{}\n\t// 把初始化传入的配置的路径进行检查\n\tfor _, p := range d.listFiles() {\n\t\t//  把单个文件进行解析，获取出里面的targets\n\t\ttgroups, err := d.readFile(p)\n\t\tif err != nil {\n\t\t\tfileSDReadErrorsCount.Inc()\n\n\t\t\tlevel.Error(d.logger).Log(\"msg\", \"Error reading file\", \"path\", p, \"err\", err)\n\t\t\t// Prevent deletion down below.\n\t\t\tref[p] = d.lastRefresh[p]\n\t\t\tcontinue\n\t\t}\n\t\tselect {\n\t\t\t// 把新传入的传入到Update中\n\t\tcase ch <- tgroups:\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\n\t\tref[p] = len(tgroups)\n\t}\n\t// Send empty updates for sources that disappeared.\n\tfor f, n := range d.lastRefresh {\n\t\tm, ok := ref[f]\n\t\tif !ok || n > m {\n\t\t\tlevel.Debug(d.logger).Log(\"msg\", \"file_sd refresh found file that should be removed\", \"file\", f)\n\t\t\td.deleteTimestamp(f)\n\t\t\tfor i := m; i < n; i++ {\n\t\t\t\tselect {\n\t\t\t\tcase ch <- []*targetgroup.Group{{Source: fileSource(f, i)}}:\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\td.lastRefresh = ref\n\n\td.watchFiles()\n}\n```\n\n#### zookeeperProvider执行\n\nZookeeper的Provider与上面的模式类似，差别在于：\n1. 初始化的时候需要创建zookeeper的链接（配置中需要传入配置好zookeeper相关的配置）\n2. 分为了ServerSetPoint和NerveEndPoint两个类型的Discovery，因此抽象了一个Discovery的结构体\n3. 没有了定时检查（因为不存在文件系统问题的）这种检查的方式\n\n```\n\ttype Discovery struct {\n\t\tconn *zk.Conn\n\n\t\tsources map[string]*targetgroup.Group\n\n\t\tupdates     chan treecache.ZookeeperTreeCacheEvent\n\t\tpathUpdates []chan treecache.ZookeeperTreeCacheEvent\n\t\ttreeCaches  []*treecache.ZookeeperTreeCache\n\n\t\tparse  func(data []byte, path string) (model.LabelSet, error)\n\t\tlogger log.Logger\n\t}\n\n\tfunc (d *Discovery) Run(ctx context.Context, ch chan<- []*targetgroup.Group) {\n\t\tdefer func() {\n\t\t\tfor _, tc := range d.treeCaches {\n\t\t\t\ttc.Stop()\n\t\t\t}\n\t\t\tfor _, pathUpdate := range d.pathUpdates {\n\t\t\t\t// Drain event channel in case the treecache leaks goroutines otherwise.\n\t\t\t\tfor range pathUpdate {\n\t\t\t\t}\n\t\t\t}\n\t\t\td.conn.Close()\n\t\t}()\n\n\t\tfor _, pathUpdate := range d.pathUpdates {\n\t\t\tgo func(update chan treecache.ZookeeperTreeCacheEvent) {\n\t\t\t\tfor event := range update {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase d.updates <- event:\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(pathUpdate)\n\t\t}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase event := <-d.updates:\n\t\t\t\ttg := &targetgroup.Group{\n\t\t\t\t\tSource: event.Path,\n\t\t\t\t}\n\t\t\t\tif event.Data != nil {\n\t\t\t\t\tlabelSet, err := d.parse(*event.Data, event.Path)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\ttg.Targets = []model.LabelSet{labelSet}\n\t\t\t\t\t\td.sources[event.Path] = tg\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete(d.sources, event.Path)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdelete(d.sources, event.Path)\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase ch <- []*targetgroup.Group{tg}:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n\nRun的流程\n1. 给每一个需要检查的路径派生一个协程\n2. 死循环获取是否有更新\n3. 如果有，则使用传入的parse函数去进行解析，然后把结果发送到update的channel中，即ch变量中","slug":"prometheus-service-discovery","published":1,"updated":"2021-01-21T07:10:15.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6irard0007k9i54bt9hz6n","content":"<!-- ---\nlayout: post\ntitle: Prometheus服务发现源码阅读\nauthor: Ray Chan(ray1888)\ndate: '2019-10-05 20:51:38 +0800'\ncategory: Prometheus\nsummary: Prometheus Service Discovery Module\nthumbnail: Prometheus.png\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li>使用的目的  </li>\n<li>代码实现<br>2.1 主协程逻辑<br>2.2 子协程逻辑</li>\n</ol>\n\n        <h1 id=\"代码版本\"   >\n          <a href=\"#代码版本\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码版本</h1>\n      <p>基于 prometheus项目的master branch的5a554df0855bf707a8c333c0dd830067d03422cf commit</p>\n\n        <h1 id=\"使用目的\"   >\n          <a href=\"#使用目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用目的</h1>\n      <p>服务发现是Prometheus中最重要的功能之一，因为它是支撑Prometheus可以在容器的环境下的最重要的功能。因为应用的容器部署的弹性和有效的时长远与传统的基于服务器（无论是实体机还是虚拟机[OpenStack]这一类的机器）部署， 都会变动的更加快。因此为了适应这种弹性大、变化快的环境，它需要基于不同平台来支持服务发现这个功能。</p>\n<p>Prometheus的服务发现模块是在prometheus/discovery的目录下面，它在Prometheus中的体系支撑了采集器的发现和AlertManager的发现。<br>可以看下面的代码。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;  此代码在cmd&#x2F;main.go中的 350-352行</span><br><span class=\"line\">\tctxScrape, cancelScrape &#x3D; context.WithCancel(context.Background())</span><br><span class=\"line\">\tdiscoveryManagerScrape  &#x3D; discovery.NewManager(ctxScrape, log.With(logger, &quot;component&quot;, &quot;discovery manager scrape&quot;), discovery.Name(&quot;scrape&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">\tctxNotify, cancelNotify &#x3D; context.WithCancel(context.Background())</span><br><span class=\"line\">\tdiscoveryManagerNotify  &#x3D; discovery.NewManager(ctxNotify, log.With(logger, &quot;component&quot;, &quot;discovery manager notify&quot;), discovery.Name(&quot;notify&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;  具体注入到两个功能的使用</span><br><span class=\"line\">&#x2F;* </span><br><span class=\"line\">\tcmd&#x2F;main.go line 555, 把Manager的输出的信道传递给scrapeManager，然后后面就会去restore scrape的方式。</span><br><span class=\"line\">\t后面会有单独文章写Scrape（抓取数据）的部分</span><br><span class=\"line\">\t*&#x2F;</span><br><span class=\"line\">err :&#x3D; scrapeManager.Run(discoveryManagerScrape.SyncCh())</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;* </span><br><span class=\"line\">\tcmd&#x2F;main.go line 726, 把Manager的输出的信道传递给notifierManager，然后后面就会去获取更新alertManager组件的方式。</span><br><span class=\"line\">\t后面会有单独文章写Notifer（抓取数据）的部分</span><br><span class=\"line\">\t*&#x2F;</span><br><span class=\"line\">notifierManager.Run(discoveryManagerNotify.SyncCh())</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 在main.go line 735, run Group 会执行上面注册在g 里面的这两个discoveryManager的Run方法。</span><br></pre></td></tr></table></div></figure>\n<p>所以整体的代码执行的入口流程</p>\n<ol>\n<li>在main.go实例化两个discoveryManager来进行服务发现的操作</li>\n<li>把注入的discovery config进行解析，并且生成对应的Provider协程</li>\n<li>主协程执行上面两个discoveryManager的Run方法</li>\n</ol>\n\n        <h1 id=\"代码实现\"   >\n          <a href=\"#代码实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码实现</h1>\n      \n        <h2 id=\"模块的运行逻辑图\"   >\n          <a href=\"#模块的运行逻辑图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>模块的运行逻辑图</h2>\n      <!-- ![ServiceDiscoveryModule](/assets/img/posts/prometheus/DiscoverManager.png) -->\n\n\n\n        <h2 id=\"主协程的逻辑\"   >\n          <a href=\"#主协程的逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>主协程的逻辑</h2>\n      <ol>\n<li>先去读取服务发现相关的配置，调用ApplyConfig()读取存在的service discovery的方式，并且加载到NewManager的结构体中。可以同同时支持多个service Discovery的方式。使用add函数把配置变为Providers结构体。<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add :&#x3D; func(cfg interface&#123;&#125;, newDiscoverer func() (Discoverer, error)) &#123;</span><br><span class=\"line\">\t\tt :&#x3D; reflect.TypeOf(cfg).String()</span><br><span class=\"line\">\t\tfor _, p :&#x3D; range m.providers &#123;</span><br><span class=\"line\">\t\t\tif reflect.DeepEqual(cfg, p.config) &#123;</span><br><span class=\"line\">\t\t\t\tp.subs &#x3D; append(p.subs, setName)</span><br><span class=\"line\">\t\t\t\tadded &#x3D; true</span><br><span class=\"line\">\t\t\t\treturn</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\td, err :&#x3D; newDiscoverer()</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tlevel.Error(m.logger).Log(&quot;msg&quot;, &quot;Cannot create service discovery&quot;, &quot;err&quot;, err, &quot;type&quot;, t)</span><br><span class=\"line\">\t\t\tfailedCount++</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprovider :&#x3D; provider&#123;</span><br><span class=\"line\">\t\t\tname:   fmt.Sprintf(&quot;%s&#x2F;%d&quot;, t, len(m.providers)),</span><br><span class=\"line\">\t\t\td:      d,</span><br><span class=\"line\">\t\t\tconfig: cfg,</span><br><span class=\"line\">\t\t\tsubs:   []string&#123;setName&#125;,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tm.providers &#x3D; append(m.providers, &amp;provider)</span><br><span class=\"line\">\t\tadded &#x3D; true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 支持多种方式的配置 具体可以看代码的discovery&#x2F;manager.go 356-417行</span><br></pre></td></tr></table></div></figure></li>\n<li>然后为每个Provider生成两个协程去进行服务发现的功能。 <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; discovery&#x2F;manager.go line 223-226</span><br><span class=\"line\">func (m *Manager) startProvider(ctx context.Context, p *provider) &#123;</span><br><span class=\"line\">\tlevel.Debug(m.logger).Log(&quot;msg&quot;, &quot;Starting provider&quot;, &quot;provider&quot;, p.name, &quot;subs&quot;, fmt.Sprintf(&quot;%v&quot;, p.subs))</span><br><span class=\"line\">\tctx, cancel :&#x3D; context.WithCancel(ctx)</span><br><span class=\"line\">\t&#x2F;&#x2F; 此处Update是执行协程与主协程的交流通道，传输Watch的变动</span><br><span class=\"line\">\tupdates :&#x3D; make(chan []*targetgroup.Group)</span><br><span class=\"line\">\tm.discoverCancel &#x3D; append(m.discoverCancel, cancel)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;  执行服务发现的Watch</span><br><span class=\"line\">\tgo p.d.Run(ctx, updates)</span><br><span class=\"line\">\t&#x2F;&#x2F; 把每个协程生成的updates放入到Manager中，使得子协程中发现到服务的变动的时候可以通知到主协程</span><br><span class=\"line\">\tgo m.updater(ctx, p, updates)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; discovery&#x2F;manager.go line 205-207</span><br><span class=\"line\">for _, prov :&#x3D; range m.providers &#123;</span><br><span class=\"line\">\t\tm.startProvider(m.ctx, prov)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\nApplyConfig完成后，Run方法如下<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (m *Manager) Run() error &#123;</span><br><span class=\"line\">\tgo m.sender()</span><br><span class=\"line\">\tfor range m.ctx.Done() &#123;</span><br><span class=\"line\">\t\tm.cancelDiscoverers()</span><br><span class=\"line\">\t\treturn m.ctx.Err()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\nManager会派生多一个协程去定时检查配置的变动，本质上是检查上面派生的updater协程时候有传入信号到triggerchan中,主协程就是为了防止泄露一直去遍历context的是否done，保持主协程阻塞，维持这个模块的运行。我们主要看一下Manager.Updater()和Manager.Sender()这两个函数。</li>\n</ol>\n<p>此处 Manager.trigglechan is 长度为1的buffered channel。updates := make(chan []*targetgroup.Group), 是unbuffered channel </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (m *Manager) updater(ctx context.Context, p *provider, updates chan []*targetgroup.Group) &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase tgs, ok :&#x3D; &lt;-updates:</span><br><span class=\"line\">\t\t\treceivedUpdates.WithLabelValues(m.name).Inc()</span><br><span class=\"line\">\t\t\tif !ok &#123;</span><br><span class=\"line\">\t\t\t\tlevel.Debug(m.logger).Log(&quot;msg&quot;, &quot;discoverer channel closed&quot;, &quot;provider&quot;, p.name)</span><br><span class=\"line\">\t\t\t\treturn</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfor _, s :&#x3D; range p.subs &#123;</span><br><span class=\"line\">\t\t\t\tm.updateGroup(poolKey&#123;setName: s, provider: p.name&#125;, tgs)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\tcase m.triggerSend &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (m *Manager) sender() &#123;</span><br><span class=\"line\">\tticker :&#x3D; time.NewTicker(m.updatert)</span><br><span class=\"line\">\tdefer ticker.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-m.ctx.Done():</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase &lt;-ticker.C: &#x2F;&#x2F; Some discoverers send updates too often so we throttle these with the ticker.</span><br><span class=\"line\">\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\tcase &lt;-m.triggerSend:</span><br><span class=\"line\">\t\t\t\tsentUpdates.WithLabelValues(m.name).Inc()</span><br><span class=\"line\">\t\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\t\tcase m.syncCh &lt;- m.allGroups():</span><br><span class=\"line\">\t\t\t\tdefault:</span><br><span class=\"line\">\t\t\t\t\tdelayedUpdates.WithLabelValues(m.name).Inc()</span><br><span class=\"line\">\t\t\t\t\tlevel.Debug(m.logger).Log(&quot;msg&quot;, &quot;discovery receiver&#39;s channel was full so will retry the next cycle&quot;)</span><br><span class=\"line\">\t\t\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\t\t\tcase m.triggerSend &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class=\"line\">\t\t\t\t\tdefault:</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>步骤</p>\n<ol>\n<li>Provider 传入变化了的update到update channel中</li>\n<li>Manager.Updater协程收集到了变化的内容后，修改Manager里面Group的内容。塞入信号到triggerSend channel中</li>\n<li>Manager.Sender协程定时去进行获取通知，检查到triggerSend Channel中可以获取之后，就会尝试塞到syncCh中，使得订阅者可以收到这个消息。(即Main里面的两个放入syncCh方法的ScrapeManager和NotiferManager可以收到)</li>\n</ol>\n<p>然后整个的流程就是这样</p>\n\n        <h2 id=\"派生协程的逻辑\"   >\n          <a href=\"#派生协程的逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>派生协程的逻辑</h2>\n      \n        <h3 id=\"Provider协程的逻辑\"   >\n          <a href=\"#Provider协程的逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Provider协程的逻辑</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Discoverer interface &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; Run hands a channel to the discovery provider (Consul, DNS etc) through which it can send</span><br><span class=\"line\">\t&#x2F;&#x2F; updated target groups.</span><br><span class=\"line\">\t&#x2F;&#x2F; Must returns if the context gets canceled. It should not close the update</span><br><span class=\"line\">\t&#x2F;&#x2F; channel on returning.</span><br><span class=\"line\">\tRun(ctx context.Context, up chan&lt;- []*targetgroup.Group)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Provider协程主要时根据具体注入的配置来生成出与对应的系统进行服务发现的能力。每个Provider中的Discoverer都实现了自己对应的Run方法即上面p.d.Run()的方法。（如何生成上面已经描述，此处不再复述）</p>\n<p>下面我们简单的看一下其中两个Provider，基于配置文件的Provider和基于zookeeper的Provider来看看具体的流程是怎样处理的。<br>对于Provider，我们可以理解为一个watch&amp;notify的模型，但是是基于不同平台给予的Api继续watch&amp;notify的操作。</p>\n\n        <h4 id=\"FileProvider执行\"   >\n          <a href=\"#FileProvider执行\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>FileProvider执行</h4>\n      <p>FileProvider支持解析json和yaml的格式内容  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; discovery&#x2F;file&#x2F;file.go line 39-46</span><br><span class=\"line\">var (</span><br><span class=\"line\">\tpatFileSDName &#x3D; regexp.MustCompile(&#96;^[^*]*(\\*[^&#x2F;]*)?\\.(json|yml|yaml|JSON|YML|YAML)$&#96;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; DefaultSDConfig is the default file SD configuration.</span><br><span class=\"line\">\tDefaultSDConfig &#x3D; SDConfig&#123;</span><br><span class=\"line\">\t\tRefreshInterval: model.Duration(5 * time.Minute),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n<p>下面我们看看主要实现Discoverer的Run方法的逻辑</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (d *Discovery) Run(ctx context.Context, ch chan&lt;- []*targetgroup.Group) &#123;</span><br><span class=\"line\">\twatcher, err :&#x3D; fsnotify.NewWatcher()</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tlevel.Error(d.logger).Log(&quot;msg&quot;, &quot;Error adding file watcher&quot;, &quot;err&quot;, err)</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\td.watcher &#x3D; watcher</span><br><span class=\"line\">\tdefer d.stop()</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;  协程内第一次执行把conf添加到discoverer中</span><br><span class=\"line\">\td.refresh(ctx, ch)</span><br><span class=\"line\"></span><br><span class=\"line\">\tticker :&#x3D; time.NewTicker(d.interval)</span><br><span class=\"line\">\tdefer ticker.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcase event :&#x3D; &lt;-d.watcher.Events:</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; fsnotify sometimes sends a bunch of events without name or operation.</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; It&#39;s unclear what they are and why they are sent - filter them out.</span><br><span class=\"line\">\t\t\tif len(event.Name) &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Everything but a chmod requires rereading.</span><br><span class=\"line\">\t\t\tif event.Op^fsnotify.Chmod &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Changes to a file can spawn various sequences of events with</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; different combinations of operations. For all practical purposes</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; this is inaccurate.</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; The most reliable solution is to reload everything if anything happens.</span><br><span class=\"line\">\t\t\td.refresh(ctx, ch)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcase &lt;-ticker.C:</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Setting a new watch after an update might fail. Make sure we don&#39;t lose</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; those files forever.</span><br><span class=\"line\">\t\t\td.refresh(ctx, ch)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcase err :&#x3D; &lt;-d.watcher.Errors:</span><br><span class=\"line\">\t\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\tlevel.Error(d.logger).Log(&quot;msg&quot;, &quot;Error watching file&quot;, &quot;err&quot;, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>上面的死循环可以看出，对于File Discoverer， 它支持两种的Watch的方式，一个是定时监控(ticker.C)，一个是事件触发监控（event := &lt;-d.watcher.Events)。</p>\n<p>所以重点是在于Refresh函数，本质上就是一个重新解析并且检查文件内容是否有变动的函数，解析完文件之后就可以传出配置到对应的update channel中。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (d *Discovery) refresh(ctx context.Context, ch chan&lt;- []*targetgroup.Group) &#123;</span><br><span class=\"line\">\tt0 :&#x3D; time.Now()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tfileSDScanDuration.Observe(time.Since(t0).Seconds())</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tref :&#x3D; map[string]int&#123;&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 把初始化传入的配置的路径进行检查</span><br><span class=\"line\">\tfor _, p :&#x3D; range d.listFiles() &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;  把单个文件进行解析，获取出里面的targets</span><br><span class=\"line\">\t\ttgroups, err :&#x3D; d.readFile(p)</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tfileSDReadErrorsCount.Inc()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tlevel.Error(d.logger).Log(&quot;msg&quot;, &quot;Error reading file&quot;, &quot;path&quot;, p, &quot;err&quot;, err)</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Prevent deletion down below.</span><br><span class=\"line\">\t\t\tref[p] &#x3D; d.lastRefresh[p]</span><br><span class=\"line\">\t\t\tcontinue</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 把新传入的传入到Update中</span><br><span class=\"line\">\t\tcase ch &lt;- tgroups:</span><br><span class=\"line\">\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tref[p] &#x3D; len(tgroups)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; Send empty updates for sources that disappeared.</span><br><span class=\"line\">\tfor f, n :&#x3D; range d.lastRefresh &#123;</span><br><span class=\"line\">\t\tm, ok :&#x3D; ref[f]</span><br><span class=\"line\">\t\tif !ok || n &gt; m &#123;</span><br><span class=\"line\">\t\t\tlevel.Debug(d.logger).Log(&quot;msg&quot;, &quot;file_sd refresh found file that should be removed&quot;, &quot;file&quot;, f)</span><br><span class=\"line\">\t\t\td.deleteTimestamp(f)</span><br><span class=\"line\">\t\t\tfor i :&#x3D; m; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\t\tcase ch &lt;- []*targetgroup.Group&#123;&#123;Source: fileSource(f, i)&#125;&#125;:</span><br><span class=\"line\">\t\t\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\t\treturn</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\td.lastRefresh &#x3D; ref</span><br><span class=\"line\"></span><br><span class=\"line\">\td.watchFiles()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"zookeeperProvider执行\"   >\n          <a href=\"#zookeeperProvider执行\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>zookeeperProvider执行</h4>\n      <p>Zookeeper的Provider与上面的模式类似，差别在于：</p>\n<ol>\n<li>初始化的时候需要创建zookeeper的链接（配置中需要传入配置好zookeeper相关的配置）</li>\n<li>分为了ServerSetPoint和NerveEndPoint两个类型的Discovery，因此抽象了一个Discovery的结构体</li>\n<li>没有了定时检查（因为不存在文件系统问题的）这种检查的方式</li>\n</ol>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Discovery struct &#123;</span><br><span class=\"line\">\tconn *zk.Conn</span><br><span class=\"line\"></span><br><span class=\"line\">\tsources map[string]*targetgroup.Group</span><br><span class=\"line\"></span><br><span class=\"line\">\tupdates     chan treecache.ZookeeperTreeCacheEvent</span><br><span class=\"line\">\tpathUpdates []chan treecache.ZookeeperTreeCacheEvent</span><br><span class=\"line\">\ttreeCaches  []*treecache.ZookeeperTreeCache</span><br><span class=\"line\"></span><br><span class=\"line\">\tparse  func(data []byte, path string) (model.LabelSet, error)</span><br><span class=\"line\">\tlogger log.Logger</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (d *Discovery) Run(ctx context.Context, ch chan&lt;- []*targetgroup.Group) &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tfor _, tc :&#x3D; range d.treeCaches &#123;</span><br><span class=\"line\">\t\t\ttc.Stop()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor _, pathUpdate :&#x3D; range d.pathUpdates &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Drain event channel in case the treecache leaks goroutines otherwise.</span><br><span class=\"line\">\t\t\tfor range pathUpdate &#123;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\td.conn.Close()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor _, pathUpdate :&#x3D; range d.pathUpdates &#123;</span><br><span class=\"line\">\t\tgo func(update chan treecache.ZookeeperTreeCacheEvent) &#123;</span><br><span class=\"line\">\t\t\tfor event :&#x3D; range update &#123;</span><br><span class=\"line\">\t\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\t\tcase d.updates &lt;- event:</span><br><span class=\"line\">\t\t\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\t\treturn</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;(pathUpdate)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase event :&#x3D; &lt;-d.updates:</span><br><span class=\"line\">\t\t\ttg :&#x3D; &amp;targetgroup.Group&#123;</span><br><span class=\"line\">\t\t\t\tSource: event.Path,</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif event.Data !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\tlabelSet, err :&#x3D; d.parse(*event.Data, event.Path)</span><br><span class=\"line\">\t\t\t\tif err &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\t\ttg.Targets &#x3D; []model.LabelSet&#123;labelSet&#125;</span><br><span class=\"line\">\t\t\t\t\td.sources[event.Path] &#x3D; tg</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\tdelete(d.sources, event.Path)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tdelete(d.sources, event.Path)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\treturn</span><br><span class=\"line\">\t\t\tcase ch &lt;- []*targetgroup.Group&#123;tg&#125;:</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Run的流程</p>\n<ol>\n<li>给每一个需要检查的路径派生一个协程</li>\n<li>死循环获取是否有更新</li>\n<li>如果有，则使用传入的parse函数去进行解析，然后把结果发送到update的channel中，即ch变量中</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<!-- ---\nlayout: post\ntitle: Prometheus服务发现源码阅读\nauthor: Ray Chan(ray1888)\ndate: '2019-10-05 20:51:38 +0800'\ncategory: Prometheus\nsummary: Prometheus Service Discovery Module\nthumbnail: Prometheus.png\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li>使用的目的  </li>\n<li>代码实现<br>2.1 主协程逻辑<br>2.2 子协程逻辑</li>\n</ol>\n\n        <h1 id=\"代码版本\"   >\n          <a href=\"#代码版本\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码版本</h1>\n      <p>基于 prometheus项目的master branch的5a554df0855bf707a8c333c0dd830067d03422cf commit</p>\n\n        <h1 id=\"使用目的\"   >\n          <a href=\"#使用目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用目的</h1>\n      <p>服务发现是Prometheus中最重要的功能之一，因为它是支撑Prometheus可以在容器的环境下的最重要的功能。因为应用的容器部署的弹性和有效的时长远与传统的基于服务器（无论是实体机还是虚拟机[OpenStack]这一类的机器）部署， 都会变动的更加快。因此为了适应这种弹性大、变化快的环境，它需要基于不同平台来支持服务发现这个功能。</p>\n<p>Prometheus的服务发现模块是在prometheus/discovery的目录下面，它在Prometheus中的体系支撑了采集器的发现和AlertManager的发现。<br>可以看下面的代码。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;  此代码在cmd&#x2F;main.go中的 350-352行</span><br><span class=\"line\">\tctxScrape, cancelScrape &#x3D; context.WithCancel(context.Background())</span><br><span class=\"line\">\tdiscoveryManagerScrape  &#x3D; discovery.NewManager(ctxScrape, log.With(logger, &quot;component&quot;, &quot;discovery manager scrape&quot;), discovery.Name(&quot;scrape&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">\tctxNotify, cancelNotify &#x3D; context.WithCancel(context.Background())</span><br><span class=\"line\">\tdiscoveryManagerNotify  &#x3D; discovery.NewManager(ctxNotify, log.With(logger, &quot;component&quot;, &quot;discovery manager notify&quot;), discovery.Name(&quot;notify&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;  具体注入到两个功能的使用</span><br><span class=\"line\">&#x2F;* </span><br><span class=\"line\">\tcmd&#x2F;main.go line 555, 把Manager的输出的信道传递给scrapeManager，然后后面就会去restore scrape的方式。</span><br><span class=\"line\">\t后面会有单独文章写Scrape（抓取数据）的部分</span><br><span class=\"line\">\t*&#x2F;</span><br><span class=\"line\">err :&#x3D; scrapeManager.Run(discoveryManagerScrape.SyncCh())</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;* </span><br><span class=\"line\">\tcmd&#x2F;main.go line 726, 把Manager的输出的信道传递给notifierManager，然后后面就会去获取更新alertManager组件的方式。</span><br><span class=\"line\">\t后面会有单独文章写Notifer（抓取数据）的部分</span><br><span class=\"line\">\t*&#x2F;</span><br><span class=\"line\">notifierManager.Run(discoveryManagerNotify.SyncCh())</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 在main.go line 735, run Group 会执行上面注册在g 里面的这两个discoveryManager的Run方法。</span><br></pre></td></tr></table></div></figure>\n<p>所以整体的代码执行的入口流程</p>\n<ol>\n<li>在main.go实例化两个discoveryManager来进行服务发现的操作</li>\n<li>把注入的discovery config进行解析，并且生成对应的Provider协程</li>\n<li>主协程执行上面两个discoveryManager的Run方法</li>\n</ol>\n\n        <h1 id=\"代码实现\"   >\n          <a href=\"#代码实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>代码实现</h1>\n      \n        <h2 id=\"模块的运行逻辑图\"   >\n          <a href=\"#模块的运行逻辑图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>模块的运行逻辑图</h2>\n      <!-- ![ServiceDiscoveryModule](/assets/img/posts/prometheus/DiscoverManager.png) -->\n\n\n\n        <h2 id=\"主协程的逻辑\"   >\n          <a href=\"#主协程的逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>主协程的逻辑</h2>\n      <ol>\n<li>先去读取服务发现相关的配置，调用ApplyConfig()读取存在的service discovery的方式，并且加载到NewManager的结构体中。可以同同时支持多个service Discovery的方式。使用add函数把配置变为Providers结构体。<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add :&#x3D; func(cfg interface&#123;&#125;, newDiscoverer func() (Discoverer, error)) &#123;</span><br><span class=\"line\">\t\tt :&#x3D; reflect.TypeOf(cfg).String()</span><br><span class=\"line\">\t\tfor _, p :&#x3D; range m.providers &#123;</span><br><span class=\"line\">\t\t\tif reflect.DeepEqual(cfg, p.config) &#123;</span><br><span class=\"line\">\t\t\t\tp.subs &#x3D; append(p.subs, setName)</span><br><span class=\"line\">\t\t\t\tadded &#x3D; true</span><br><span class=\"line\">\t\t\t\treturn</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\td, err :&#x3D; newDiscoverer()</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tlevel.Error(m.logger).Log(&quot;msg&quot;, &quot;Cannot create service discovery&quot;, &quot;err&quot;, err, &quot;type&quot;, t)</span><br><span class=\"line\">\t\t\tfailedCount++</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprovider :&#x3D; provider&#123;</span><br><span class=\"line\">\t\t\tname:   fmt.Sprintf(&quot;%s&#x2F;%d&quot;, t, len(m.providers)),</span><br><span class=\"line\">\t\t\td:      d,</span><br><span class=\"line\">\t\t\tconfig: cfg,</span><br><span class=\"line\">\t\t\tsubs:   []string&#123;setName&#125;,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tm.providers &#x3D; append(m.providers, &amp;provider)</span><br><span class=\"line\">\t\tadded &#x3D; true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 支持多种方式的配置 具体可以看代码的discovery&#x2F;manager.go 356-417行</span><br></pre></td></tr></table></div></figure></li>\n<li>然后为每个Provider生成两个协程去进行服务发现的功能。 <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; discovery&#x2F;manager.go line 223-226</span><br><span class=\"line\">func (m *Manager) startProvider(ctx context.Context, p *provider) &#123;</span><br><span class=\"line\">\tlevel.Debug(m.logger).Log(&quot;msg&quot;, &quot;Starting provider&quot;, &quot;provider&quot;, p.name, &quot;subs&quot;, fmt.Sprintf(&quot;%v&quot;, p.subs))</span><br><span class=\"line\">\tctx, cancel :&#x3D; context.WithCancel(ctx)</span><br><span class=\"line\">\t&#x2F;&#x2F; 此处Update是执行协程与主协程的交流通道，传输Watch的变动</span><br><span class=\"line\">\tupdates :&#x3D; make(chan []*targetgroup.Group)</span><br><span class=\"line\">\tm.discoverCancel &#x3D; append(m.discoverCancel, cancel)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;  执行服务发现的Watch</span><br><span class=\"line\">\tgo p.d.Run(ctx, updates)</span><br><span class=\"line\">\t&#x2F;&#x2F; 把每个协程生成的updates放入到Manager中，使得子协程中发现到服务的变动的时候可以通知到主协程</span><br><span class=\"line\">\tgo m.updater(ctx, p, updates)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; discovery&#x2F;manager.go line 205-207</span><br><span class=\"line\">for _, prov :&#x3D; range m.providers &#123;</span><br><span class=\"line\">\t\tm.startProvider(m.ctx, prov)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\nApplyConfig完成后，Run方法如下<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (m *Manager) Run() error &#123;</span><br><span class=\"line\">\tgo m.sender()</span><br><span class=\"line\">\tfor range m.ctx.Done() &#123;</span><br><span class=\"line\">\t\tm.cancelDiscoverers()</span><br><span class=\"line\">\t\treturn m.ctx.Err()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\nManager会派生多一个协程去定时检查配置的变动，本质上是检查上面派生的updater协程时候有传入信号到triggerchan中,主协程就是为了防止泄露一直去遍历context的是否done，保持主协程阻塞，维持这个模块的运行。我们主要看一下Manager.Updater()和Manager.Sender()这两个函数。</li>\n</ol>\n<p>此处 Manager.trigglechan is 长度为1的buffered channel。updates := make(chan []*targetgroup.Group), 是unbuffered channel </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (m *Manager) updater(ctx context.Context, p *provider, updates chan []*targetgroup.Group) &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase tgs, ok :&#x3D; &lt;-updates:</span><br><span class=\"line\">\t\t\treceivedUpdates.WithLabelValues(m.name).Inc()</span><br><span class=\"line\">\t\t\tif !ok &#123;</span><br><span class=\"line\">\t\t\t\tlevel.Debug(m.logger).Log(&quot;msg&quot;, &quot;discoverer channel closed&quot;, &quot;provider&quot;, p.name)</span><br><span class=\"line\">\t\t\t\treturn</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfor _, s :&#x3D; range p.subs &#123;</span><br><span class=\"line\">\t\t\t\tm.updateGroup(poolKey&#123;setName: s, provider: p.name&#125;, tgs)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\tcase m.triggerSend &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (m *Manager) sender() &#123;</span><br><span class=\"line\">\tticker :&#x3D; time.NewTicker(m.updatert)</span><br><span class=\"line\">\tdefer ticker.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-m.ctx.Done():</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase &lt;-ticker.C: &#x2F;&#x2F; Some discoverers send updates too often so we throttle these with the ticker.</span><br><span class=\"line\">\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\tcase &lt;-m.triggerSend:</span><br><span class=\"line\">\t\t\t\tsentUpdates.WithLabelValues(m.name).Inc()</span><br><span class=\"line\">\t\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\t\tcase m.syncCh &lt;- m.allGroups():</span><br><span class=\"line\">\t\t\t\tdefault:</span><br><span class=\"line\">\t\t\t\t\tdelayedUpdates.WithLabelValues(m.name).Inc()</span><br><span class=\"line\">\t\t\t\t\tlevel.Debug(m.logger).Log(&quot;msg&quot;, &quot;discovery receiver&#39;s channel was full so will retry the next cycle&quot;)</span><br><span class=\"line\">\t\t\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\t\t\tcase m.triggerSend &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class=\"line\">\t\t\t\t\tdefault:</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>步骤</p>\n<ol>\n<li>Provider 传入变化了的update到update channel中</li>\n<li>Manager.Updater协程收集到了变化的内容后，修改Manager里面Group的内容。塞入信号到triggerSend channel中</li>\n<li>Manager.Sender协程定时去进行获取通知，检查到triggerSend Channel中可以获取之后，就会尝试塞到syncCh中，使得订阅者可以收到这个消息。(即Main里面的两个放入syncCh方法的ScrapeManager和NotiferManager可以收到)</li>\n</ol>\n<p>然后整个的流程就是这样</p>\n\n        <h2 id=\"派生协程的逻辑\"   >\n          <a href=\"#派生协程的逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>派生协程的逻辑</h2>\n      \n        <h3 id=\"Provider协程的逻辑\"   >\n          <a href=\"#Provider协程的逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Provider协程的逻辑</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Discoverer interface &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; Run hands a channel to the discovery provider (Consul, DNS etc) through which it can send</span><br><span class=\"line\">\t&#x2F;&#x2F; updated target groups.</span><br><span class=\"line\">\t&#x2F;&#x2F; Must returns if the context gets canceled. It should not close the update</span><br><span class=\"line\">\t&#x2F;&#x2F; channel on returning.</span><br><span class=\"line\">\tRun(ctx context.Context, up chan&lt;- []*targetgroup.Group)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Provider协程主要时根据具体注入的配置来生成出与对应的系统进行服务发现的能力。每个Provider中的Discoverer都实现了自己对应的Run方法即上面p.d.Run()的方法。（如何生成上面已经描述，此处不再复述）</p>\n<p>下面我们简单的看一下其中两个Provider，基于配置文件的Provider和基于zookeeper的Provider来看看具体的流程是怎样处理的。<br>对于Provider，我们可以理解为一个watch&amp;notify的模型，但是是基于不同平台给予的Api继续watch&amp;notify的操作。</p>\n\n        <h4 id=\"FileProvider执行\"   >\n          <a href=\"#FileProvider执行\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>FileProvider执行</h4>\n      <p>FileProvider支持解析json和yaml的格式内容  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; discovery&#x2F;file&#x2F;file.go line 39-46</span><br><span class=\"line\">var (</span><br><span class=\"line\">\tpatFileSDName &#x3D; regexp.MustCompile(&#96;^[^*]*(\\*[^&#x2F;]*)?\\.(json|yml|yaml|JSON|YML|YAML)$&#96;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; DefaultSDConfig is the default file SD configuration.</span><br><span class=\"line\">\tDefaultSDConfig &#x3D; SDConfig&#123;</span><br><span class=\"line\">\t\tRefreshInterval: model.Duration(5 * time.Minute),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n<p>下面我们看看主要实现Discoverer的Run方法的逻辑</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (d *Discovery) Run(ctx context.Context, ch chan&lt;- []*targetgroup.Group) &#123;</span><br><span class=\"line\">\twatcher, err :&#x3D; fsnotify.NewWatcher()</span><br><span class=\"line\">\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tlevel.Error(d.logger).Log(&quot;msg&quot;, &quot;Error adding file watcher&quot;, &quot;err&quot;, err)</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\td.watcher &#x3D; watcher</span><br><span class=\"line\">\tdefer d.stop()</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;  协程内第一次执行把conf添加到discoverer中</span><br><span class=\"line\">\td.refresh(ctx, ch)</span><br><span class=\"line\"></span><br><span class=\"line\">\tticker :&#x3D; time.NewTicker(d.interval)</span><br><span class=\"line\">\tdefer ticker.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcase event :&#x3D; &lt;-d.watcher.Events:</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; fsnotify sometimes sends a bunch of events without name or operation.</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; It&#39;s unclear what they are and why they are sent - filter them out.</span><br><span class=\"line\">\t\t\tif len(event.Name) &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Everything but a chmod requires rereading.</span><br><span class=\"line\">\t\t\tif event.Op^fsnotify.Chmod &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Changes to a file can spawn various sequences of events with</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; different combinations of operations. For all practical purposes</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; this is inaccurate.</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; The most reliable solution is to reload everything if anything happens.</span><br><span class=\"line\">\t\t\td.refresh(ctx, ch)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcase &lt;-ticker.C:</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Setting a new watch after an update might fail. Make sure we don&#39;t lose</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; those files forever.</span><br><span class=\"line\">\t\t\td.refresh(ctx, ch)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcase err :&#x3D; &lt;-d.watcher.Errors:</span><br><span class=\"line\">\t\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\tlevel.Error(d.logger).Log(&quot;msg&quot;, &quot;Error watching file&quot;, &quot;err&quot;, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>上面的死循环可以看出，对于File Discoverer， 它支持两种的Watch的方式，一个是定时监控(ticker.C)，一个是事件触发监控（event := &lt;-d.watcher.Events)。</p>\n<p>所以重点是在于Refresh函数，本质上就是一个重新解析并且检查文件内容是否有变动的函数，解析完文件之后就可以传出配置到对应的update channel中。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (d *Discovery) refresh(ctx context.Context, ch chan&lt;- []*targetgroup.Group) &#123;</span><br><span class=\"line\">\tt0 :&#x3D; time.Now()</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tfileSDScanDuration.Observe(time.Since(t0).Seconds())</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tref :&#x3D; map[string]int&#123;&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 把初始化传入的配置的路径进行检查</span><br><span class=\"line\">\tfor _, p :&#x3D; range d.listFiles() &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;  把单个文件进行解析，获取出里面的targets</span><br><span class=\"line\">\t\ttgroups, err :&#x3D; d.readFile(p)</span><br><span class=\"line\">\t\tif err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\tfileSDReadErrorsCount.Inc()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tlevel.Error(d.logger).Log(&quot;msg&quot;, &quot;Error reading file&quot;, &quot;path&quot;, p, &quot;err&quot;, err)</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Prevent deletion down below.</span><br><span class=\"line\">\t\t\tref[p] &#x3D; d.lastRefresh[p]</span><br><span class=\"line\">\t\t\tcontinue</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 把新传入的传入到Update中</span><br><span class=\"line\">\t\tcase ch &lt;- tgroups:</span><br><span class=\"line\">\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tref[p] &#x3D; len(tgroups)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; Send empty updates for sources that disappeared.</span><br><span class=\"line\">\tfor f, n :&#x3D; range d.lastRefresh &#123;</span><br><span class=\"line\">\t\tm, ok :&#x3D; ref[f]</span><br><span class=\"line\">\t\tif !ok || n &gt; m &#123;</span><br><span class=\"line\">\t\t\tlevel.Debug(d.logger).Log(&quot;msg&quot;, &quot;file_sd refresh found file that should be removed&quot;, &quot;file&quot;, f)</span><br><span class=\"line\">\t\t\td.deleteTimestamp(f)</span><br><span class=\"line\">\t\t\tfor i :&#x3D; m; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\t\tcase ch &lt;- []*targetgroup.Group&#123;&#123;Source: fileSource(f, i)&#125;&#125;:</span><br><span class=\"line\">\t\t\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\t\treturn</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\td.lastRefresh &#x3D; ref</span><br><span class=\"line\"></span><br><span class=\"line\">\td.watchFiles()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"zookeeperProvider执行\"   >\n          <a href=\"#zookeeperProvider执行\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>zookeeperProvider执行</h4>\n      <p>Zookeeper的Provider与上面的模式类似，差别在于：</p>\n<ol>\n<li>初始化的时候需要创建zookeeper的链接（配置中需要传入配置好zookeeper相关的配置）</li>\n<li>分为了ServerSetPoint和NerveEndPoint两个类型的Discovery，因此抽象了一个Discovery的结构体</li>\n<li>没有了定时检查（因为不存在文件系统问题的）这种检查的方式</li>\n</ol>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Discovery struct &#123;</span><br><span class=\"line\">\tconn *zk.Conn</span><br><span class=\"line\"></span><br><span class=\"line\">\tsources map[string]*targetgroup.Group</span><br><span class=\"line\"></span><br><span class=\"line\">\tupdates     chan treecache.ZookeeperTreeCacheEvent</span><br><span class=\"line\">\tpathUpdates []chan treecache.ZookeeperTreeCacheEvent</span><br><span class=\"line\">\ttreeCaches  []*treecache.ZookeeperTreeCache</span><br><span class=\"line\"></span><br><span class=\"line\">\tparse  func(data []byte, path string) (model.LabelSet, error)</span><br><span class=\"line\">\tlogger log.Logger</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (d *Discovery) Run(ctx context.Context, ch chan&lt;- []*targetgroup.Group) &#123;</span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\tfor _, tc :&#x3D; range d.treeCaches &#123;</span><br><span class=\"line\">\t\t\ttc.Stop()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor _, pathUpdate :&#x3D; range d.pathUpdates &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; Drain event channel in case the treecache leaks goroutines otherwise.</span><br><span class=\"line\">\t\t\tfor range pathUpdate &#123;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\td.conn.Close()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor _, pathUpdate :&#x3D; range d.pathUpdates &#123;</span><br><span class=\"line\">\t\tgo func(update chan treecache.ZookeeperTreeCacheEvent) &#123;</span><br><span class=\"line\">\t\t\tfor event :&#x3D; range update &#123;</span><br><span class=\"line\">\t\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\t\tcase d.updates &lt;- event:</span><br><span class=\"line\">\t\t\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\t\treturn</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;(pathUpdate)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tselect &#123;</span><br><span class=\"line\">\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\treturn</span><br><span class=\"line\">\t\tcase event :&#x3D; &lt;-d.updates:</span><br><span class=\"line\">\t\t\ttg :&#x3D; &amp;targetgroup.Group&#123;</span><br><span class=\"line\">\t\t\t\tSource: event.Path,</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif event.Data !&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\tlabelSet, err :&#x3D; d.parse(*event.Data, event.Path)</span><br><span class=\"line\">\t\t\t\tif err &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\t\t\ttg.Targets &#x3D; []model.LabelSet&#123;labelSet&#125;</span><br><span class=\"line\">\t\t\t\t\td.sources[event.Path] &#x3D; tg</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\tdelete(d.sources, event.Path)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tdelete(d.sources, event.Path)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\tcase &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\t\treturn</span><br><span class=\"line\">\t\t\tcase ch &lt;- []*targetgroup.Group&#123;tg&#125;:</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>Run的流程</p>\n<ol>\n<li>给每一个需要检查的路径派生一个协程</li>\n<li>死循环获取是否有更新</li>\n<li>如果有，则使用传入的parse函数去进行解析，然后把结果发送到update的channel中，即ch变量中</li>\n</ol>\n"},{"title":"MIT6.824 Lab3 实现及解析","date":"2019-08-29T07:05:38.000Z","_content":"\n<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: \nsummary: MIT6.824 Lab3 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n# 目录\n1. 实验目的\n2. 实验实现\n\n# <a id=\"\"><span class=\"toptitle\">实验目的</span></a>\nlab3需要实现一个建议的带客户端的 分布式KV的数据库，需要支持对外的Get(), Put(), Append()三个操作\n\n整体的实验架构是这样的\n\n<!-- ![lab3](/assets/img/posts/Lab3-Process.png) -->\n{% asset_img Lab3-Process.png lab3 %}\n架构图如上：\n一个值得注意的点是，各个KV数据库层之间不会直接相互通信，只是会通过Raft层来同步操作。  \n并且Client如果找到的不是Leader的节点，会直接放弃操作。然后请求集群内的下一个节点。  \nPS: 这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。  \n\n流程大概如下:\n1. Client发送请求到KvDatabase\n2. KvDatabase收到请求后，会把收到的命令重新封装，通过Raft提供的Start API来在Raft集群中进行同步的操作\n3. Raft同步到其他的非Leader节点中\n4. Raft层同步成功后，会通过ApplyCh返回信号的KvDatabase\n5. KvDatabase对Client端做出应答（如果成功返回结果为成功，如果下面同步层失败导致超时，返回给客户端的结果为超时）\n\n# <a id=\"\"><span class=\"toptitle\">实验实现</span></a>\n\n此部分实现分为两个部分：\n1. 基础的键值对的实现\n2. 日志压缩与快照的部分\n\n\n## <a id=\"\"><span class=\"secondtitle\">基础键值对的实现</span></a>\n\n因为上面提及到这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。  \n所以此处展示一下KvRaft所包含的结构\n```\ntype KVServer struct {\n\tmu      sync.Mutex\n\tme      int\n    // 包含了Raft的实例\n\trf      *raft.Raft\n    // Applych 是 用与接受Raft成形成共识后的返回\n\tapplyCh chan raft.ApplyMsg\n\n\tmaxraftstate int // snapshot if log grows this big\n\tdatabase map[string]string\n\tdup map[int64]int\n\tchanResult map[int]chan Op\n}\n\n// Type OP\ntype Op struct {\n    // Key 是 Get()、Put()、Append()三个都会用到的值\n\tKey      string\n    // Value是Put()、Append()用到的字段，Get此处默认为空\n\tValue    string\n    // 存放的是操作的名称\n\tName     string\n    // 用于表示客户端的来源\n\tClientId int64\n    // 给予序号\n\tSeq      int\n}\n```\n\n上面所描述到的Op结构体的操作为什么要把Get加入，并且需要区分ClientId和Seq的原因，本质上都是需要在全序关系广播中实现线性化所需要的。如果不知道什么是全序关系广播，可以查看之前我的文章[分布式系统一致性与共识](https://ray1888.github.io/distributed-system/2019/08/20/distributed-consensus/)\n\n此处还需要注意，因为我们暴露给客户端的操作是一个同步的操作，但是我们这层与Raft层是一个异步的操作，因此，需要我们这边等待Raft层异步返回成功，并且我们此层把数据保留下来后，才能继续返回\n\n所以需要需要在另外一个协程中去读取ApplyCH的数据，然后继续对比之后再去创建返回给客户端\n\n```\nfunc (kv *KVServer) ApplyOPRoutine() {\n\t//this gorouine is to asyncly get the result of raft applych reply to\n\t// and to produce signal to reply client Rpc Request\n\tDPrintf(\"Apply gorountine runing \")\n\tfor {\n\t\tmsg := <-kv.applyCh\n\t\t//DPrintf(\"get apply msg from raftServer\")\n\t\tif msg.CommandValid {\n\t\t\tindex := msg.CommandIndex\n\t\t\tif cmd, ok := msg.Command.(Op); ok {\n\t\t\t\tkv.mu.Lock()\n                // 对比单个客户端的序号，来减少重复的旧操作的更新操作\n\t\t\t\tif kv.dupcheck(cmd.ClientId, cmd.Seq) {\n\t\t\t\t\tif cmd.Name == PUT {\n\t\t\t\t\t\tkv.database[cmd.Key] = cmd.Value\n\t\t\t\t\t} else if cmd.Name == APPEND {\n\t\t\t\t\t\tif _, ok := kv.database[cmd.Key]; ok {\n\t\t\t\t\t\t\tkv.database[cmd.Key] += cmd.Value\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tkv.database[cmd.Key] = cmd.Value\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkv.dup[cmd.ClientId] = cmd.Seq\n\t\t\t\t}\n\t\t\t\tres := Op{cmd.Key, kv.database[cmd.Key], cmd.Name,\n\t\t\t\t\tcmd.ClientId, cmd.Seq}\n\t\t\t\tch, ok := kv.chanResult[index]\n\t\t\t\tif ok {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ch:\n\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\tch <- res\n\t\t\t\t\t//DPrintf(\"the cmd has been commited , push request return to chan\")\n\t\t\t\t}\n\t\t\t\tif kv.maxraftstate != -1 && kv.rf.GetStateSize() >= kv.maxraftstate && index == kv.rf.GetCommitedIndex() {\n\t\t\t\t\tDPrintf(\"Do snapshot for over the maxraftstate\")\n\t\t\t\t\tkv.DoSnapShot(index)\n\t\t\t\t}\n\t\t\t\tkv.mu.Unlock()\n\t\t\t}\n\t\t} else {\n\t\t\tkv.LoadSnapShot(msg.Snapshot)\n\n\t\t}\n\t}\n}\n\n//  把OP传入到Raft共识层的函数\nfunc(rf *Raft) StartCommand(cmd Op) (Err, string){\n    index, _, isLeader := kv.rf.Start(cmd)\n\t//DPrintf(\"start command %s , client id is %d, key is %s, value is %s\",\n\t//\tcmd.Name, cmd.ClientId, cmd.Key, cmd.Value)\n\tif !isLeader {\n\t\tkv.mu.Unlock()\n\t\t//DPrintf(\"not leader \")\n\t\treturn ERRWrongLeader, \"\"\n\t}\n\tch := make(chan Op, 1)\n\tkv.chanResult[index] = ch\n\tkv.mu.Unlock()\n\n\tdefer func() {\n\t\t// After finish the task\n\t\tkv.mu.Lock()\n\t\tdelete(kv.chanResult, index)\n\t\tkv.mu.Unlock()\n\t}()\n\tselect {\n\tcase c := <-ch:\n\t\t// this channel return is get data from ApplyRoutine\n\t\tif kv.CheckSame(c, cmd) {\n\t\t\tresvalue := \"\"\n\t\t\tif cmd.Name == GET {\n\t\t\t\tresvalue = c.Value\n\t\t\t}\n\t\t\treturn OK, resvalue\n\t\t} else {\n\t\t\tDPrintf(\"Leader has change, index %d op %s error\", index, cmd.Name)\n\t\t\treturn ERRWrongLeader, \"\"\n\t\t}\n\tcase <-time.After(time.Duration(200) * time.Millisecond):\n\t\tDPrintf(\"log get agree timeout, index is %d\", index)\n\t\treturn ERRTimeout, \"\"\n\t}\n}\n```\n\n## <a id=\"\"><span class=\"secondtitle\">日志压缩与快照</span></a>\n\n此处的快照与Raft本身的快照多了两个KVDatabase 特有的属性， database（保存的数据） 和 dup （客户端操作序号的记录）这两个属性\n```\nfunc (kv *KVServer) DoSnapShot(index int) {\n\tkv.rf.SaveSnapShot(index, kv.database, kv.dup)\n}\n\n\n// 读取快照的函数\nfunc (kv *KVServer) LoadSnapShot(snapshot []byte) {\n\tif snapshot == nil || len(snapshot) < 1 {\n\t\tkv.mu.Lock()\n\t\tkv.database = make(map[string]string)\n\t\tkv.mu.Unlock()\n\t\treturn\n\t}\n\ts := bytes.NewBuffer(snapshot)\n\tdecoder := labgob.NewDecoder(s)\n\tvar kvdb map[string]string\n\tvar kvdup map[int64]int\n\tif decoder.Decode(&kvdb) != nil || decoder.Decode(&kvdup) != nil {\n\t\tDPrintf(\"server %d, Decode Snapshot error\", kv.me)\n\t} else {\n\t\tkv.mu.Lock()\n\t\tdefer kv.mu.Unlock()\n\t\tkv.database = kvdb\n\t\tkv.dup = kvdup\n\t\tDPrintf(\"msg snapshot db is %v, dup is %v\", kvdb, kvdup)\n\t\tDPrintf(\"server %d , load Snapshot success\", kv.me)\n\t}\n}\n\n```\n\n在本实验中，会触发日志保留的情况只是因为保存的Log> maxraftstate。 \n\n\n\n","source":"_posts/raft-lab-3.md","raw":"---\ntitle:  MIT6.824 Lab3 实现及解析\ndate: 2019-08-29 15:05:38\ntags: distributed-system\n---\n\n<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: \nsummary: MIT6.824 Lab3 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n# 目录\n1. 实验目的\n2. 实验实现\n\n# <a id=\"\"><span class=\"toptitle\">实验目的</span></a>\nlab3需要实现一个建议的带客户端的 分布式KV的数据库，需要支持对外的Get(), Put(), Append()三个操作\n\n整体的实验架构是这样的\n\n<!-- ![lab3](/assets/img/posts/Lab3-Process.png) -->\n{% asset_img Lab3-Process.png lab3 %}\n架构图如上：\n一个值得注意的点是，各个KV数据库层之间不会直接相互通信，只是会通过Raft层来同步操作。  \n并且Client如果找到的不是Leader的节点，会直接放弃操作。然后请求集群内的下一个节点。  \nPS: 这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。  \n\n流程大概如下:\n1. Client发送请求到KvDatabase\n2. KvDatabase收到请求后，会把收到的命令重新封装，通过Raft提供的Start API来在Raft集群中进行同步的操作\n3. Raft同步到其他的非Leader节点中\n4. Raft层同步成功后，会通过ApplyCh返回信号的KvDatabase\n5. KvDatabase对Client端做出应答（如果成功返回结果为成功，如果下面同步层失败导致超时，返回给客户端的结果为超时）\n\n# <a id=\"\"><span class=\"toptitle\">实验实现</span></a>\n\n此部分实现分为两个部分：\n1. 基础的键值对的实现\n2. 日志压缩与快照的部分\n\n\n## <a id=\"\"><span class=\"secondtitle\">基础键值对的实现</span></a>\n\n因为上面提及到这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。  \n所以此处展示一下KvRaft所包含的结构\n```\ntype KVServer struct {\n\tmu      sync.Mutex\n\tme      int\n    // 包含了Raft的实例\n\trf      *raft.Raft\n    // Applych 是 用与接受Raft成形成共识后的返回\n\tapplyCh chan raft.ApplyMsg\n\n\tmaxraftstate int // snapshot if log grows this big\n\tdatabase map[string]string\n\tdup map[int64]int\n\tchanResult map[int]chan Op\n}\n\n// Type OP\ntype Op struct {\n    // Key 是 Get()、Put()、Append()三个都会用到的值\n\tKey      string\n    // Value是Put()、Append()用到的字段，Get此处默认为空\n\tValue    string\n    // 存放的是操作的名称\n\tName     string\n    // 用于表示客户端的来源\n\tClientId int64\n    // 给予序号\n\tSeq      int\n}\n```\n\n上面所描述到的Op结构体的操作为什么要把Get加入，并且需要区分ClientId和Seq的原因，本质上都是需要在全序关系广播中实现线性化所需要的。如果不知道什么是全序关系广播，可以查看之前我的文章[分布式系统一致性与共识](https://ray1888.github.io/distributed-system/2019/08/20/distributed-consensus/)\n\n此处还需要注意，因为我们暴露给客户端的操作是一个同步的操作，但是我们这层与Raft层是一个异步的操作，因此，需要我们这边等待Raft层异步返回成功，并且我们此层把数据保留下来后，才能继续返回\n\n所以需要需要在另外一个协程中去读取ApplyCH的数据，然后继续对比之后再去创建返回给客户端\n\n```\nfunc (kv *KVServer) ApplyOPRoutine() {\n\t//this gorouine is to asyncly get the result of raft applych reply to\n\t// and to produce signal to reply client Rpc Request\n\tDPrintf(\"Apply gorountine runing \")\n\tfor {\n\t\tmsg := <-kv.applyCh\n\t\t//DPrintf(\"get apply msg from raftServer\")\n\t\tif msg.CommandValid {\n\t\t\tindex := msg.CommandIndex\n\t\t\tif cmd, ok := msg.Command.(Op); ok {\n\t\t\t\tkv.mu.Lock()\n                // 对比单个客户端的序号，来减少重复的旧操作的更新操作\n\t\t\t\tif kv.dupcheck(cmd.ClientId, cmd.Seq) {\n\t\t\t\t\tif cmd.Name == PUT {\n\t\t\t\t\t\tkv.database[cmd.Key] = cmd.Value\n\t\t\t\t\t} else if cmd.Name == APPEND {\n\t\t\t\t\t\tif _, ok := kv.database[cmd.Key]; ok {\n\t\t\t\t\t\t\tkv.database[cmd.Key] += cmd.Value\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tkv.database[cmd.Key] = cmd.Value\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkv.dup[cmd.ClientId] = cmd.Seq\n\t\t\t\t}\n\t\t\t\tres := Op{cmd.Key, kv.database[cmd.Key], cmd.Name,\n\t\t\t\t\tcmd.ClientId, cmd.Seq}\n\t\t\t\tch, ok := kv.chanResult[index]\n\t\t\t\tif ok {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ch:\n\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\tch <- res\n\t\t\t\t\t//DPrintf(\"the cmd has been commited , push request return to chan\")\n\t\t\t\t}\n\t\t\t\tif kv.maxraftstate != -1 && kv.rf.GetStateSize() >= kv.maxraftstate && index == kv.rf.GetCommitedIndex() {\n\t\t\t\t\tDPrintf(\"Do snapshot for over the maxraftstate\")\n\t\t\t\t\tkv.DoSnapShot(index)\n\t\t\t\t}\n\t\t\t\tkv.mu.Unlock()\n\t\t\t}\n\t\t} else {\n\t\t\tkv.LoadSnapShot(msg.Snapshot)\n\n\t\t}\n\t}\n}\n\n//  把OP传入到Raft共识层的函数\nfunc(rf *Raft) StartCommand(cmd Op) (Err, string){\n    index, _, isLeader := kv.rf.Start(cmd)\n\t//DPrintf(\"start command %s , client id is %d, key is %s, value is %s\",\n\t//\tcmd.Name, cmd.ClientId, cmd.Key, cmd.Value)\n\tif !isLeader {\n\t\tkv.mu.Unlock()\n\t\t//DPrintf(\"not leader \")\n\t\treturn ERRWrongLeader, \"\"\n\t}\n\tch := make(chan Op, 1)\n\tkv.chanResult[index] = ch\n\tkv.mu.Unlock()\n\n\tdefer func() {\n\t\t// After finish the task\n\t\tkv.mu.Lock()\n\t\tdelete(kv.chanResult, index)\n\t\tkv.mu.Unlock()\n\t}()\n\tselect {\n\tcase c := <-ch:\n\t\t// this channel return is get data from ApplyRoutine\n\t\tif kv.CheckSame(c, cmd) {\n\t\t\tresvalue := \"\"\n\t\t\tif cmd.Name == GET {\n\t\t\t\tresvalue = c.Value\n\t\t\t}\n\t\t\treturn OK, resvalue\n\t\t} else {\n\t\t\tDPrintf(\"Leader has change, index %d op %s error\", index, cmd.Name)\n\t\t\treturn ERRWrongLeader, \"\"\n\t\t}\n\tcase <-time.After(time.Duration(200) * time.Millisecond):\n\t\tDPrintf(\"log get agree timeout, index is %d\", index)\n\t\treturn ERRTimeout, \"\"\n\t}\n}\n```\n\n## <a id=\"\"><span class=\"secondtitle\">日志压缩与快照</span></a>\n\n此处的快照与Raft本身的快照多了两个KVDatabase 特有的属性， database（保存的数据） 和 dup （客户端操作序号的记录）这两个属性\n```\nfunc (kv *KVServer) DoSnapShot(index int) {\n\tkv.rf.SaveSnapShot(index, kv.database, kv.dup)\n}\n\n\n// 读取快照的函数\nfunc (kv *KVServer) LoadSnapShot(snapshot []byte) {\n\tif snapshot == nil || len(snapshot) < 1 {\n\t\tkv.mu.Lock()\n\t\tkv.database = make(map[string]string)\n\t\tkv.mu.Unlock()\n\t\treturn\n\t}\n\ts := bytes.NewBuffer(snapshot)\n\tdecoder := labgob.NewDecoder(s)\n\tvar kvdb map[string]string\n\tvar kvdup map[int64]int\n\tif decoder.Decode(&kvdb) != nil || decoder.Decode(&kvdup) != nil {\n\t\tDPrintf(\"server %d, Decode Snapshot error\", kv.me)\n\t} else {\n\t\tkv.mu.Lock()\n\t\tdefer kv.mu.Unlock()\n\t\tkv.database = kvdb\n\t\tkv.dup = kvdup\n\t\tDPrintf(\"msg snapshot db is %v, dup is %v\", kvdb, kvdup)\n\t\tDPrintf(\"server %d , load Snapshot success\", kv.me)\n\t}\n}\n\n```\n\n在本实验中，会触发日志保留的情况只是因为保存的Log> maxraftstate。 \n\n\n\n","slug":"raft-lab-3","published":1,"updated":"2021-01-21T07:27:32.636Z","_id":"ckk6irarf000ak9i58ywe0055","comments":1,"layout":"post","photos":[],"link":"","content":"<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: \nsummary: MIT6.824 Lab3 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li>实验目的</li>\n<li>实验实现</li>\n</ol>\n\n        <h1 id=\"实验目的\"   >\n          <a href=\"#实验目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实验目的</h1>\n      <p>lab3需要实现一个建议的带客户端的 分布式KV的数据库，需要支持对外的Get(), Put(), Append()三个操作</p>\n<p>整体的实验架构是这样的</p>\n<!-- ![lab3](/assets/img/posts/Lab3-Process.png) -->\n<img src=\"/2019/08/29/raft-lab-3/Lab3-Process.png\" class=\"\" title=\"lab3\">\n<p>架构图如上：<br>一个值得注意的点是，各个KV数据库层之间不会直接相互通信，只是会通过Raft层来同步操作。<br>并且Client如果找到的不是Leader的节点，会直接放弃操作。然后请求集群内的下一个节点。<br>PS: 这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。  </p>\n<p>流程大概如下:</p>\n<ol>\n<li>Client发送请求到KvDatabase</li>\n<li>KvDatabase收到请求后，会把收到的命令重新封装，通过Raft提供的Start API来在Raft集群中进行同步的操作</li>\n<li>Raft同步到其他的非Leader节点中</li>\n<li>Raft层同步成功后，会通过ApplyCh返回信号的KvDatabase</li>\n<li>KvDatabase对Client端做出应答（如果成功返回结果为成功，如果下面同步层失败导致超时，返回给客户端的结果为超时）</li>\n</ol>\n\n        <h1 id=\"实验实现\"   >\n          <a href=\"#实验实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实验实现</h1>\n      <p>此部分实现分为两个部分：</p>\n<ol>\n<li>基础的键值对的实现</li>\n<li>日志压缩与快照的部分</li>\n</ol>\n\n        <h2 id=\"基础键值对的实现\"   >\n          <a href=\"#基础键值对的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基础键值对的实现</h2>\n      <p>因为上面提及到这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。<br>所以此处展示一下KvRaft所包含的结构</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type KVServer struct &#123;</span><br><span class=\"line\">\tmu      sync.Mutex</span><br><span class=\"line\">\tme      int</span><br><span class=\"line\">    &#x2F;&#x2F; 包含了Raft的实例</span><br><span class=\"line\">\trf      *raft.Raft</span><br><span class=\"line\">    &#x2F;&#x2F; Applych 是 用与接受Raft成形成共识后的返回</span><br><span class=\"line\">\tapplyCh chan raft.ApplyMsg</span><br><span class=\"line\"></span><br><span class=\"line\">\tmaxraftstate int &#x2F;&#x2F; snapshot if log grows this big</span><br><span class=\"line\">\tdatabase map[string]string</span><br><span class=\"line\">\tdup map[int64]int</span><br><span class=\"line\">\tchanResult map[int]chan Op</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Type OP</span><br><span class=\"line\">type Op struct &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Key 是 Get()、Put()、Append()三个都会用到的值</span><br><span class=\"line\">\tKey      string</span><br><span class=\"line\">    &#x2F;&#x2F; Value是Put()、Append()用到的字段，Get此处默认为空</span><br><span class=\"line\">\tValue    string</span><br><span class=\"line\">    &#x2F;&#x2F; 存放的是操作的名称</span><br><span class=\"line\">\tName     string</span><br><span class=\"line\">    &#x2F;&#x2F; 用于表示客户端的来源</span><br><span class=\"line\">\tClientId int64</span><br><span class=\"line\">    &#x2F;&#x2F; 给予序号</span><br><span class=\"line\">\tSeq      int</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>上面所描述到的Op结构体的操作为什么要把Get加入，并且需要区分ClientId和Seq的原因，本质上都是需要在全序关系广播中实现线性化所需要的。如果不知道什么是全序关系广播，可以查看之前我的文章<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://ray1888.github.io/distributed-system/2019/08/20/distributed-consensus/\" >分布式系统一致性与共识</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>此处还需要注意，因为我们暴露给客户端的操作是一个同步的操作，但是我们这层与Raft层是一个异步的操作，因此，需要我们这边等待Raft层异步返回成功，并且我们此层把数据保留下来后，才能继续返回</p>\n<p>所以需要需要在另外一个协程中去读取ApplyCH的数据，然后继续对比之后再去创建返回给客户端</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (kv *KVServer) ApplyOPRoutine() &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;this gorouine is to asyncly get the result of raft applych reply to</span><br><span class=\"line\">\t&#x2F;&#x2F; and to produce signal to reply client Rpc Request</span><br><span class=\"line\">\tDPrintf(&quot;Apply gorountine runing &quot;)</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tmsg :&#x3D; &lt;-kv.applyCh</span><br><span class=\"line\">\t\t&#x2F;&#x2F;DPrintf(&quot;get apply msg from raftServer&quot;)</span><br><span class=\"line\">\t\tif msg.CommandValid &#123;</span><br><span class=\"line\">\t\t\tindex :&#x3D; msg.CommandIndex</span><br><span class=\"line\">\t\t\tif cmd, ok :&#x3D; msg.Command.(Op); ok &#123;</span><br><span class=\"line\">\t\t\t\tkv.mu.Lock()</span><br><span class=\"line\">                &#x2F;&#x2F; 对比单个客户端的序号，来减少重复的旧操作的更新操作</span><br><span class=\"line\">\t\t\t\tif kv.dupcheck(cmd.ClientId, cmd.Seq) &#123;</span><br><span class=\"line\">\t\t\t\t\tif cmd.Name &#x3D;&#x3D; PUT &#123;</span><br><span class=\"line\">\t\t\t\t\t\tkv.database[cmd.Key] &#x3D; cmd.Value</span><br><span class=\"line\">\t\t\t\t\t&#125; else if cmd.Name &#x3D;&#x3D; APPEND &#123;</span><br><span class=\"line\">\t\t\t\t\t\tif _, ok :&#x3D; kv.database[cmd.Key]; ok &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tkv.database[cmd.Key] +&#x3D; cmd.Value</span><br><span class=\"line\">\t\t\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tkv.database[cmd.Key] &#x3D; cmd.Value</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tkv.dup[cmd.ClientId] &#x3D; cmd.Seq</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres :&#x3D; Op&#123;cmd.Key, kv.database[cmd.Key], cmd.Name,</span><br><span class=\"line\">\t\t\t\t\tcmd.ClientId, cmd.Seq&#125;</span><br><span class=\"line\">\t\t\t\tch, ok :&#x3D; kv.chanResult[index]</span><br><span class=\"line\">\t\t\t\tif ok &#123;</span><br><span class=\"line\">\t\t\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\t\t\tcase &lt;-ch:</span><br><span class=\"line\">\t\t\t\t\tdefault:</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tch &lt;- res</span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F;DPrintf(&quot;the cmd has been commited , push request return to chan&quot;)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tif kv.maxraftstate !&#x3D; -1 &amp;&amp; kv.rf.GetStateSize() &gt;&#x3D; kv.maxraftstate &amp;&amp; index &#x3D;&#x3D; kv.rf.GetCommitedIndex() &#123;</span><br><span class=\"line\">\t\t\t\t\tDPrintf(&quot;Do snapshot for over the maxraftstate&quot;)</span><br><span class=\"line\">\t\t\t\t\tkv.DoSnapShot(index)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tkv.LoadSnapShot(msg.Snapshot)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;  把OP传入到Raft共识层的函数</span><br><span class=\"line\">func(rf *Raft) StartCommand(cmd Op) (Err, string)&#123;</span><br><span class=\"line\">    index, _, isLeader :&#x3D; kv.rf.Start(cmd)</span><br><span class=\"line\">\t&#x2F;&#x2F;DPrintf(&quot;start command %s , client id is %d, key is %s, value is %s&quot;,</span><br><span class=\"line\">\t&#x2F;&#x2F;\tcmd.Name, cmd.ClientId, cmd.Key, cmd.Value)</span><br><span class=\"line\">\tif !isLeader &#123;</span><br><span class=\"line\">\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\t&#x2F;&#x2F;DPrintf(&quot;not leader &quot;)</span><br><span class=\"line\">\t\treturn ERRWrongLeader, &quot;&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tch :&#x3D; make(chan Op, 1)</span><br><span class=\"line\">\tkv.chanResult[index] &#x3D; ch</span><br><span class=\"line\">\tkv.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; After finish the task</span><br><span class=\"line\">\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\tdelete(kv.chanResult, index)</span><br><span class=\"line\">\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tselect &#123;</span><br><span class=\"line\">\tcase c :&#x3D; &lt;-ch:</span><br><span class=\"line\">\t\t&#x2F;&#x2F; this channel return is get data from ApplyRoutine</span><br><span class=\"line\">\t\tif kv.CheckSame(c, cmd) &#123;</span><br><span class=\"line\">\t\t\tresvalue :&#x3D; &quot;&quot;</span><br><span class=\"line\">\t\t\tif cmd.Name &#x3D;&#x3D; GET &#123;</span><br><span class=\"line\">\t\t\t\tresvalue &#x3D; c.Value</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn OK, resvalue</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tDPrintf(&quot;Leader has change, index %d op %s error&quot;, index, cmd.Name)</span><br><span class=\"line\">\t\t\treturn ERRWrongLeader, &quot;&quot;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\tcase &lt;-time.After(time.Duration(200) * time.Millisecond):</span><br><span class=\"line\">\t\tDPrintf(&quot;log get agree timeout, index is %d&quot;, index)</span><br><span class=\"line\">\t\treturn ERRTimeout, &quot;&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"日志压缩与快照\"   >\n          <a href=\"#日志压缩与快照\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>日志压缩与快照</h2>\n      <p>此处的快照与Raft本身的快照多了两个KVDatabase 特有的属性， database（保存的数据） 和 dup （客户端操作序号的记录）这两个属性</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (kv *KVServer) DoSnapShot(index int) &#123;</span><br><span class=\"line\">\tkv.rf.SaveSnapShot(index, kv.database, kv.dup)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 读取快照的函数</span><br><span class=\"line\">func (kv *KVServer) LoadSnapShot(snapshot []byte) &#123;</span><br><span class=\"line\">\tif snapshot &#x3D;&#x3D; nil || len(snapshot) &lt; 1 &#123;</span><br><span class=\"line\">\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\tkv.database &#x3D; make(map[string]string)</span><br><span class=\"line\">\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts :&#x3D; bytes.NewBuffer(snapshot)</span><br><span class=\"line\">\tdecoder :&#x3D; labgob.NewDecoder(s)</span><br><span class=\"line\">\tvar kvdb map[string]string</span><br><span class=\"line\">\tvar kvdup map[int64]int</span><br><span class=\"line\">\tif decoder.Decode(&amp;kvdb) !&#x3D; nil || decoder.Decode(&amp;kvdup) !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tDPrintf(&quot;server %d, Decode Snapshot error&quot;, kv.me)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\tdefer kv.mu.Unlock()</span><br><span class=\"line\">\t\tkv.database &#x3D; kvdb</span><br><span class=\"line\">\t\tkv.dup &#x3D; kvdup</span><br><span class=\"line\">\t\tDPrintf(&quot;msg snapshot db is %v, dup is %v&quot;, kvdb, kvdup)</span><br><span class=\"line\">\t\tDPrintf(&quot;server %d , load Snapshot success&quot;, kv.me)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>在本实验中，会触发日志保留的情况只是因为保存的Log&gt; maxraftstate。 </p>\n","site":{"data":{}},"excerpt":"","more":"<!-- ---\nlayout: post\ntitle:\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: \nsummary: MIT6.824 Lab3 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li>实验目的</li>\n<li>实验实现</li>\n</ol>\n\n        <h1 id=\"实验目的\"   >\n          <a href=\"#实验目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实验目的</h1>\n      <p>lab3需要实现一个建议的带客户端的 分布式KV的数据库，需要支持对外的Get(), Put(), Append()三个操作</p>\n<p>整体的实验架构是这样的</p>\n<!-- ![lab3](/assets/img/posts/Lab3-Process.png) -->\n<img src=\"/2019/08/29/raft-lab-3/Lab3-Process.png\" class=\"\" title=\"lab3\">\n<p>架构图如上：<br>一个值得注意的点是，各个KV数据库层之间不会直接相互通信，只是会通过Raft层来同步操作。<br>并且Client如果找到的不是Leader的节点，会直接放弃操作。然后请求集群内的下一个节点。<br>PS: 这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。  </p>\n<p>流程大概如下:</p>\n<ol>\n<li>Client发送请求到KvDatabase</li>\n<li>KvDatabase收到请求后，会把收到的命令重新封装，通过Raft提供的Start API来在Raft集群中进行同步的操作</li>\n<li>Raft同步到其他的非Leader节点中</li>\n<li>Raft层同步成功后，会通过ApplyCh返回信号的KvDatabase</li>\n<li>KvDatabase对Client端做出应答（如果成功返回结果为成功，如果下面同步层失败导致超时，返回给客户端的结果为超时）</li>\n</ol>\n\n        <h1 id=\"实验实现\"   >\n          <a href=\"#实验实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实验实现</h1>\n      <p>此部分实现分为两个部分：</p>\n<ol>\n<li>基础的键值对的实现</li>\n<li>日志压缩与快照的部分</li>\n</ol>\n\n        <h2 id=\"基础键值对的实现\"   >\n          <a href=\"#基础键值对的实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基础键值对的实现</h2>\n      <p>因为上面提及到这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。<br>所以此处展示一下KvRaft所包含的结构</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type KVServer struct &#123;</span><br><span class=\"line\">\tmu      sync.Mutex</span><br><span class=\"line\">\tme      int</span><br><span class=\"line\">    &#x2F;&#x2F; 包含了Raft的实例</span><br><span class=\"line\">\trf      *raft.Raft</span><br><span class=\"line\">    &#x2F;&#x2F; Applych 是 用与接受Raft成形成共识后的返回</span><br><span class=\"line\">\tapplyCh chan raft.ApplyMsg</span><br><span class=\"line\"></span><br><span class=\"line\">\tmaxraftstate int &#x2F;&#x2F; snapshot if log grows this big</span><br><span class=\"line\">\tdatabase map[string]string</span><br><span class=\"line\">\tdup map[int64]int</span><br><span class=\"line\">\tchanResult map[int]chan Op</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Type OP</span><br><span class=\"line\">type Op struct &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Key 是 Get()、Put()、Append()三个都会用到的值</span><br><span class=\"line\">\tKey      string</span><br><span class=\"line\">    &#x2F;&#x2F; Value是Put()、Append()用到的字段，Get此处默认为空</span><br><span class=\"line\">\tValue    string</span><br><span class=\"line\">    &#x2F;&#x2F; 存放的是操作的名称</span><br><span class=\"line\">\tName     string</span><br><span class=\"line\">    &#x2F;&#x2F; 用于表示客户端的来源</span><br><span class=\"line\">\tClientId int64</span><br><span class=\"line\">    &#x2F;&#x2F; 给予序号</span><br><span class=\"line\">\tSeq      int</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>上面所描述到的Op结构体的操作为什么要把Get加入，并且需要区分ClientId和Seq的原因，本质上都是需要在全序关系广播中实现线性化所需要的。如果不知道什么是全序关系广播，可以查看之前我的文章<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://ray1888.github.io/distributed-system/2019/08/20/distributed-consensus/\" >分布式系统一致性与共识</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<p>此处还需要注意，因为我们暴露给客户端的操作是一个同步的操作，但是我们这层与Raft层是一个异步的操作，因此，需要我们这边等待Raft层异步返回成功，并且我们此层把数据保留下来后，才能继续返回</p>\n<p>所以需要需要在另外一个协程中去读取ApplyCH的数据，然后继续对比之后再去创建返回给客户端</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (kv *KVServer) ApplyOPRoutine() &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;this gorouine is to asyncly get the result of raft applych reply to</span><br><span class=\"line\">\t&#x2F;&#x2F; and to produce signal to reply client Rpc Request</span><br><span class=\"line\">\tDPrintf(&quot;Apply gorountine runing &quot;)</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tmsg :&#x3D; &lt;-kv.applyCh</span><br><span class=\"line\">\t\t&#x2F;&#x2F;DPrintf(&quot;get apply msg from raftServer&quot;)</span><br><span class=\"line\">\t\tif msg.CommandValid &#123;</span><br><span class=\"line\">\t\t\tindex :&#x3D; msg.CommandIndex</span><br><span class=\"line\">\t\t\tif cmd, ok :&#x3D; msg.Command.(Op); ok &#123;</span><br><span class=\"line\">\t\t\t\tkv.mu.Lock()</span><br><span class=\"line\">                &#x2F;&#x2F; 对比单个客户端的序号，来减少重复的旧操作的更新操作</span><br><span class=\"line\">\t\t\t\tif kv.dupcheck(cmd.ClientId, cmd.Seq) &#123;</span><br><span class=\"line\">\t\t\t\t\tif cmd.Name &#x3D;&#x3D; PUT &#123;</span><br><span class=\"line\">\t\t\t\t\t\tkv.database[cmd.Key] &#x3D; cmd.Value</span><br><span class=\"line\">\t\t\t\t\t&#125; else if cmd.Name &#x3D;&#x3D; APPEND &#123;</span><br><span class=\"line\">\t\t\t\t\t\tif _, ok :&#x3D; kv.database[cmd.Key]; ok &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tkv.database[cmd.Key] +&#x3D; cmd.Value</span><br><span class=\"line\">\t\t\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tkv.database[cmd.Key] &#x3D; cmd.Value</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tkv.dup[cmd.ClientId] &#x3D; cmd.Seq</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres :&#x3D; Op&#123;cmd.Key, kv.database[cmd.Key], cmd.Name,</span><br><span class=\"line\">\t\t\t\t\tcmd.ClientId, cmd.Seq&#125;</span><br><span class=\"line\">\t\t\t\tch, ok :&#x3D; kv.chanResult[index]</span><br><span class=\"line\">\t\t\t\tif ok &#123;</span><br><span class=\"line\">\t\t\t\t\tselect &#123;</span><br><span class=\"line\">\t\t\t\t\tcase &lt;-ch:</span><br><span class=\"line\">\t\t\t\t\tdefault:</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tch &lt;- res</span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F;DPrintf(&quot;the cmd has been commited , push request return to chan&quot;)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tif kv.maxraftstate !&#x3D; -1 &amp;&amp; kv.rf.GetStateSize() &gt;&#x3D; kv.maxraftstate &amp;&amp; index &#x3D;&#x3D; kv.rf.GetCommitedIndex() &#123;</span><br><span class=\"line\">\t\t\t\t\tDPrintf(&quot;Do snapshot for over the maxraftstate&quot;)</span><br><span class=\"line\">\t\t\t\t\tkv.DoSnapShot(index)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tkv.LoadSnapShot(msg.Snapshot)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;  把OP传入到Raft共识层的函数</span><br><span class=\"line\">func(rf *Raft) StartCommand(cmd Op) (Err, string)&#123;</span><br><span class=\"line\">    index, _, isLeader :&#x3D; kv.rf.Start(cmd)</span><br><span class=\"line\">\t&#x2F;&#x2F;DPrintf(&quot;start command %s , client id is %d, key is %s, value is %s&quot;,</span><br><span class=\"line\">\t&#x2F;&#x2F;\tcmd.Name, cmd.ClientId, cmd.Key, cmd.Value)</span><br><span class=\"line\">\tif !isLeader &#123;</span><br><span class=\"line\">\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\t&#x2F;&#x2F;DPrintf(&quot;not leader &quot;)</span><br><span class=\"line\">\t\treturn ERRWrongLeader, &quot;&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tch :&#x3D; make(chan Op, 1)</span><br><span class=\"line\">\tkv.chanResult[index] &#x3D; ch</span><br><span class=\"line\">\tkv.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tdefer func() &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; After finish the task</span><br><span class=\"line\">\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\tdelete(kv.chanResult, index)</span><br><span class=\"line\">\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tselect &#123;</span><br><span class=\"line\">\tcase c :&#x3D; &lt;-ch:</span><br><span class=\"line\">\t\t&#x2F;&#x2F; this channel return is get data from ApplyRoutine</span><br><span class=\"line\">\t\tif kv.CheckSame(c, cmd) &#123;</span><br><span class=\"line\">\t\t\tresvalue :&#x3D; &quot;&quot;</span><br><span class=\"line\">\t\t\tif cmd.Name &#x3D;&#x3D; GET &#123;</span><br><span class=\"line\">\t\t\t\tresvalue &#x3D; c.Value</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn OK, resvalue</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tDPrintf(&quot;Leader has change, index %d op %s error&quot;, index, cmd.Name)</span><br><span class=\"line\">\t\t\treturn ERRWrongLeader, &quot;&quot;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\tcase &lt;-time.After(time.Duration(200) * time.Millisecond):</span><br><span class=\"line\">\t\tDPrintf(&quot;log get agree timeout, index is %d&quot;, index)</span><br><span class=\"line\">\t\treturn ERRTimeout, &quot;&quot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"日志压缩与快照\"   >\n          <a href=\"#日志压缩与快照\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>日志压缩与快照</h2>\n      <p>此处的快照与Raft本身的快照多了两个KVDatabase 特有的属性， database（保存的数据） 和 dup （客户端操作序号的记录）这两个属性</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (kv *KVServer) DoSnapShot(index int) &#123;</span><br><span class=\"line\">\tkv.rf.SaveSnapShot(index, kv.database, kv.dup)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 读取快照的函数</span><br><span class=\"line\">func (kv *KVServer) LoadSnapShot(snapshot []byte) &#123;</span><br><span class=\"line\">\tif snapshot &#x3D;&#x3D; nil || len(snapshot) &lt; 1 &#123;</span><br><span class=\"line\">\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\tkv.database &#x3D; make(map[string]string)</span><br><span class=\"line\">\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\treturn</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts :&#x3D; bytes.NewBuffer(snapshot)</span><br><span class=\"line\">\tdecoder :&#x3D; labgob.NewDecoder(s)</span><br><span class=\"line\">\tvar kvdb map[string]string</span><br><span class=\"line\">\tvar kvdup map[int64]int</span><br><span class=\"line\">\tif decoder.Decode(&amp;kvdb) !&#x3D; nil || decoder.Decode(&amp;kvdup) !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tDPrintf(&quot;server %d, Decode Snapshot error&quot;, kv.me)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\tdefer kv.mu.Unlock()</span><br><span class=\"line\">\t\tkv.database &#x3D; kvdb</span><br><span class=\"line\">\t\tkv.dup &#x3D; kvdup</span><br><span class=\"line\">\t\tDPrintf(&quot;msg snapshot db is %v, dup is %v&quot;, kvdb, kvdup)</span><br><span class=\"line\">\t\tDPrintf(&quot;server %d , load Snapshot success&quot;, kv.me)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>在本实验中，会触发日志保留的情况只是因为保存的Log&gt; maxraftstate。 </p>\n"},{"title":"MIT6.824 Lab4 实现及解析","date":"2019-08-29T12:05:38.000Z","_content":"\n<!-- ---\nlayout: post\ntitle: MIT6.824 Lab4 实现及解析\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab4 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n# 目录\n1. [实验目的](#Purpose)  \n2. [实验实现](#Implementation)  \n   2.1 [lab4-1](#2.1)  \n   2.2 [lab4-2](#2.2)  \n\n\n# <a id=\"Purpose\"><span class=\"toptitle\">实验目的</span></a>\n\nlab4需要实现两个模块:\n1. lab4-1 完成一个基于KvRaft的ShardMaster（可以理解为一个分片调度的存放的机器），但是写入的是配置而不是简单的K-v的值（但是与Lab3的实现相当相似）\n2. lab4-2 完成一个Sharding的kvRaft数据库（实现了Multi-raft)\n\n整体的实验架构是这样的\n\n<!-- ![lab4](/assets/img/posts/lab4.png) -->\n{% asset_img lab4.png lab4 %}\n\n架构图如上：\n一个值得注意的点是，各个KV数据库层之间不会直接相互通信，只是会通过Raft层来同步操作。    \n并且Client如果找到的不是Leader的节点，会直接放弃操作。然后请求集群内的下一个节点。    \nPS: 这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。    \n\n流程大概如下:\n1. Client发送请求到ShardMaster，查询Key的具体对应的分片在哪个组里面\n2. ShardMaster收到请求后，返回对应数据Key所在的组信息\n3. Client发送请求到对应分片的Raft Leader中\n4. Raft层同步成功后，会通过ApplyCh返回信号的KvDatabase\n5. 分片的KvDatabase对Client端做出应答（如果成功返回结果为成功，如果下面同步层失败导致超时，返回给客户端的结果为超时）\n\n## 副本与分片的问题\n在上面的架构图中，Multi-Raft已经实现了分片的副本的实现。\n\n分片： 只要是把数据进行划分（从大的数据变为只负责一部分的数据量）即是分片（在定义上面数据库的垂直划分和水平划分和此处的Key按键去Mod划分都是属于分片的操作，但是数据库表的划分和此处的Key的Mod划分不是在同一个层级上面的，理解不一样）  \n副本： 是指数据的重复的数量。但是一般只有一份的数据我们不会称之为单副本，而是称为0副本。副本一般是>=2才叫。副本的目的是为了冗余的问题。防止因为单点故障而导致数据全部的丢失。  \n\n# <a id=\"Implementation\"><span class=\"toptitle\">实验实现</span></a>\n\n## <a id=\"2.1\"><span class=\"secondtitle\">lab4-1</span></a>\n\n对比起与Lab3 的实现，它在这里需要支持的是Leave(), Move(), Join()， Query()的四种方法，因为分别对应节点的加入集群、退出集群、移动集群和集群配置查询的四种操作。\n所以基本实现的思路与Lab3是类似的。  \n\n```\ntype ShardMaster struct {\n\tmu      sync.Mutex\n\tme      int\n\trf      *raft.Raft\n\tapplyCh chan raft.ApplyMsg\n\t// Your data here.\n    // Lab3 此处是为database 是一个map[string]string 的结构\n\tconfigs    []Config // indexed by config num\n\tdup        map[int64]Result\n\tchanResult map[int]chan Result\n}\n\n```\n\n但是有一个比较重要的需求是，它需要完成一个shard 与 集群的绑定关系的变动，因为本来就是需要支持的目的就是数据随着Group的添加和变动来做到数据的均衡。  \n并且一个比较不同的是，对于重复的Get操作操作，Lab3采用的是直接返回Kv的值，但是在此处，因为Config的存放机制是一个数组（里面的顺序就是配置有效的顺序），因此需要把重复的读配置，返回一个复制好的配置。  \n\n## <a id=\"2.2\"><span class=\"secondtitle\">lab4-2</span></a>\n\n这里的实现是需要首先保证Kv的功能可以使用，然后保证在配置变动并且数据搬移完成之后，才能继续对外提供Kv的服务。并且需要保证节点挂掉之后可以读取会最新的状态下来\n\n总体流程：\n在提供KV服务的同时，需要把配置定时进行更新，并且实际应用新配置之前，必须保证数据迁移成功。因此实际上用到了3个单独的协程去分别做这几个工作\n1. 读取配置协程（定时向ShardMaster请求配置）\n2. 数据迁移的协程\n3. 应用数据同步的协程\n\n因为这个实验中的目的有三种，因此我们的消息类型也定义了三种\n1. 数据操作类型，与Lab3原来类似的OP类型（可以包含Get、Pull、Put、Append的操作）\n2. 配置更新类型，把Lab4-1的Config类型封装一层进行使用\n3. 真实的数据迁移类型，原因是：因为数据迁移的时候是两个RaftGroup的Leader相互通信，并且需要把原来数据KV格式同步进去到新的组的所有副本上面。因此单独分配一个数据类型来记录此类数据\n\n向ShardMaster读取配置的协程的实现\n```\nfunc (kv *ShardKV) ConfigUpdateRoutine() {\n\tfor {\n\t\tkv.mu.Lock()\n\t\tcurConfigNum := kv.myconfig[0].Num\n\t\tkv.mu.Unlock()\n        // 此处Query带上当前版本加1的原因，防止查询到的配置不正确，导致分片的节点之前一直无法达成配置上共识\n\t\tconfig := kv.mck.Query(curConfigNum + 1)\n\t\t//DPrintf(\"get newConfig from SM group is %v, shard is %v\", config.Groups, config.Shards)\n\t\tkv.mu.Lock()\n\t\tif config.Num == kv.myconfig[0].Num+1 {\n\t\t\t// update with static NewConfig\n\t\t\tnewConfig := kv.makeEmptyConfig()\n\t\t\tkv.CopyConfig(&config, &newConfig)\n\t\t\tif _, isLeader := kv.rf.GetState(); isLeader {\n\t\t\t\tcfg := Cfg{newConfig, int64(kv.gid), kv.myconfig[0].Num}\n\t\t\t\tkv.rf.Start(cfg)\n\t\t\t\tDPrintf(\"Config: group %d-%d is start config %d into consueum\",\n\t\t\t\t\tkv.gid, kv.me, cfg.NewConfig.Num)\n\t\t\t\t//index, _, isleader := kv.rf.Start(cfg)\n\t\t\t\t//DPrintf(\"))))) server %d gid %d Start cfg， index is %d, isleader is %t, kv is %v\",\n\t\t\t\t//\tkv.me, kv.gid, index, isleader, kv.database)\n\t\t\t}\n\t\t} \n\t\tkv.mu.Unlock()\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n}\n\n```\n\n修改自己需要发送和接受Shard的配置部分的代码\n```\ncase Cfg:\n    if kv.CfgDupCheck(cmd.ClientId, cmd.Seq) {\n        kv.SwitchConfig(cmd)\n        if kv.CheckMigrateDone() {\n            // if migrate done, use new config, if not, do nothing to avoid replying the old group replied\n            kv.myconfig[0] = kv.myconfig[1]\n            //DPrintf(\"group %d-%d is applied new config , shard is %v, kv is %v\", kv.gid, kv.me, kv.myshards, kv.database)\n        }\n        kv.cfgdup[cmd.ClientId] = cmd.Seq\n        if kv.maxraftstate != -1 {\n            kv.SaveSnapshot(index)\n        }\n    }\n\nfunc (kv *ShardKV) SwitchConfig(newcfg Cfg) {\n\tif newcfg.NewConfig.Num == kv.myconfig[0].Num+1 {\n\t\tif kv.myconfig[0].Num != 0 {\n\t\t\tkv.GenShardChangeList(newcfg)\n\t\t} else if kv.myconfig[0].Num == 0 {\n\t\t\tfor i := 0; i < shardmaster.NShards; i++ {\n\t\t\t\tif newcfg.NewConfig.Shards[i] == kv.gid {\n\t\t\t\t\tkv.myshards[i] = 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnewc := kv.makeEmptyConfig()\n\t\tkv.CopyConfig(&newcfg.NewConfig, &newc)\n\t\tkv.myconfig[1] = newc\n\t}\n}\n\n// 此函数是用于生成需要发送和修改那些部分的参数\nfunc (kv *ShardKV) GenShardChangeList(newcfg Cfg) {\n\tfor i := 0; i < shardmaster.NShards; i++ {\n\t\tif kv.myconfig[0].Shards[i] == kv.gid && newcfg.NewConfig.Shards[i] != kv.gid {\n\t\t\t//need to send\n\t\t\tkv.needsend[i] = newcfg.NewConfig.Shards[i]\n\t\t}\n\t\tif kv.myconfig[0].Shards[i] != kv.gid && newcfg.NewConfig.Shards[i] == kv.gid {\n\t\t\t//need to recv\n\t\t\t_, ok := kv.needrecv[kv.myconfig[0].Shards[i]]\n\t\t\tif !ok {\n\t\t\t\tkv.needrecv[kv.myconfig[0].Shards[i]] = make([]int, 0)\n\t\t\t}\n\t\t\tkv.needrecv[kv.myconfig[0].Shards[i]] = append(kv.needrecv[kv.myconfig[0].Shards[i]], i)\n\t\t}\n\t}\n\tDPrintf(\"!!! group %d-%d, new config need to send is %v, need to receive is %v\", kv.gid, kv.me, kv.needsend, kv.needrecv)\n}\n```\n\n\n获取迁移的数据部分  \n数据迁移的副本是只要检测到相关属性的变化之后（感知到数据的变化）后，新的数据所归属的Leader就会与旧Leader继续RPC的Pull调用， 去获取它的Database和DUP的部分  \n当拉取到配置了之后，就会把数据变成日志应用到状态中，就可以实现分片数据的副本的性质。\n```\nfunc (kv *ShardKV) MigrationRoutine() {\n\tfor {\n\t\tif _, isLeader := kv.rf.GetState(); isLeader {\n\t\t\tkv.mu.Lock()\n\t\t\tfor k, v := range kv.needrecv {\n\t\t\t\t//DPrintf(\"group %d-%d needrecv \")\n\t\t\t\tneedshard := make([]int, 0)\n\t\t\t\tfor i := 0; i < len(v); i++ {\n\t\t\t\t\tneedshard = append(needshard, v[i])\n\t\t\t\t}\n\n\t\t\t\targs := PullArgs{Shard: needshard, ClientId: int64(kv.gid), Seq: kv.myconfig[0].Num}\n\t\t\t\tgo func(mgid int, arg *PullArgs) {\n\t\t\t\t\tservers := kv.myconfig[0].Groups[mgid]\n\t\t\t\t\tDPrintf(\"Migrate: group %d-%d get Gid %d Servers is %v\",\n\t\t\t\t\t\tkv.gid, kv.me, mgid, servers)\n\t\t\t\t\tfor {\n\t\t\t\t\t\tfor _, si := range servers {\n\t\t\t\t\t\t\treply := PullReply{}\n\t\t\t\t\t\t\tsrv := kv.make_end(si)\n\t\t\t\t\t\t\tDPrintf(\"group %d-%d start call to gid %d\", kv.gid, kv.me, mgid)\n                            // 由GroupA\n\t\t\t\t\t\t\tok := srv.Call(\"ShardKV.Pull\", arg, &reply)\n\t\t\t\t\t\t\t//DPrintf(\"Migrate: group %d-%d  calling for server %v rpc pull, result is %t\",\n\t\t\t\t\t\t\t//\t    kv.gid, kv.me, si, ok)\n\t\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\t\tDPrintf(\"Migrate Failed: group %d-%d  calling for server %v rpc pull, result is %t\",\n\t\t\t\t\t\t\t\t\tkv.gid, kv.me, si, ok)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ok && reply.WrongLeader == false {\n\t\t\t\t\t\t\t\tif reply.Err == ErrNeedWait {\n\t\t\t\t\t\t\t\t\tDPrintf(\"Migrate: waiting server %v to pull new config from SM\", si)\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif _, isleader := kv.rf.GetState(); isleader {\n\t\t\t\t\t\t\t\t\tnewmapkv := make(map[string]string)\n\t\t\t\t\t\t\t\t\tfor k, v := range reply.MapKV {\n\t\t\t\t\t\t\t\t\t\tnewmapkv[k] = v\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tvar newdup [shardmaster.NShards]map[int64]int\n\t\t\t\t\t\t\t\t\tfor i := 0; i < shardmaster.NShards; i++ {\n\t\t\t\t\t\t\t\t\t\tnewdup[i] = make(map[int64]int)\n\t\t\t\t\t\t\t\t\t\tfor k, v := range reply.ShardDup[i] {\n\t\t\t\t\t\t\t\t\t\t\tnewdup[i][k] = v\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmig := Migrate{newmapkv, newdup, arg.Seq, mgid}\n\t\t\t\t\t\t\t\t\tkv.mu.Lock()\n\t\t\t\t\t\t\t\t\t// this is how partition data can be repliacated\n\t\t\t\t\t\t\t\t\tkv.rf.Start(mig)\n\t\t\t\t\t\t\t\t\tDPrintf(\"Migrate: group %d-%d start migrate the data pulled from %d\", kv.gid, kv.me, mgid)\n\t\t\t\t\t\t\t\t\tkv.mu.Unlock()\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDPrintf(\"Migrate Failed: group %d-%d call %d-%v meet wrong leader\",\n\t\t\t\t\t\t\t\t\tkv.gid, kv.me, mgid, si)\n\t\t\t\t\t\t\t\tDPrintf(\"!!!server is %v\", servers)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}(k, &args)\n\t\t\t}\n\t\t\tkv.mu.Unlock()\n\t\t}\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n}\n\n```\n\n非Leader节点同步KV数据的方法\n```\ncase Migrate:\n    if kv.MigrateDupCheck(cmd.Gid, cmd.Num) {\n        //DPrintf(\"group %d-%d apply the migrate data from %d and config num %d\", kv.gid, kv.me, cmd.Gid, cmd.Num)\n        //DPrintf(\"group %d-%d database before migrate is %v\", kv.gid, kv.me, kv.database)\n        for k, v := range cmd.MapKV {\n            kv.database[k] = v\n        }\n        //DPrintf(\"group %d-%d database after migrate is %v\", kv.gid, kv.me, kv.database)\n        for i := 0; i < shardmaster.NShards; i++ {\n            for k, v := range cmd.ShardDup[i] {\n                kv.dup[i][k] = v\n            }\n        }\n        for i := 0; i < len(kv.needrecv[cmd.Gid]); i++ {\n            kv.myshards[kv.needrecv[cmd.Gid][i]] = 1\n        }\n        delete(kv.needrecv, cmd.Gid)\n        if kv.CheckMigrateDone() {\n            kv.myconfig[0] = kv.myconfig[1]\n            DPrintf(\"Migrate: group %d-%d successful switch to config %d\", kv.gid, kv.me, kv.myconfig[0].Num)\n            //DPrintf(\"group %d-%d is applied new config , shard is %v\", kv.gid, kv.me, kv.myshards)\n        }\n        kv.migratedup[cmd.Gid] = cmd.Num\n        if kv.maxraftstate != -1 {\n            kv.SaveSnapshot(index)\n        }\n    }\n```","source":"_posts/raft-lab-4.md","raw":"---\ntitle: MIT6.824 Lab4 实现及解析\ndate: 2019-08-29 20:05:38\ntags: distributed-system\n---\n\n<!-- ---\nlayout: post\ntitle: MIT6.824 Lab4 实现及解析\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab4 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n# 目录\n1. [实验目的](#Purpose)  \n2. [实验实现](#Implementation)  \n   2.1 [lab4-1](#2.1)  \n   2.2 [lab4-2](#2.2)  \n\n\n# <a id=\"Purpose\"><span class=\"toptitle\">实验目的</span></a>\n\nlab4需要实现两个模块:\n1. lab4-1 完成一个基于KvRaft的ShardMaster（可以理解为一个分片调度的存放的机器），但是写入的是配置而不是简单的K-v的值（但是与Lab3的实现相当相似）\n2. lab4-2 完成一个Sharding的kvRaft数据库（实现了Multi-raft)\n\n整体的实验架构是这样的\n\n<!-- ![lab4](/assets/img/posts/lab4.png) -->\n{% asset_img lab4.png lab4 %}\n\n架构图如上：\n一个值得注意的点是，各个KV数据库层之间不会直接相互通信，只是会通过Raft层来同步操作。    \n并且Client如果找到的不是Leader的节点，会直接放弃操作。然后请求集群内的下一个节点。    \nPS: 这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。    \n\n流程大概如下:\n1. Client发送请求到ShardMaster，查询Key的具体对应的分片在哪个组里面\n2. ShardMaster收到请求后，返回对应数据Key所在的组信息\n3. Client发送请求到对应分片的Raft Leader中\n4. Raft层同步成功后，会通过ApplyCh返回信号的KvDatabase\n5. 分片的KvDatabase对Client端做出应答（如果成功返回结果为成功，如果下面同步层失败导致超时，返回给客户端的结果为超时）\n\n## 副本与分片的问题\n在上面的架构图中，Multi-Raft已经实现了分片的副本的实现。\n\n分片： 只要是把数据进行划分（从大的数据变为只负责一部分的数据量）即是分片（在定义上面数据库的垂直划分和水平划分和此处的Key按键去Mod划分都是属于分片的操作，但是数据库表的划分和此处的Key的Mod划分不是在同一个层级上面的，理解不一样）  \n副本： 是指数据的重复的数量。但是一般只有一份的数据我们不会称之为单副本，而是称为0副本。副本一般是>=2才叫。副本的目的是为了冗余的问题。防止因为单点故障而导致数据全部的丢失。  \n\n# <a id=\"Implementation\"><span class=\"toptitle\">实验实现</span></a>\n\n## <a id=\"2.1\"><span class=\"secondtitle\">lab4-1</span></a>\n\n对比起与Lab3 的实现，它在这里需要支持的是Leave(), Move(), Join()， Query()的四种方法，因为分别对应节点的加入集群、退出集群、移动集群和集群配置查询的四种操作。\n所以基本实现的思路与Lab3是类似的。  \n\n```\ntype ShardMaster struct {\n\tmu      sync.Mutex\n\tme      int\n\trf      *raft.Raft\n\tapplyCh chan raft.ApplyMsg\n\t// Your data here.\n    // Lab3 此处是为database 是一个map[string]string 的结构\n\tconfigs    []Config // indexed by config num\n\tdup        map[int64]Result\n\tchanResult map[int]chan Result\n}\n\n```\n\n但是有一个比较重要的需求是，它需要完成一个shard 与 集群的绑定关系的变动，因为本来就是需要支持的目的就是数据随着Group的添加和变动来做到数据的均衡。  \n并且一个比较不同的是，对于重复的Get操作操作，Lab3采用的是直接返回Kv的值，但是在此处，因为Config的存放机制是一个数组（里面的顺序就是配置有效的顺序），因此需要把重复的读配置，返回一个复制好的配置。  \n\n## <a id=\"2.2\"><span class=\"secondtitle\">lab4-2</span></a>\n\n这里的实现是需要首先保证Kv的功能可以使用，然后保证在配置变动并且数据搬移完成之后，才能继续对外提供Kv的服务。并且需要保证节点挂掉之后可以读取会最新的状态下来\n\n总体流程：\n在提供KV服务的同时，需要把配置定时进行更新，并且实际应用新配置之前，必须保证数据迁移成功。因此实际上用到了3个单独的协程去分别做这几个工作\n1. 读取配置协程（定时向ShardMaster请求配置）\n2. 数据迁移的协程\n3. 应用数据同步的协程\n\n因为这个实验中的目的有三种，因此我们的消息类型也定义了三种\n1. 数据操作类型，与Lab3原来类似的OP类型（可以包含Get、Pull、Put、Append的操作）\n2. 配置更新类型，把Lab4-1的Config类型封装一层进行使用\n3. 真实的数据迁移类型，原因是：因为数据迁移的时候是两个RaftGroup的Leader相互通信，并且需要把原来数据KV格式同步进去到新的组的所有副本上面。因此单独分配一个数据类型来记录此类数据\n\n向ShardMaster读取配置的协程的实现\n```\nfunc (kv *ShardKV) ConfigUpdateRoutine() {\n\tfor {\n\t\tkv.mu.Lock()\n\t\tcurConfigNum := kv.myconfig[0].Num\n\t\tkv.mu.Unlock()\n        // 此处Query带上当前版本加1的原因，防止查询到的配置不正确，导致分片的节点之前一直无法达成配置上共识\n\t\tconfig := kv.mck.Query(curConfigNum + 1)\n\t\t//DPrintf(\"get newConfig from SM group is %v, shard is %v\", config.Groups, config.Shards)\n\t\tkv.mu.Lock()\n\t\tif config.Num == kv.myconfig[0].Num+1 {\n\t\t\t// update with static NewConfig\n\t\t\tnewConfig := kv.makeEmptyConfig()\n\t\t\tkv.CopyConfig(&config, &newConfig)\n\t\t\tif _, isLeader := kv.rf.GetState(); isLeader {\n\t\t\t\tcfg := Cfg{newConfig, int64(kv.gid), kv.myconfig[0].Num}\n\t\t\t\tkv.rf.Start(cfg)\n\t\t\t\tDPrintf(\"Config: group %d-%d is start config %d into consueum\",\n\t\t\t\t\tkv.gid, kv.me, cfg.NewConfig.Num)\n\t\t\t\t//index, _, isleader := kv.rf.Start(cfg)\n\t\t\t\t//DPrintf(\"))))) server %d gid %d Start cfg， index is %d, isleader is %t, kv is %v\",\n\t\t\t\t//\tkv.me, kv.gid, index, isleader, kv.database)\n\t\t\t}\n\t\t} \n\t\tkv.mu.Unlock()\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n}\n\n```\n\n修改自己需要发送和接受Shard的配置部分的代码\n```\ncase Cfg:\n    if kv.CfgDupCheck(cmd.ClientId, cmd.Seq) {\n        kv.SwitchConfig(cmd)\n        if kv.CheckMigrateDone() {\n            // if migrate done, use new config, if not, do nothing to avoid replying the old group replied\n            kv.myconfig[0] = kv.myconfig[1]\n            //DPrintf(\"group %d-%d is applied new config , shard is %v, kv is %v\", kv.gid, kv.me, kv.myshards, kv.database)\n        }\n        kv.cfgdup[cmd.ClientId] = cmd.Seq\n        if kv.maxraftstate != -1 {\n            kv.SaveSnapshot(index)\n        }\n    }\n\nfunc (kv *ShardKV) SwitchConfig(newcfg Cfg) {\n\tif newcfg.NewConfig.Num == kv.myconfig[0].Num+1 {\n\t\tif kv.myconfig[0].Num != 0 {\n\t\t\tkv.GenShardChangeList(newcfg)\n\t\t} else if kv.myconfig[0].Num == 0 {\n\t\t\tfor i := 0; i < shardmaster.NShards; i++ {\n\t\t\t\tif newcfg.NewConfig.Shards[i] == kv.gid {\n\t\t\t\t\tkv.myshards[i] = 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnewc := kv.makeEmptyConfig()\n\t\tkv.CopyConfig(&newcfg.NewConfig, &newc)\n\t\tkv.myconfig[1] = newc\n\t}\n}\n\n// 此函数是用于生成需要发送和修改那些部分的参数\nfunc (kv *ShardKV) GenShardChangeList(newcfg Cfg) {\n\tfor i := 0; i < shardmaster.NShards; i++ {\n\t\tif kv.myconfig[0].Shards[i] == kv.gid && newcfg.NewConfig.Shards[i] != kv.gid {\n\t\t\t//need to send\n\t\t\tkv.needsend[i] = newcfg.NewConfig.Shards[i]\n\t\t}\n\t\tif kv.myconfig[0].Shards[i] != kv.gid && newcfg.NewConfig.Shards[i] == kv.gid {\n\t\t\t//need to recv\n\t\t\t_, ok := kv.needrecv[kv.myconfig[0].Shards[i]]\n\t\t\tif !ok {\n\t\t\t\tkv.needrecv[kv.myconfig[0].Shards[i]] = make([]int, 0)\n\t\t\t}\n\t\t\tkv.needrecv[kv.myconfig[0].Shards[i]] = append(kv.needrecv[kv.myconfig[0].Shards[i]], i)\n\t\t}\n\t}\n\tDPrintf(\"!!! group %d-%d, new config need to send is %v, need to receive is %v\", kv.gid, kv.me, kv.needsend, kv.needrecv)\n}\n```\n\n\n获取迁移的数据部分  \n数据迁移的副本是只要检测到相关属性的变化之后（感知到数据的变化）后，新的数据所归属的Leader就会与旧Leader继续RPC的Pull调用， 去获取它的Database和DUP的部分  \n当拉取到配置了之后，就会把数据变成日志应用到状态中，就可以实现分片数据的副本的性质。\n```\nfunc (kv *ShardKV) MigrationRoutine() {\n\tfor {\n\t\tif _, isLeader := kv.rf.GetState(); isLeader {\n\t\t\tkv.mu.Lock()\n\t\t\tfor k, v := range kv.needrecv {\n\t\t\t\t//DPrintf(\"group %d-%d needrecv \")\n\t\t\t\tneedshard := make([]int, 0)\n\t\t\t\tfor i := 0; i < len(v); i++ {\n\t\t\t\t\tneedshard = append(needshard, v[i])\n\t\t\t\t}\n\n\t\t\t\targs := PullArgs{Shard: needshard, ClientId: int64(kv.gid), Seq: kv.myconfig[0].Num}\n\t\t\t\tgo func(mgid int, arg *PullArgs) {\n\t\t\t\t\tservers := kv.myconfig[0].Groups[mgid]\n\t\t\t\t\tDPrintf(\"Migrate: group %d-%d get Gid %d Servers is %v\",\n\t\t\t\t\t\tkv.gid, kv.me, mgid, servers)\n\t\t\t\t\tfor {\n\t\t\t\t\t\tfor _, si := range servers {\n\t\t\t\t\t\t\treply := PullReply{}\n\t\t\t\t\t\t\tsrv := kv.make_end(si)\n\t\t\t\t\t\t\tDPrintf(\"group %d-%d start call to gid %d\", kv.gid, kv.me, mgid)\n                            // 由GroupA\n\t\t\t\t\t\t\tok := srv.Call(\"ShardKV.Pull\", arg, &reply)\n\t\t\t\t\t\t\t//DPrintf(\"Migrate: group %d-%d  calling for server %v rpc pull, result is %t\",\n\t\t\t\t\t\t\t//\t    kv.gid, kv.me, si, ok)\n\t\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\t\tDPrintf(\"Migrate Failed: group %d-%d  calling for server %v rpc pull, result is %t\",\n\t\t\t\t\t\t\t\t\tkv.gid, kv.me, si, ok)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ok && reply.WrongLeader == false {\n\t\t\t\t\t\t\t\tif reply.Err == ErrNeedWait {\n\t\t\t\t\t\t\t\t\tDPrintf(\"Migrate: waiting server %v to pull new config from SM\", si)\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif _, isleader := kv.rf.GetState(); isleader {\n\t\t\t\t\t\t\t\t\tnewmapkv := make(map[string]string)\n\t\t\t\t\t\t\t\t\tfor k, v := range reply.MapKV {\n\t\t\t\t\t\t\t\t\t\tnewmapkv[k] = v\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tvar newdup [shardmaster.NShards]map[int64]int\n\t\t\t\t\t\t\t\t\tfor i := 0; i < shardmaster.NShards; i++ {\n\t\t\t\t\t\t\t\t\t\tnewdup[i] = make(map[int64]int)\n\t\t\t\t\t\t\t\t\t\tfor k, v := range reply.ShardDup[i] {\n\t\t\t\t\t\t\t\t\t\t\tnewdup[i][k] = v\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmig := Migrate{newmapkv, newdup, arg.Seq, mgid}\n\t\t\t\t\t\t\t\t\tkv.mu.Lock()\n\t\t\t\t\t\t\t\t\t// this is how partition data can be repliacated\n\t\t\t\t\t\t\t\t\tkv.rf.Start(mig)\n\t\t\t\t\t\t\t\t\tDPrintf(\"Migrate: group %d-%d start migrate the data pulled from %d\", kv.gid, kv.me, mgid)\n\t\t\t\t\t\t\t\t\tkv.mu.Unlock()\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDPrintf(\"Migrate Failed: group %d-%d call %d-%v meet wrong leader\",\n\t\t\t\t\t\t\t\t\tkv.gid, kv.me, mgid, si)\n\t\t\t\t\t\t\t\tDPrintf(\"!!!server is %v\", servers)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}(k, &args)\n\t\t\t}\n\t\t\tkv.mu.Unlock()\n\t\t}\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n}\n\n```\n\n非Leader节点同步KV数据的方法\n```\ncase Migrate:\n    if kv.MigrateDupCheck(cmd.Gid, cmd.Num) {\n        //DPrintf(\"group %d-%d apply the migrate data from %d and config num %d\", kv.gid, kv.me, cmd.Gid, cmd.Num)\n        //DPrintf(\"group %d-%d database before migrate is %v\", kv.gid, kv.me, kv.database)\n        for k, v := range cmd.MapKV {\n            kv.database[k] = v\n        }\n        //DPrintf(\"group %d-%d database after migrate is %v\", kv.gid, kv.me, kv.database)\n        for i := 0; i < shardmaster.NShards; i++ {\n            for k, v := range cmd.ShardDup[i] {\n                kv.dup[i][k] = v\n            }\n        }\n        for i := 0; i < len(kv.needrecv[cmd.Gid]); i++ {\n            kv.myshards[kv.needrecv[cmd.Gid][i]] = 1\n        }\n        delete(kv.needrecv, cmd.Gid)\n        if kv.CheckMigrateDone() {\n            kv.myconfig[0] = kv.myconfig[1]\n            DPrintf(\"Migrate: group %d-%d successful switch to config %d\", kv.gid, kv.me, kv.myconfig[0].Num)\n            //DPrintf(\"group %d-%d is applied new config , shard is %v\", kv.gid, kv.me, kv.myshards)\n        }\n        kv.migratedup[cmd.Gid] = cmd.Num\n        if kv.maxraftstate != -1 {\n            kv.SaveSnapshot(index)\n        }\n    }\n```","slug":"raft-lab-4","published":1,"updated":"2021-01-21T07:28:28.088Z","_id":"ckk6irarh000dk9i5944l19ix","comments":1,"layout":"post","photos":[],"link":"","content":"<!-- ---\nlayout: post\ntitle: MIT6.824 Lab4 实现及解析\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab4 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#Purpose\">实验目的</a>  </li>\n<li><a href=\"#Implementation\">实验实现</a><br>2.1 <a href=\"#2.1\">lab4-1</a><br>2.2 <a href=\"#2.2\">lab4-2</a>  </li>\n</ol>\n\n        <h1 id=\"实验目的\"   >\n          <a href=\"#实验目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实验目的</h1>\n      <p>lab4需要实现两个模块:</p>\n<ol>\n<li>lab4-1 完成一个基于KvRaft的ShardMaster（可以理解为一个分片调度的存放的机器），但是写入的是配置而不是简单的K-v的值（但是与Lab3的实现相当相似）</li>\n<li>lab4-2 完成一个Sharding的kvRaft数据库（实现了Multi-raft)</li>\n</ol>\n<p>整体的实验架构是这样的</p>\n<!-- ![lab4](/assets/img/posts/lab4.png) -->\n<img src=\"/2019/08/29/raft-lab-4/lab4.png\" class=\"\" title=\"lab4\">\n\n<p>架构图如上：<br>一个值得注意的点是，各个KV数据库层之间不会直接相互通信，只是会通过Raft层来同步操作。<br>并且Client如果找到的不是Leader的节点，会直接放弃操作。然后请求集群内的下一个节点。<br>PS: 这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。    </p>\n<p>流程大概如下:</p>\n<ol>\n<li>Client发送请求到ShardMaster，查询Key的具体对应的分片在哪个组里面</li>\n<li>ShardMaster收到请求后，返回对应数据Key所在的组信息</li>\n<li>Client发送请求到对应分片的Raft Leader中</li>\n<li>Raft层同步成功后，会通过ApplyCh返回信号的KvDatabase</li>\n<li>分片的KvDatabase对Client端做出应答（如果成功返回结果为成功，如果下面同步层失败导致超时，返回给客户端的结果为超时）</li>\n</ol>\n\n        <h2 id=\"副本与分片的问题\"   >\n          <a href=\"#副本与分片的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>副本与分片的问题</h2>\n      <p>在上面的架构图中，Multi-Raft已经实现了分片的副本的实现。</p>\n<p>分片： 只要是把数据进行划分（从大的数据变为只负责一部分的数据量）即是分片（在定义上面数据库的垂直划分和水平划分和此处的Key按键去Mod划分都是属于分片的操作，但是数据库表的划分和此处的Key的Mod划分不是在同一个层级上面的，理解不一样）<br>副本： 是指数据的重复的数量。但是一般只有一份的数据我们不会称之为单副本，而是称为0副本。副本一般是&gt;=2才叫。副本的目的是为了冗余的问题。防止因为单点故障而导致数据全部的丢失。  </p>\n\n        <h1 id=\"实验实现\"   >\n          <a href=\"#实验实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实验实现</h1>\n      \n        <h2 id=\"lab4-1\"   >\n          <a href=\"#lab4-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>lab4-1</h2>\n      <p>对比起与Lab3 的实现，它在这里需要支持的是Leave(), Move(), Join()， Query()的四种方法，因为分别对应节点的加入集群、退出集群、移动集群和集群配置查询的四种操作。<br>所以基本实现的思路与Lab3是类似的。  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ShardMaster struct &#123;</span><br><span class=\"line\">\tmu      sync.Mutex</span><br><span class=\"line\">\tme      int</span><br><span class=\"line\">\trf      *raft.Raft</span><br><span class=\"line\">\tapplyCh chan raft.ApplyMsg</span><br><span class=\"line\">\t&#x2F;&#x2F; Your data here.</span><br><span class=\"line\">    &#x2F;&#x2F; Lab3 此处是为database 是一个map[string]string 的结构</span><br><span class=\"line\">\tconfigs    []Config &#x2F;&#x2F; indexed by config num</span><br><span class=\"line\">\tdup        map[int64]Result</span><br><span class=\"line\">\tchanResult map[int]chan Result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>但是有一个比较重要的需求是，它需要完成一个shard 与 集群的绑定关系的变动，因为本来就是需要支持的目的就是数据随着Group的添加和变动来做到数据的均衡。<br>并且一个比较不同的是，对于重复的Get操作操作，Lab3采用的是直接返回Kv的值，但是在此处，因为Config的存放机制是一个数组（里面的顺序就是配置有效的顺序），因此需要把重复的读配置，返回一个复制好的配置。  </p>\n\n        <h2 id=\"lab4-2\"   >\n          <a href=\"#lab4-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>lab4-2</h2>\n      <p>这里的实现是需要首先保证Kv的功能可以使用，然后保证在配置变动并且数据搬移完成之后，才能继续对外提供Kv的服务。并且需要保证节点挂掉之后可以读取会最新的状态下来</p>\n<p>总体流程：<br>在提供KV服务的同时，需要把配置定时进行更新，并且实际应用新配置之前，必须保证数据迁移成功。因此实际上用到了3个单独的协程去分别做这几个工作</p>\n<ol>\n<li>读取配置协程（定时向ShardMaster请求配置）</li>\n<li>数据迁移的协程</li>\n<li>应用数据同步的协程</li>\n</ol>\n<p>因为这个实验中的目的有三种，因此我们的消息类型也定义了三种</p>\n<ol>\n<li>数据操作类型，与Lab3原来类似的OP类型（可以包含Get、Pull、Put、Append的操作）</li>\n<li>配置更新类型，把Lab4-1的Config类型封装一层进行使用</li>\n<li>真实的数据迁移类型，原因是：因为数据迁移的时候是两个RaftGroup的Leader相互通信，并且需要把原来数据KV格式同步进去到新的组的所有副本上面。因此单独分配一个数据类型来记录此类数据</li>\n</ol>\n<p>向ShardMaster读取配置的协程的实现</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (kv *ShardKV) ConfigUpdateRoutine() &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\tcurConfigNum :&#x3D; kv.myconfig[0].Num</span><br><span class=\"line\">\t\tkv.mu.Unlock()</span><br><span class=\"line\">        &#x2F;&#x2F; 此处Query带上当前版本加1的原因，防止查询到的配置不正确，导致分片的节点之前一直无法达成配置上共识</span><br><span class=\"line\">\t\tconfig :&#x3D; kv.mck.Query(curConfigNum + 1)</span><br><span class=\"line\">\t\t&#x2F;&#x2F;DPrintf(&quot;get newConfig from SM group is %v, shard is %v&quot;, config.Groups, config.Shards)</span><br><span class=\"line\">\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\tif config.Num &#x3D;&#x3D; kv.myconfig[0].Num+1 &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; update with static NewConfig</span><br><span class=\"line\">\t\t\tnewConfig :&#x3D; kv.makeEmptyConfig()</span><br><span class=\"line\">\t\t\tkv.CopyConfig(&amp;config, &amp;newConfig)</span><br><span class=\"line\">\t\t\tif _, isLeader :&#x3D; kv.rf.GetState(); isLeader &#123;</span><br><span class=\"line\">\t\t\t\tcfg :&#x3D; Cfg&#123;newConfig, int64(kv.gid), kv.myconfig[0].Num&#125;</span><br><span class=\"line\">\t\t\t\tkv.rf.Start(cfg)</span><br><span class=\"line\">\t\t\t\tDPrintf(&quot;Config: group %d-%d is start config %d into consueum&quot;,</span><br><span class=\"line\">\t\t\t\t\tkv.gid, kv.me, cfg.NewConfig.Num)</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F;index, _, isleader :&#x3D; kv.rf.Start(cfg)</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F;DPrintf(&quot;))))) server %d gid %d Start cfg， index is %d, isleader is %t, kv is %v&quot;,</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F;\tkv.me, kv.gid, index, isleader, kv.database)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\ttime.Sleep(100 * time.Millisecond)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>修改自己需要发送和接受Shard的配置部分的代码</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case Cfg:</span><br><span class=\"line\">    if kv.CfgDupCheck(cmd.ClientId, cmd.Seq) &#123;</span><br><span class=\"line\">        kv.SwitchConfig(cmd)</span><br><span class=\"line\">        if kv.CheckMigrateDone() &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; if migrate done, use new config, if not, do nothing to avoid replying the old group replied</span><br><span class=\"line\">            kv.myconfig[0] &#x3D; kv.myconfig[1]</span><br><span class=\"line\">            &#x2F;&#x2F;DPrintf(&quot;group %d-%d is applied new config , shard is %v, kv is %v&quot;, kv.gid, kv.me, kv.myshards, kv.database)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        kv.cfgdup[cmd.ClientId] &#x3D; cmd.Seq</span><br><span class=\"line\">        if kv.maxraftstate !&#x3D; -1 &#123;</span><br><span class=\"line\">            kv.SaveSnapshot(index)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (kv *ShardKV) SwitchConfig(newcfg Cfg) &#123;</span><br><span class=\"line\">\tif newcfg.NewConfig.Num &#x3D;&#x3D; kv.myconfig[0].Num+1 &#123;</span><br><span class=\"line\">\t\tif kv.myconfig[0].Num !&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\tkv.GenShardChangeList(newcfg)</span><br><span class=\"line\">\t\t&#125; else if kv.myconfig[0].Num &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\tfor i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class=\"line\">\t\t\t\tif newcfg.NewConfig.Shards[i] &#x3D;&#x3D; kv.gid &#123;</span><br><span class=\"line\">\t\t\t\t\tkv.myshards[i] &#x3D; 1</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnewc :&#x3D; kv.makeEmptyConfig()</span><br><span class=\"line\">\t\tkv.CopyConfig(&amp;newcfg.NewConfig, &amp;newc)</span><br><span class=\"line\">\t\tkv.myconfig[1] &#x3D; newc</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 此函数是用于生成需要发送和修改那些部分的参数</span><br><span class=\"line\">func (kv *ShardKV) GenShardChangeList(newcfg Cfg) &#123;</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class=\"line\">\t\tif kv.myconfig[0].Shards[i] &#x3D;&#x3D; kv.gid &amp;&amp; newcfg.NewConfig.Shards[i] !&#x3D; kv.gid &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F;need to send</span><br><span class=\"line\">\t\t\tkv.needsend[i] &#x3D; newcfg.NewConfig.Shards[i]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif kv.myconfig[0].Shards[i] !&#x3D; kv.gid &amp;&amp; newcfg.NewConfig.Shards[i] &#x3D;&#x3D; kv.gid &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F;need to recv</span><br><span class=\"line\">\t\t\t_, ok :&#x3D; kv.needrecv[kv.myconfig[0].Shards[i]]</span><br><span class=\"line\">\t\t\tif !ok &#123;</span><br><span class=\"line\">\t\t\t\tkv.needrecv[kv.myconfig[0].Shards[i]] &#x3D; make([]int, 0)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tkv.needrecv[kv.myconfig[0].Shards[i]] &#x3D; append(kv.needrecv[kv.myconfig[0].Shards[i]], i)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tDPrintf(&quot;!!! group %d-%d, new config need to send is %v, need to receive is %v&quot;, kv.gid, kv.me, kv.needsend, kv.needrecv)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>获取迁移的数据部分<br>数据迁移的副本是只要检测到相关属性的变化之后（感知到数据的变化）后，新的数据所归属的Leader就会与旧Leader继续RPC的Pull调用， 去获取它的Database和DUP的部分<br>当拉取到配置了之后，就会把数据变成日志应用到状态中，就可以实现分片数据的副本的性质。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (kv *ShardKV) MigrationRoutine() &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tif _, isLeader :&#x3D; kv.rf.GetState(); isLeader &#123;</span><br><span class=\"line\">\t\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\t\tfor k, v :&#x3D; range kv.needrecv &#123;</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F;DPrintf(&quot;group %d-%d needrecv &quot;)</span><br><span class=\"line\">\t\t\t\tneedshard :&#x3D; make([]int, 0)</span><br><span class=\"line\">\t\t\t\tfor i :&#x3D; 0; i &lt; len(v); i++ &#123;</span><br><span class=\"line\">\t\t\t\t\tneedshard &#x3D; append(needshard, v[i])</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\targs :&#x3D; PullArgs&#123;Shard: needshard, ClientId: int64(kv.gid), Seq: kv.myconfig[0].Num&#125;</span><br><span class=\"line\">\t\t\t\tgo func(mgid int, arg *PullArgs) &#123;</span><br><span class=\"line\">\t\t\t\t\tservers :&#x3D; kv.myconfig[0].Groups[mgid]</span><br><span class=\"line\">\t\t\t\t\tDPrintf(&quot;Migrate: group %d-%d get Gid %d Servers is %v&quot;,</span><br><span class=\"line\">\t\t\t\t\t\tkv.gid, kv.me, mgid, servers)</span><br><span class=\"line\">\t\t\t\t\tfor &#123;</span><br><span class=\"line\">\t\t\t\t\t\tfor _, si :&#x3D; range servers &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\treply :&#x3D; PullReply&#123;&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\tsrv :&#x3D; kv.make_end(si)</span><br><span class=\"line\">\t\t\t\t\t\t\tDPrintf(&quot;group %d-%d start call to gid %d&quot;, kv.gid, kv.me, mgid)</span><br><span class=\"line\">                            &#x2F;&#x2F; 由GroupA</span><br><span class=\"line\">\t\t\t\t\t\t\tok :&#x3D; srv.Call(&quot;ShardKV.Pull&quot;, arg, &amp;reply)</span><br><span class=\"line\">\t\t\t\t\t\t\t&#x2F;&#x2F;DPrintf(&quot;Migrate: group %d-%d  calling for server %v rpc pull, result is %t&quot;,</span><br><span class=\"line\">\t\t\t\t\t\t\t&#x2F;&#x2F;\t    kv.gid, kv.me, si, ok)</span><br><span class=\"line\">\t\t\t\t\t\t\tif !ok &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tDPrintf(&quot;Migrate Failed: group %d-%d  calling for server %v rpc pull, result is %t&quot;,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tkv.gid, kv.me, si, ok)</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\tif ok &amp;&amp; reply.WrongLeader &#x3D;&#x3D; false &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tif reply.Err &#x3D;&#x3D; ErrNeedWait &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tDPrintf(&quot;Migrate: waiting server %v to pull new config from SM&quot;, si)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\treturn</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tif _, isleader :&#x3D; kv.rf.GetState(); isleader &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tnewmapkv :&#x3D; make(map[string]string)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tfor k, v :&#x3D; range reply.MapKV &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\tnewmapkv[k] &#x3D; v</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tvar newdup [shardmaster.NShards]map[int64]int</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tfor i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\tnewdup[i] &#x3D; make(map[int64]int)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\tfor k, v :&#x3D; range reply.ShardDup[i] &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\tnewdup[i][k] &#x3D; v</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tmig :&#x3D; Migrate&#123;newmapkv, newdup, arg.Seq, mgid&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; this is how partition data can be repliacated</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tkv.rf.Start(mig)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tDPrintf(&quot;Migrate: group %d-%d start migrate the data pulled from %d&quot;, kv.gid, kv.me, mgid)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\treturn</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tDPrintf(&quot;Migrate Failed: group %d-%d call %d-%v meet wrong leader&quot;,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tkv.gid, kv.me, mgid, si)</span><br><span class=\"line\">\t\t\t\t\t\t\t\tDPrintf(&quot;!!!server is %v&quot;, servers)</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\ttime.Sleep(20 * time.Millisecond)</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;(k, &amp;args)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttime.Sleep(100 * time.Millisecond)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>非Leader节点同步KV数据的方法</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case Migrate:</span><br><span class=\"line\">    if kv.MigrateDupCheck(cmd.Gid, cmd.Num) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;DPrintf(&quot;group %d-%d apply the migrate data from %d and config num %d&quot;, kv.gid, kv.me, cmd.Gid, cmd.Num)</span><br><span class=\"line\">        &#x2F;&#x2F;DPrintf(&quot;group %d-%d database before migrate is %v&quot;, kv.gid, kv.me, kv.database)</span><br><span class=\"line\">        for k, v :&#x3D; range cmd.MapKV &#123;</span><br><span class=\"line\">            kv.database[k] &#x3D; v</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;DPrintf(&quot;group %d-%d database after migrate is %v&quot;, kv.gid, kv.me, kv.database)</span><br><span class=\"line\">        for i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class=\"line\">            for k, v :&#x3D; range cmd.ShardDup[i] &#123;</span><br><span class=\"line\">                kv.dup[i][k] &#x3D; v</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for i :&#x3D; 0; i &lt; len(kv.needrecv[cmd.Gid]); i++ &#123;</span><br><span class=\"line\">            kv.myshards[kv.needrecv[cmd.Gid][i]] &#x3D; 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        delete(kv.needrecv, cmd.Gid)</span><br><span class=\"line\">        if kv.CheckMigrateDone() &#123;</span><br><span class=\"line\">            kv.myconfig[0] &#x3D; kv.myconfig[1]</span><br><span class=\"line\">            DPrintf(&quot;Migrate: group %d-%d successful switch to config %d&quot;, kv.gid, kv.me, kv.myconfig[0].Num)</span><br><span class=\"line\">            &#x2F;&#x2F;DPrintf(&quot;group %d-%d is applied new config , shard is %v&quot;, kv.gid, kv.me, kv.myshards)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        kv.migratedup[cmd.Gid] &#x3D; cmd.Num</span><br><span class=\"line\">        if kv.maxraftstate !&#x3D; -1 &#123;</span><br><span class=\"line\">            kv.SaveSnapshot(index)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></div></figure>","site":{"data":{}},"excerpt":"","more":"<!-- ---\nlayout: post\ntitle: MIT6.824 Lab4 实现及解析\nauthor: Ray Chan(ray1888)\ndate: '2019-08-20 12:05:38 +0800'\ncategory: distributed-system\nsummary: MIT6.824 Lab4 Implemantation and detail explains\nthumbnail: distributed-db.jpg\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#Purpose\">实验目的</a>  </li>\n<li><a href=\"#Implementation\">实验实现</a><br>2.1 <a href=\"#2.1\">lab4-1</a><br>2.2 <a href=\"#2.2\">lab4-2</a>  </li>\n</ol>\n\n        <h1 id=\"实验目的\"   >\n          <a href=\"#实验目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实验目的</h1>\n      <p>lab4需要实现两个模块:</p>\n<ol>\n<li>lab4-1 完成一个基于KvRaft的ShardMaster（可以理解为一个分片调度的存放的机器），但是写入的是配置而不是简单的K-v的值（但是与Lab3的实现相当相似）</li>\n<li>lab4-2 完成一个Sharding的kvRaft数据库（实现了Multi-raft)</li>\n</ol>\n<p>整体的实验架构是这样的</p>\n<!-- ![lab4](/assets/img/posts/lab4.png) -->\n<img src=\"/2019/08/29/raft-lab-4/lab4.png\" class=\"\" title=\"lab4\">\n\n<p>架构图如上：<br>一个值得注意的点是，各个KV数据库层之间不会直接相互通信，只是会通过Raft层来同步操作。<br>并且Client如果找到的不是Leader的节点，会直接放弃操作。然后请求集群内的下一个节点。<br>PS: 这里的KvDatabase 和Raft总体包起来才是一个KVServer的实例，而不是单独脱离的。    </p>\n<p>流程大概如下:</p>\n<ol>\n<li>Client发送请求到ShardMaster，查询Key的具体对应的分片在哪个组里面</li>\n<li>ShardMaster收到请求后，返回对应数据Key所在的组信息</li>\n<li>Client发送请求到对应分片的Raft Leader中</li>\n<li>Raft层同步成功后，会通过ApplyCh返回信号的KvDatabase</li>\n<li>分片的KvDatabase对Client端做出应答（如果成功返回结果为成功，如果下面同步层失败导致超时，返回给客户端的结果为超时）</li>\n</ol>\n\n        <h2 id=\"副本与分片的问题\"   >\n          <a href=\"#副本与分片的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>副本与分片的问题</h2>\n      <p>在上面的架构图中，Multi-Raft已经实现了分片的副本的实现。</p>\n<p>分片： 只要是把数据进行划分（从大的数据变为只负责一部分的数据量）即是分片（在定义上面数据库的垂直划分和水平划分和此处的Key按键去Mod划分都是属于分片的操作，但是数据库表的划分和此处的Key的Mod划分不是在同一个层级上面的，理解不一样）<br>副本： 是指数据的重复的数量。但是一般只有一份的数据我们不会称之为单副本，而是称为0副本。副本一般是&gt;=2才叫。副本的目的是为了冗余的问题。防止因为单点故障而导致数据全部的丢失。  </p>\n\n        <h1 id=\"实验实现\"   >\n          <a href=\"#实验实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实验实现</h1>\n      \n        <h2 id=\"lab4-1\"   >\n          <a href=\"#lab4-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>lab4-1</h2>\n      <p>对比起与Lab3 的实现，它在这里需要支持的是Leave(), Move(), Join()， Query()的四种方法，因为分别对应节点的加入集群、退出集群、移动集群和集群配置查询的四种操作。<br>所以基本实现的思路与Lab3是类似的。  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ShardMaster struct &#123;</span><br><span class=\"line\">\tmu      sync.Mutex</span><br><span class=\"line\">\tme      int</span><br><span class=\"line\">\trf      *raft.Raft</span><br><span class=\"line\">\tapplyCh chan raft.ApplyMsg</span><br><span class=\"line\">\t&#x2F;&#x2F; Your data here.</span><br><span class=\"line\">    &#x2F;&#x2F; Lab3 此处是为database 是一个map[string]string 的结构</span><br><span class=\"line\">\tconfigs    []Config &#x2F;&#x2F; indexed by config num</span><br><span class=\"line\">\tdup        map[int64]Result</span><br><span class=\"line\">\tchanResult map[int]chan Result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>但是有一个比较重要的需求是，它需要完成一个shard 与 集群的绑定关系的变动，因为本来就是需要支持的目的就是数据随着Group的添加和变动来做到数据的均衡。<br>并且一个比较不同的是，对于重复的Get操作操作，Lab3采用的是直接返回Kv的值，但是在此处，因为Config的存放机制是一个数组（里面的顺序就是配置有效的顺序），因此需要把重复的读配置，返回一个复制好的配置。  </p>\n\n        <h2 id=\"lab4-2\"   >\n          <a href=\"#lab4-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>lab4-2</h2>\n      <p>这里的实现是需要首先保证Kv的功能可以使用，然后保证在配置变动并且数据搬移完成之后，才能继续对外提供Kv的服务。并且需要保证节点挂掉之后可以读取会最新的状态下来</p>\n<p>总体流程：<br>在提供KV服务的同时，需要把配置定时进行更新，并且实际应用新配置之前，必须保证数据迁移成功。因此实际上用到了3个单独的协程去分别做这几个工作</p>\n<ol>\n<li>读取配置协程（定时向ShardMaster请求配置）</li>\n<li>数据迁移的协程</li>\n<li>应用数据同步的协程</li>\n</ol>\n<p>因为这个实验中的目的有三种，因此我们的消息类型也定义了三种</p>\n<ol>\n<li>数据操作类型，与Lab3原来类似的OP类型（可以包含Get、Pull、Put、Append的操作）</li>\n<li>配置更新类型，把Lab4-1的Config类型封装一层进行使用</li>\n<li>真实的数据迁移类型，原因是：因为数据迁移的时候是两个RaftGroup的Leader相互通信，并且需要把原来数据KV格式同步进去到新的组的所有副本上面。因此单独分配一个数据类型来记录此类数据</li>\n</ol>\n<p>向ShardMaster读取配置的协程的实现</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (kv *ShardKV) ConfigUpdateRoutine() &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\tcurConfigNum :&#x3D; kv.myconfig[0].Num</span><br><span class=\"line\">\t\tkv.mu.Unlock()</span><br><span class=\"line\">        &#x2F;&#x2F; 此处Query带上当前版本加1的原因，防止查询到的配置不正确，导致分片的节点之前一直无法达成配置上共识</span><br><span class=\"line\">\t\tconfig :&#x3D; kv.mck.Query(curConfigNum + 1)</span><br><span class=\"line\">\t\t&#x2F;&#x2F;DPrintf(&quot;get newConfig from SM group is %v, shard is %v&quot;, config.Groups, config.Shards)</span><br><span class=\"line\">\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\tif config.Num &#x3D;&#x3D; kv.myconfig[0].Num+1 &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; update with static NewConfig</span><br><span class=\"line\">\t\t\tnewConfig :&#x3D; kv.makeEmptyConfig()</span><br><span class=\"line\">\t\t\tkv.CopyConfig(&amp;config, &amp;newConfig)</span><br><span class=\"line\">\t\t\tif _, isLeader :&#x3D; kv.rf.GetState(); isLeader &#123;</span><br><span class=\"line\">\t\t\t\tcfg :&#x3D; Cfg&#123;newConfig, int64(kv.gid), kv.myconfig[0].Num&#125;</span><br><span class=\"line\">\t\t\t\tkv.rf.Start(cfg)</span><br><span class=\"line\">\t\t\t\tDPrintf(&quot;Config: group %d-%d is start config %d into consueum&quot;,</span><br><span class=\"line\">\t\t\t\t\tkv.gid, kv.me, cfg.NewConfig.Num)</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F;index, _, isleader :&#x3D; kv.rf.Start(cfg)</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F;DPrintf(&quot;))))) server %d gid %d Start cfg， index is %d, isleader is %t, kv is %v&quot;,</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F;\tkv.me, kv.gid, index, isleader, kv.database)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\ttime.Sleep(100 * time.Millisecond)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>修改自己需要发送和接受Shard的配置部分的代码</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case Cfg:</span><br><span class=\"line\">    if kv.CfgDupCheck(cmd.ClientId, cmd.Seq) &#123;</span><br><span class=\"line\">        kv.SwitchConfig(cmd)</span><br><span class=\"line\">        if kv.CheckMigrateDone() &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; if migrate done, use new config, if not, do nothing to avoid replying the old group replied</span><br><span class=\"line\">            kv.myconfig[0] &#x3D; kv.myconfig[1]</span><br><span class=\"line\">            &#x2F;&#x2F;DPrintf(&quot;group %d-%d is applied new config , shard is %v, kv is %v&quot;, kv.gid, kv.me, kv.myshards, kv.database)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        kv.cfgdup[cmd.ClientId] &#x3D; cmd.Seq</span><br><span class=\"line\">        if kv.maxraftstate !&#x3D; -1 &#123;</span><br><span class=\"line\">            kv.SaveSnapshot(index)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (kv *ShardKV) SwitchConfig(newcfg Cfg) &#123;</span><br><span class=\"line\">\tif newcfg.NewConfig.Num &#x3D;&#x3D; kv.myconfig[0].Num+1 &#123;</span><br><span class=\"line\">\t\tif kv.myconfig[0].Num !&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\tkv.GenShardChangeList(newcfg)</span><br><span class=\"line\">\t\t&#125; else if kv.myconfig[0].Num &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\tfor i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class=\"line\">\t\t\t\tif newcfg.NewConfig.Shards[i] &#x3D;&#x3D; kv.gid &#123;</span><br><span class=\"line\">\t\t\t\t\tkv.myshards[i] &#x3D; 1</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnewc :&#x3D; kv.makeEmptyConfig()</span><br><span class=\"line\">\t\tkv.CopyConfig(&amp;newcfg.NewConfig, &amp;newc)</span><br><span class=\"line\">\t\tkv.myconfig[1] &#x3D; newc</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 此函数是用于生成需要发送和修改那些部分的参数</span><br><span class=\"line\">func (kv *ShardKV) GenShardChangeList(newcfg Cfg) &#123;</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class=\"line\">\t\tif kv.myconfig[0].Shards[i] &#x3D;&#x3D; kv.gid &amp;&amp; newcfg.NewConfig.Shards[i] !&#x3D; kv.gid &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F;need to send</span><br><span class=\"line\">\t\t\tkv.needsend[i] &#x3D; newcfg.NewConfig.Shards[i]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif kv.myconfig[0].Shards[i] !&#x3D; kv.gid &amp;&amp; newcfg.NewConfig.Shards[i] &#x3D;&#x3D; kv.gid &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F;need to recv</span><br><span class=\"line\">\t\t\t_, ok :&#x3D; kv.needrecv[kv.myconfig[0].Shards[i]]</span><br><span class=\"line\">\t\t\tif !ok &#123;</span><br><span class=\"line\">\t\t\t\tkv.needrecv[kv.myconfig[0].Shards[i]] &#x3D; make([]int, 0)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tkv.needrecv[kv.myconfig[0].Shards[i]] &#x3D; append(kv.needrecv[kv.myconfig[0].Shards[i]], i)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tDPrintf(&quot;!!! group %d-%d, new config need to send is %v, need to receive is %v&quot;, kv.gid, kv.me, kv.needsend, kv.needrecv)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>获取迁移的数据部分<br>数据迁移的副本是只要检测到相关属性的变化之后（感知到数据的变化）后，新的数据所归属的Leader就会与旧Leader继续RPC的Pull调用， 去获取它的Database和DUP的部分<br>当拉取到配置了之后，就会把数据变成日志应用到状态中，就可以实现分片数据的副本的性质。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (kv *ShardKV) MigrationRoutine() &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tif _, isLeader :&#x3D; kv.rf.GetState(); isLeader &#123;</span><br><span class=\"line\">\t\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\t\tfor k, v :&#x3D; range kv.needrecv &#123;</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F;DPrintf(&quot;group %d-%d needrecv &quot;)</span><br><span class=\"line\">\t\t\t\tneedshard :&#x3D; make([]int, 0)</span><br><span class=\"line\">\t\t\t\tfor i :&#x3D; 0; i &lt; len(v); i++ &#123;</span><br><span class=\"line\">\t\t\t\t\tneedshard &#x3D; append(needshard, v[i])</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\targs :&#x3D; PullArgs&#123;Shard: needshard, ClientId: int64(kv.gid), Seq: kv.myconfig[0].Num&#125;</span><br><span class=\"line\">\t\t\t\tgo func(mgid int, arg *PullArgs) &#123;</span><br><span class=\"line\">\t\t\t\t\tservers :&#x3D; kv.myconfig[0].Groups[mgid]</span><br><span class=\"line\">\t\t\t\t\tDPrintf(&quot;Migrate: group %d-%d get Gid %d Servers is %v&quot;,</span><br><span class=\"line\">\t\t\t\t\t\tkv.gid, kv.me, mgid, servers)</span><br><span class=\"line\">\t\t\t\t\tfor &#123;</span><br><span class=\"line\">\t\t\t\t\t\tfor _, si :&#x3D; range servers &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\treply :&#x3D; PullReply&#123;&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\tsrv :&#x3D; kv.make_end(si)</span><br><span class=\"line\">\t\t\t\t\t\t\tDPrintf(&quot;group %d-%d start call to gid %d&quot;, kv.gid, kv.me, mgid)</span><br><span class=\"line\">                            &#x2F;&#x2F; 由GroupA</span><br><span class=\"line\">\t\t\t\t\t\t\tok :&#x3D; srv.Call(&quot;ShardKV.Pull&quot;, arg, &amp;reply)</span><br><span class=\"line\">\t\t\t\t\t\t\t&#x2F;&#x2F;DPrintf(&quot;Migrate: group %d-%d  calling for server %v rpc pull, result is %t&quot;,</span><br><span class=\"line\">\t\t\t\t\t\t\t&#x2F;&#x2F;\t    kv.gid, kv.me, si, ok)</span><br><span class=\"line\">\t\t\t\t\t\t\tif !ok &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tDPrintf(&quot;Migrate Failed: group %d-%d  calling for server %v rpc pull, result is %t&quot;,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tkv.gid, kv.me, si, ok)</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\tif ok &amp;&amp; reply.WrongLeader &#x3D;&#x3D; false &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tif reply.Err &#x3D;&#x3D; ErrNeedWait &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tDPrintf(&quot;Migrate: waiting server %v to pull new config from SM&quot;, si)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\treturn</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tif _, isleader :&#x3D; kv.rf.GetState(); isleader &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tnewmapkv :&#x3D; make(map[string]string)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tfor k, v :&#x3D; range reply.MapKV &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\tnewmapkv[k] &#x3D; v</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tvar newdup [shardmaster.NShards]map[int64]int</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tfor i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\tnewdup[i] &#x3D; make(map[int64]int)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\tfor k, v :&#x3D; range reply.ShardDup[i] &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\tnewdup[i][k] &#x3D; v</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tmig :&#x3D; Migrate&#123;newmapkv, newdup, arg.Seq, mgid&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tkv.mu.Lock()</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; this is how partition data can be repliacated</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tkv.rf.Start(mig)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tDPrintf(&quot;Migrate: group %d-%d start migrate the data pulled from %d&quot;, kv.gid, kv.me, mgid)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\treturn</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tDPrintf(&quot;Migrate Failed: group %d-%d call %d-%v meet wrong leader&quot;,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tkv.gid, kv.me, mgid, si)</span><br><span class=\"line\">\t\t\t\t\t\t\t\tDPrintf(&quot;!!!server is %v&quot;, servers)</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\ttime.Sleep(20 * time.Millisecond)</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;(k, &amp;args)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tkv.mu.Unlock()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttime.Sleep(100 * time.Millisecond)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>非Leader节点同步KV数据的方法</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case Migrate:</span><br><span class=\"line\">    if kv.MigrateDupCheck(cmd.Gid, cmd.Num) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;DPrintf(&quot;group %d-%d apply the migrate data from %d and config num %d&quot;, kv.gid, kv.me, cmd.Gid, cmd.Num)</span><br><span class=\"line\">        &#x2F;&#x2F;DPrintf(&quot;group %d-%d database before migrate is %v&quot;, kv.gid, kv.me, kv.database)</span><br><span class=\"line\">        for k, v :&#x3D; range cmd.MapKV &#123;</span><br><span class=\"line\">            kv.database[k] &#x3D; v</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;DPrintf(&quot;group %d-%d database after migrate is %v&quot;, kv.gid, kv.me, kv.database)</span><br><span class=\"line\">        for i :&#x3D; 0; i &lt; shardmaster.NShards; i++ &#123;</span><br><span class=\"line\">            for k, v :&#x3D; range cmd.ShardDup[i] &#123;</span><br><span class=\"line\">                kv.dup[i][k] &#x3D; v</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for i :&#x3D; 0; i &lt; len(kv.needrecv[cmd.Gid]); i++ &#123;</span><br><span class=\"line\">            kv.myshards[kv.needrecv[cmd.Gid][i]] &#x3D; 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        delete(kv.needrecv, cmd.Gid)</span><br><span class=\"line\">        if kv.CheckMigrateDone() &#123;</span><br><span class=\"line\">            kv.myconfig[0] &#x3D; kv.myconfig[1]</span><br><span class=\"line\">            DPrintf(&quot;Migrate: group %d-%d successful switch to config %d&quot;, kv.gid, kv.me, kv.myconfig[0].Num)</span><br><span class=\"line\">            &#x2F;&#x2F;DPrintf(&quot;group %d-%d is applied new config , shard is %v&quot;, kv.gid, kv.me, kv.myshards)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        kv.migratedup[cmd.Gid] &#x3D; cmd.Num</span><br><span class=\"line\">        if kv.maxraftstate !&#x3D; -1 &#123;</span><br><span class=\"line\">            kv.SaveSnapshot(index)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></div></figure>"},{"title":"Effective Go Reading","date":"2019-09-16T03:07:38.000Z","_content":"\n\n<!-- --- -->\n<!-- layout: post\ntitle: Effective Go Reading\nauthor: Ray Chan(ray1888)\ndate: '2019-09-16 11:07:38 +0800'\ncategory: go\nsummary: Effective Go \nthumbnail: go.png\n--- -->\n\n本文章的目的是为了详细阅读和理解Effective GO所提及到的内容。\n\n# 目录\n1. [Method](#Method)  \n   1.1 [Pointers vs Values](#PvV)  \n2. [Data](#Data)\n   2.1 [New vs Make](#NewMake)  \n   2.2 [Array](#Array)  \n   2.3 [Slice](#Slice)  \n   2.4 [Map](#Map)  \n   2.5 [Append](#Append)  \n3. [Interface](#InterFace)\n4. [Error](#Error)\n5. [PackageInit](#Init)  \n6. [Defer](#Defer)\n7. [ShareNote](#ShareNote)\n\n# <a id=\"Method\"><span class=\"toptitle\">Method</span></a>\n\n## <a id=\"PvV\"><span class=\"secondtitle\">Pointers vs Values</span></a>\n\n主要的区别，如果方法是放在类型值上面而不是指针上面的，可以通过指针和普通类型来进行使用。但是对于方法绑定的是指针的类型，只能通过指针来进行使用。\n\n```\npackage main\n\nimport \"fmt\"\n\ntype ByteSlice []byte\n\nfunc (slice ByteSlice) Append(data []byte) []byte {\n\t// Body exactly the same as the Append function defined above.\n\tl := len(slice)\n\tif l+len(data) > cap(slice) { // reallocate\n\t\t// Allocate double what's needed, for future growth.\n\t\tnewSlice := make([]byte, (l+len(data))*2)\n\t\t// The copy function is predeclared and works for any slice type.\n\t\tcopy(newSlice, slice)\n\t\tslice = newSlice\n\t}\n\tslice = slice[0 : l+len(data)]\n\tcopy(slice[l:], data)\n\treturn slice\n}\n\nfunc (p *ByteSlice) Append2(data []byte) {\n\tslice := *p\n\t// Body as above, without the return.\n\tl := len(slice)\n\tif l+len(data) > cap(slice) { // reallocate\n\t\t// Allocate double what's needed, for future growth.\n\t\tnewSlice := make([]byte, (l+len(data))*2)\n\t\t// The copy function is predeclared and works for any slice type.\n\t\tcopy(newSlice, slice)\n\t\tslice = newSlice\n\t}\n\tslice = slice[0 : l+len(data)]\n\tcopy(slice[l:], data)\n\t*p = slice\n}\n\nfunc (p *ByteSlice) Write(data []byte) (n int, err error) {\n\tslice := *p\n\t// Body as above, without the return.\n\tl := len(slice)\n\tif l+len(data) > cap(slice) { // reallocate\n\t\t// Allocate double what's needed, for future growth.\n\t\tnewSlice := make([]byte, (l+len(data))*2)\n\t\t// The copy function is predeclared and works for any slice type.\n\t\tcopy(newSlice, slice)\n\t\tslice = newSlice\n\t}\n\tslice = slice[0 : l+len(data)]\n\tcopy(slice[l:], data)\n\t*p = slice\n\t*p = slice\n\treturn len(data), nil\n}\n\nfunc main() {\n\tvar b ByteSlice\n\tb = b.Append([]byte{1, 2, 3})\n\tfmt.Printf(\"byteSlice 1 is %v\", b)\n\tb.Write([]byte{7, 8, 9})\n\tfmt.Printf(\"byteSlice 2 is %v\", b)\n    /*\n    func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)\n    */\n\tfmt.Fprintf(&b, \"This hour has %d days\\n\", 7)\n    /*\n    if use below code , will throw error \n    fmt.Fprintf(b, \"This hour has %d days\\n\", 7)\n    */\n\tb.Append2([]byte{4, 5, 6})\n\tfmt.Printf(\"byteSlice 3 is %v\", b)\n}\n```\n\n上面的例子表达的是，假如直接像注释的代码那样，把B传入一个满足io.Writer的指针的方法中（含有Write方法），但是因为我们的自定义类型上面的Write是指针方法，而不是类型方法，所以会出现类型报错的问题。报错如下\n```\nas type io.Writer in argument to fmt.Fprintf:\n\tByteSlice does not implement io.Writer (Write method has pointer receiver)\n```\n\n根据官方的描述，原文如下：\n```\nThe rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.\n\nThis rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call its Write method with just b.Write. The compiler will rewrite that to (&b).Write for us.\n```\n\n翻译一下：\n对于接收者类型是指针还是值的规则，值接收者可以 被值或者指针进行调用。而指针方法只能被指针进行调用。\n\n这个规则的产生的原因是因为指针方法可以修改接受者的值。 但是以值的方式继续调用的情况下，go是会自动把值复制一份，然后继续方法的调用，所有对于里面变量得修改都会被丢弃（因为是值传递，除非使用Return +调用的地方有返回值接收）。 因此语言不允许有这种的错误出现。当值是可以获得地址的情况下，语言会自动把值获取指针传入指针调用的方法里面。 \n\n\n# <a id=\"Data\"><span class=\"toptitle\">Data</span></a>\n\n## <a id=\"NewMake\"><span class=\"secondtitle\">New vs Make</span></a>\n\n### <a id=\"New\"><span class=\"thirdtitle\">New</span></a>\nNew 是 Go里面的分配内存的方法，但是它只会创建一个Zero值（即创建一个0的空间给对应的内存，并且返回这个变量所占有的内存地址）。\n\n由于由new出来的内存占用为0。这样对于设计你自己的数据结构很有帮助，原因是因为可以默认初始化了0的值，而不用之后再去进行二次的初始化。\n\n官网上的例子：\n```\nFor example, the documentation for bytes.Buffer states that \"the zero value for Buffer is an empty buffer ready to use.\" Similarly, sync.Mutex does not have an explicit constructor or Init method. Instead, the zero value for a sync.Mutex is defined to be an unlocked mutex.\n\nThe zero-value-is-useful property works transitively. Consider this type declaration.\n\ntype SyncedBuffer struct {\n    lock    sync.Mutex\n    buffer  bytes.Buffer\n}\n\n```\n\n但是有些时候直接初始化0值不要足够，需要一个构建者。像这个例子一样\n```\nfunc NewFile(fd int, name string) *File {\n    if fd < 0 {\n        return nil\n    }\n    f := new(File)\n    f.fd = fd\n    f.name = name\n    f.dirinfo = nil\n    f.nepipe = 0\n    return f\n}\n```\n\n因为上面这段代码有比较多的参数，因此我们可以用一个命名的字段来继续初始化\n```\nfunc NewFile(fd int, name string) *File {\n    if fd < 0 {\n        return nil\n    }\n    f := File{fd, name, nil, 0}\n    return &f\n}\n```\n\n事实上，直接获取复合文字初始化的结构体的地址，实际上会创建一个全新的实例并且赋值，因此我们可以把上面的最后两行代码合成一行代码  \n```\nf := File{fd, name, nil, 0}\n    return &f\n=== \n\nreturn &File{fd, name, nil, 0}\n```\n\n用于和范围： 适用于创建数组、切片、映射（with the field labels being indices or map keys as appropriate）。\n\n返回值：\n一个对应类型的指针\n\n### <a id=\"Make\"><span class=\"thirdtitle\">Make</span></a>\n\nMake 可以用于创建并且返回一个非nil的值。  \n适用范围：\n切片、映射、channel  \n\n```\nmake([]int,10,100)  // 这样是创建了一个容量为100，但是填入了10个0的切片。\n```\n\n官网上面对make的描述\n```\nFor slices, maps, and channels, make initializes the internal data structure and prepares the value for use.\n```\n\n返回值：\n一个对应类型的数据\n\n### <a id=\"MakediffNew\"><span class=\"thirdtitle\">Diff</span></a>\n区别上面的Make和New的目的是为了，对于切片、映射、channel这三种类型，在底层的实现原理中都必须要先创建一个底层的实现才能被引用到，才能在暴露给语言的使用者上面不会抛出错误。  \n所以本质上，new创建出来的可以理解为一个nil的对象，而make创建出来的是一个带有底层数据结构，并且有非nil的对象。  \n而且返回值有所不同。\n```\npackage main\n\nimport \"fmt\"\n\nfunc main(){\n\t // allocates slice structure; *p == nil; rarely useful\n\tvar p *[]int = new([]int)     \n\t// the slice v now refers to a new array of 100 ints \n\tvar v []int = make([]int, 5) \n\tfmt.Printf(\"p values is %v，%v\\n\", p, *p==nil)\n\tfmt.Printf(\"v values is %v, %v\\n\", v, v==nil)\n\t\n}\n\n------------------\np values is &[]，true\nv values is [0 0 0 0 0], false\n\n```\n\n## <a id=\"Array\"><span class=\"secondtitle\">Array</span></a>\n\n数组在Go的三个特点：\n1. 如果直接把数据传入到一个函数中，则是把这个数组的值拷贝一份，然后把拷贝的副本传到函数中进行使用。\n2. 数组的长度也是它的类型属性之一，[10]int和[20]int不是等价的。\n3. Array都是值。\n\n而且有一个使用的小技巧，如果想要减少传递的数据的量，可以直接传入指针，这样可以免于拷贝多一份中间的数据。  \n对于Go来说，因为数组类型支持的方法比较少，而且不能够通过动态去进行特定长度数组创建。因此更加建议的是用Slice来代替数组。  \n\n## <a id=\"Slice\"><span class=\"secondtitle\">Slice</span></a>\n\n可以看我的博客另外一篇的文章Go Slice上面有提及高级的用法，此处不再重复。  \n\n### 二维数组和二维切片\n\n对于二维数组的声明，可以使用这样的方法  \n```\ntype Transform [3][3]float64  // A 3x3 array, really an array of arrays.\ntype LinesOfText [][]byte     // A slice of byte slices.\n\ntext := LinesOfText{\n\t[]byte(\"Now is the time\"),\n\t[]byte(\"for all good gophers\"),\n\t[]byte(\"to bring some fun to the party.\"),\n}\n```\n\n如果使用Make来继续初始化的情况。需要考虑两个不同的使用场景导致的初始化方式的不同。  \n第一种：如果内部的一位数组可能发生扩展或者收缩，那么就要单独去分配这个一位数组。\n第二种： 如果内部的数组长度不会发生size变化而只会发生值得变化，则可以进行统一得初始化。(这样性能会比较好，因为可以一次性的调用Allocate的系统函数，减少分配内存的开销)\n```\n// First Method\npicture := make([][]uint8, YSize)\nfor i:= range picture{\n    picture[i] = make([]uint8, XSize)\n}\n\n// Second Method \npicture := make([][]uint8, YSize)\npixels := make([]uint8, XSize * YSize)\n\nfor i := range picture{\n    picture[i], pixels = pixels[:XSize], pixels[XSize:]\n}\n\n```\n\n## <a id=\"Map\"><span class=\"secondtitle\">Map</span></a>\n主要注意当一个Key不存在与一个Map中的情况下，需要使用这种方法来进行判断\n```\nvar tz map[string]int\nvar ds string = \"abc\"\nif val, ok := tz[ds]; ok{\n    return val\n}\n```\n\n同理在上面的例子上面，如果反过来进行使用，可以用于判断Key是否存在于Map中。\n```\nvar tz map[string]int\nvar ds string = \"abc\"\n_, exist := tz[ds]\nif !exist {\n    return \"is not exist\"\n}\n```\n\n如果需要删除一个值的情况下,使用delete的函数进行处理\n```\nvar tz map[string]int\nvar ds string = \"abc\"\n// delete(map, key)\ndelete(tz, ds)\n```\n\n## <a id=\"Append\"><span class=\"secondtitle\">Append</span></a>\n\nAppend 可以接受多个参数\n```\nfunc append(slice []T, elements ...T) []T\n\n// use case \nx := []int{1,2,3}\nx = append(x, 4, 5, 6)\nfmt.Println(x)\n```\n\n对于如果要把两个数组直接接起来的情况下\n```\nx := []int{1,2,3}\ny := []int{4,5,6}\nx = append(x, y...)\nfmt.Println(x)\n```\n\n# <a id=\"InterFace\"><span class=\"toptitle\">InterFace</span></a>\n\n## Interface\n\n一个结构体可以实现多个接口，只要它实现了那些接口所定义的方法。\n```\ntype Sequence []int\n\n// Methods required by sort.Interface.\nfunc (s Sequence) Len() int {\n    return len(s)\n}\nfunc (s Sequence) Less(i, j int) bool {\n    return s[i] < s[j]\n}\nfunc (s Sequence) Swap(i, j int) {\n    s[i], s[j] = s[j], s[i]\n}\n\n// Copy returns a copy of the Sequence.\nfunc (s Sequence) Copy() Sequence {\n    copy := make(Sequence, 0, len(s))\n    return append(copy, s...)\n}\n\n// Method for printing - sorts the elements before printing.\nfunc (s Sequence) String() string {\n    s = s.Copy() // Make a copy; don't overwrite argument.\n    sort.Sort(s)\n    str := \"[\"\n    for i, elem := range s { // Loop is O(N²); will fix that in next example.\n        if i > 0 {\n            str += \" \"\n        }\n        str += fmt.Sprint(elem)\n    }\n    return str + \"]\"\n}\n```\n\n## Coversions\n\n上面所引用的到方法其实是重新实现了fmt包里面的Sprint方法。我们可以用一些方法来为这个提速，在调用Sprint之前把数据转换成[]int类型，因为Sequence的本质上就\n是[]int。  \n\n```\n// 修改前\nfunc (s Sequence) String() string {\n    s = s.Copy()\n    sort.Sort(s)\n    return fmt.Sprint([]int(s))\n}\n\n// 修改后\ntype Sequence []int\n\n// Method for printing - sorts the elements before printing\nfunc (s Sequence) String() string {\n    s = s.Copy()\n    sort.IntSlice(s).Sort()\n    return fmt.Sprint([]int(s))\n}\n```\n\n## type assertions\n\n使用Type switch 实际上的操作会把那个变量根据分支的判断的类型来转型。  \n下面这段代码是一个例子，目的是如果不是string类型, 调用其String()进行输出。而如果是，直接输出。\n```\ntype Stringer interface {\n    String() string\n}\n\nvar value interface{} // Value provided by caller.\nswitch str := value.(type) {\ncase string:\n    return str\ncase Stringer:\n    return str.String()\n}\n```\n\n如果对于使用场景是单分支，只需要判断接口是否为那个类型的实现的情况下，可以使用\n```\n// \nstr, ok := value.(string)\n```\n\n注意的是继续类型推断的情况下，必须要填入实际的类型，不能再填入Interface。\n\n##  Generality\n\n如果包里面的一个类型只是为了实现接口并且其他方法不需要进行导出给外部使用的情况下。只需要导出接口就好，这样可以避免对于使用者不感兴趣的方法的实现的复杂度。\n如官方的Hash模块，crc32.NewIEEE 和 adler32.New这两个方法都是返回 接口类型Hash.Hash32。\n\n## interface & method\n\n只要这个类型实现了这个接口的所有方法，即可以把这个类型传入来当接口使用.可以理解为简单的依赖翻转。\n\n\n# <a id=\"Error\"><span class=\"toptitle\">Error</span></a>\n\n## <a id=\"Defination\"><span class=\"secondtitle\">Defination</span></a>\nError 接口在代码里面的定义是这样的。\n```\ntype error interface {\n    Error() string\n}\n```\n\n如果需要实现一个自定义的Error（添加部分与业务相关的信息）\n```\n// PathError records an error and the operation and\n// file path that caused it.\ntype PathError struct {\n    Op string    // \"open\", \"unlink\", etc.\n    Path string  // The associated file.\n    Err error    // Returned by the system call.\n}\n\nfunc (e *PathError) Error() string {\n    return e.Op + \" \" + e.Path + \": \" + e.Err.Error()\n}\n```\n\n并且建议的可行方法，错误信息应该能够表明他们的来源（即发生错误的模块是哪个模块的哪个函数）。  \n一般来说，函数调用者如果关心具体的错误信息的话，可以使用一个类型switch来获取具体的错误类型和相信信息。\n```\nfor try := 0; try < 2; try++ {\n    file, err = os.Create(filename)\n    if err == nil {\n        return\n    }\n    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {\n        deleteTempFiles()  // Recover some space.\n        continue\n    }\n    return\n}\n```\n\n## <a id=\"Panic\"><span class=\"secondtitle\">Panic</span></a>\n对于预设以内的错误，返回错误的方式应该是返回错误的信息为多一个参数.\n```\n\nfunc Get() (string, Error){\n    return \"\", nil\n}\n\nk, err := Get()\n```\n但是对于不可恢复的错误，我们不能让程序继续运行。  \nPanic()的作用是创建一个Runtime Error并且使得程序无法继续运行。  \nPanic可以接受任意长度的参数，并且打印到日志上，\n```\nfunc CubeRoot(x float64) float64 {\n    z := x/3   // Arbitrary initial value\n    for i := 0; i < 1e6; i++ {\n        prevz := z\n        z -= (z*z*z-x) / (3*z*z)\n        if veryClose(z, prevz) {\n            return z\n        }\n    }\n    // A million iterations has not converged; something is wrong.\n    panic(fmt.Sprintf(\"CubeRoot(%g) did not converge\", x))\n}\n```\n\n官方对于Panic的态度：程序员应该尽可能的去考虑并且解决所有的异常的情况。\n对于真实的代码库上面不建议使用这个方法。\n\n## <a id=\"Recover\"><span class=\"secondtitle\">Recover</span></a>\n\n用于恢复发生Panic的Goroutine。但是必须在panic前面的地方添加一个defer 并且把Recover函数放入其中。\n```\nfunc server(workChan <-chan *Work) {\n    for work := range workChan {\n        go safelyDo(work)\n    }\n}\n\nfunc safelyDo(work *Work) {\n    defer func() {\n        if err := recover(); err != nil {\n            log.Println(\"work failed:\", err)\n        }\n    }()\n    do(work)\n}\n```\n\n官方库中处理复杂错误的例子，Regexp\n```\n// Error is the type of a parse error; it satisfies the error interface.\ntype Error string\nfunc (e Error) Error() string {\n    return string(e)\n}\n\n// error is a method of *Regexp that reports parsing errors by\n// panicking with an Error.\nfunc (regexp *Regexp) error(err string) {\n    panic(Error(err))\n}\n\n// Compile returns a parsed representation of the regular expression.\nfunc Compile(str string) (regexp *Regexp, err error) {\n    regexp = new(Regexp)\n    // doParse will panic if there is a parse error.\n    defer func() {\n        if e := recover(); e != nil {\n            regexp = nil    // Clear return value.\n            err = e.(Error) // Will re-panic if not a parse error.\n        }\n    }()\n    return regexp.doParse(str), nil\n}\n```\n\n即使上面把regexp 的类型变成了nil。但是如果在e判断类型的时候如果不是Error的类型。程序仍然会发生错误，并且崩溃推出。\n```\nif pos == 0 {\n    re.error(\"'*' illegal at start of expression\")\n}\n```\n对于上面的这种re-panic的策略，官方建议是在一个包内进行使用，这样就不会把错误暴露给Client。  \n虽然re-panic最终程序还是崩溃了，但是这样可以使得程序具体的错误可以过滤一层，并且找到更加直接的错误的原因。\n\n# <a id=\"Init\"><span class=\"toptitle\">PackageInit</span></a>\n\n可以直接看[译文](https://zhuanlan.zhihu.com/p/34211611)即可。\n\n也可以直接读介绍的[原文](https://medium.com/golangspec/init-functions-in-go-eac191b3860a)\n\n# <a id=\"Defer\"><span class=\"toptitle\">Defer</span></a>\n\nDefer语法是在函数返回前进行调度的清除函数调用。它能够很好地处理多分支返回情况下的释放资源的问题。（类似于Python的With语法）\n\n```\nfunc Contents(filename string) (string, error) {\n    f, err := os.Open(filename)\n    if err != nil {\n        return \"\", err\n    }\n    defer f.Close()  // f.Close will run when we're finished.\n\n    var result []byte\n    buf := make([]byte, 100)\n    for {\n        n, err := f.Read(buf[0:])\n        result = append(result, buf[0:n]...) // append is discussed later.\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return \"\", err  // f will be closed if we return here.\n        }\n    }\n    return string(result), nil // f will be closed if we return here.\n}\n```\n\n```\n官方对于Defer的好处声明：\n1. 位置更加接近，更好的可以清晰的看出操作\n2. 防止资源忘了关闭导致的泄露问题\n```\n\n延迟函数（如果函数是方法，则包括接收方）的参数在延迟执行时而不是在调用执行时进行评估。除了避免担心函数执行时变量会更改值外，这还意味着单个延迟的调用站点可以延迟多个函数的执行。这是一个简单的例子。\n```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tfor i := 0; i < 5; i++ {\n    \t\tdefer fmt.Printf(\"%d \", i)\n\t}\n}\n\n-------\noutput:\n4 3 2 1 0 \n```\nDefer函数的执行吮吸是LIFO（LastInFirstOut)栈的结构。\n\n\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc trace(s string) string {\n    fmt.Println(\"entering:\", s)\n    return s\n}\n\nfunc un(s string) {\n    fmt.Println(\"leaving:\", s)\n}\n\nfunc a() {\n    defer un(trace(\"a\"))\n    fmt.Println(\"in a\")\n}\n\nfunc b() {\n    defer un(trace(\"b\"))\n    fmt.Println(\"in b\")\n    a()\n}\n\nfunc main() {\n    b()\n}\n-------------------\noutput\nentering: b\nin b\nentering: a\nin a\nleaving: a\nleaving: b\n```\n\n从上面的例子可以看出来，defer函数只能包含一层，如果像上面的代码 defer un(trace()), 那么会先执行trace()，然后再把un()函数压入defer的栈中。\n\n[更加实际的使用场景相关的例子](https://mp.weixin.qq.com/s/_wZQID0VatIlAiH6-x3U6A)\n\n# <a id=\"ShareNote\"><span class=\"toptitle\">ShareNote</span></a>\n1. [EffectiveGo](https://golang.org/doc/effective_go.html)\n2. [GoInitFunc](https://medium.com/golangspec/init-functions-in-go-eac191b3860a)\n3. [GoInitFunc译文](https://zhuanlan.zhihu.com/p/34211611)","source":"_posts/effective-go.md","raw":"---\ntitle: Effective Go Reading\ndate: 2019-09-16 11:07:38\ntags: Go\n---\n\n\n<!-- --- -->\n<!-- layout: post\ntitle: Effective Go Reading\nauthor: Ray Chan(ray1888)\ndate: '2019-09-16 11:07:38 +0800'\ncategory: go\nsummary: Effective Go \nthumbnail: go.png\n--- -->\n\n本文章的目的是为了详细阅读和理解Effective GO所提及到的内容。\n\n# 目录\n1. [Method](#Method)  \n   1.1 [Pointers vs Values](#PvV)  \n2. [Data](#Data)\n   2.1 [New vs Make](#NewMake)  \n   2.2 [Array](#Array)  \n   2.3 [Slice](#Slice)  \n   2.4 [Map](#Map)  \n   2.5 [Append](#Append)  \n3. [Interface](#InterFace)\n4. [Error](#Error)\n5. [PackageInit](#Init)  \n6. [Defer](#Defer)\n7. [ShareNote](#ShareNote)\n\n# <a id=\"Method\"><span class=\"toptitle\">Method</span></a>\n\n## <a id=\"PvV\"><span class=\"secondtitle\">Pointers vs Values</span></a>\n\n主要的区别，如果方法是放在类型值上面而不是指针上面的，可以通过指针和普通类型来进行使用。但是对于方法绑定的是指针的类型，只能通过指针来进行使用。\n\n```\npackage main\n\nimport \"fmt\"\n\ntype ByteSlice []byte\n\nfunc (slice ByteSlice) Append(data []byte) []byte {\n\t// Body exactly the same as the Append function defined above.\n\tl := len(slice)\n\tif l+len(data) > cap(slice) { // reallocate\n\t\t// Allocate double what's needed, for future growth.\n\t\tnewSlice := make([]byte, (l+len(data))*2)\n\t\t// The copy function is predeclared and works for any slice type.\n\t\tcopy(newSlice, slice)\n\t\tslice = newSlice\n\t}\n\tslice = slice[0 : l+len(data)]\n\tcopy(slice[l:], data)\n\treturn slice\n}\n\nfunc (p *ByteSlice) Append2(data []byte) {\n\tslice := *p\n\t// Body as above, without the return.\n\tl := len(slice)\n\tif l+len(data) > cap(slice) { // reallocate\n\t\t// Allocate double what's needed, for future growth.\n\t\tnewSlice := make([]byte, (l+len(data))*2)\n\t\t// The copy function is predeclared and works for any slice type.\n\t\tcopy(newSlice, slice)\n\t\tslice = newSlice\n\t}\n\tslice = slice[0 : l+len(data)]\n\tcopy(slice[l:], data)\n\t*p = slice\n}\n\nfunc (p *ByteSlice) Write(data []byte) (n int, err error) {\n\tslice := *p\n\t// Body as above, without the return.\n\tl := len(slice)\n\tif l+len(data) > cap(slice) { // reallocate\n\t\t// Allocate double what's needed, for future growth.\n\t\tnewSlice := make([]byte, (l+len(data))*2)\n\t\t// The copy function is predeclared and works for any slice type.\n\t\tcopy(newSlice, slice)\n\t\tslice = newSlice\n\t}\n\tslice = slice[0 : l+len(data)]\n\tcopy(slice[l:], data)\n\t*p = slice\n\t*p = slice\n\treturn len(data), nil\n}\n\nfunc main() {\n\tvar b ByteSlice\n\tb = b.Append([]byte{1, 2, 3})\n\tfmt.Printf(\"byteSlice 1 is %v\", b)\n\tb.Write([]byte{7, 8, 9})\n\tfmt.Printf(\"byteSlice 2 is %v\", b)\n    /*\n    func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)\n    */\n\tfmt.Fprintf(&b, \"This hour has %d days\\n\", 7)\n    /*\n    if use below code , will throw error \n    fmt.Fprintf(b, \"This hour has %d days\\n\", 7)\n    */\n\tb.Append2([]byte{4, 5, 6})\n\tfmt.Printf(\"byteSlice 3 is %v\", b)\n}\n```\n\n上面的例子表达的是，假如直接像注释的代码那样，把B传入一个满足io.Writer的指针的方法中（含有Write方法），但是因为我们的自定义类型上面的Write是指针方法，而不是类型方法，所以会出现类型报错的问题。报错如下\n```\nas type io.Writer in argument to fmt.Fprintf:\n\tByteSlice does not implement io.Writer (Write method has pointer receiver)\n```\n\n根据官方的描述，原文如下：\n```\nThe rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.\n\nThis rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call its Write method with just b.Write. The compiler will rewrite that to (&b).Write for us.\n```\n\n翻译一下：\n对于接收者类型是指针还是值的规则，值接收者可以 被值或者指针进行调用。而指针方法只能被指针进行调用。\n\n这个规则的产生的原因是因为指针方法可以修改接受者的值。 但是以值的方式继续调用的情况下，go是会自动把值复制一份，然后继续方法的调用，所有对于里面变量得修改都会被丢弃（因为是值传递，除非使用Return +调用的地方有返回值接收）。 因此语言不允许有这种的错误出现。当值是可以获得地址的情况下，语言会自动把值获取指针传入指针调用的方法里面。 \n\n\n# <a id=\"Data\"><span class=\"toptitle\">Data</span></a>\n\n## <a id=\"NewMake\"><span class=\"secondtitle\">New vs Make</span></a>\n\n### <a id=\"New\"><span class=\"thirdtitle\">New</span></a>\nNew 是 Go里面的分配内存的方法，但是它只会创建一个Zero值（即创建一个0的空间给对应的内存，并且返回这个变量所占有的内存地址）。\n\n由于由new出来的内存占用为0。这样对于设计你自己的数据结构很有帮助，原因是因为可以默认初始化了0的值，而不用之后再去进行二次的初始化。\n\n官网上的例子：\n```\nFor example, the documentation for bytes.Buffer states that \"the zero value for Buffer is an empty buffer ready to use.\" Similarly, sync.Mutex does not have an explicit constructor or Init method. Instead, the zero value for a sync.Mutex is defined to be an unlocked mutex.\n\nThe zero-value-is-useful property works transitively. Consider this type declaration.\n\ntype SyncedBuffer struct {\n    lock    sync.Mutex\n    buffer  bytes.Buffer\n}\n\n```\n\n但是有些时候直接初始化0值不要足够，需要一个构建者。像这个例子一样\n```\nfunc NewFile(fd int, name string) *File {\n    if fd < 0 {\n        return nil\n    }\n    f := new(File)\n    f.fd = fd\n    f.name = name\n    f.dirinfo = nil\n    f.nepipe = 0\n    return f\n}\n```\n\n因为上面这段代码有比较多的参数，因此我们可以用一个命名的字段来继续初始化\n```\nfunc NewFile(fd int, name string) *File {\n    if fd < 0 {\n        return nil\n    }\n    f := File{fd, name, nil, 0}\n    return &f\n}\n```\n\n事实上，直接获取复合文字初始化的结构体的地址，实际上会创建一个全新的实例并且赋值，因此我们可以把上面的最后两行代码合成一行代码  \n```\nf := File{fd, name, nil, 0}\n    return &f\n=== \n\nreturn &File{fd, name, nil, 0}\n```\n\n用于和范围： 适用于创建数组、切片、映射（with the field labels being indices or map keys as appropriate）。\n\n返回值：\n一个对应类型的指针\n\n### <a id=\"Make\"><span class=\"thirdtitle\">Make</span></a>\n\nMake 可以用于创建并且返回一个非nil的值。  \n适用范围：\n切片、映射、channel  \n\n```\nmake([]int,10,100)  // 这样是创建了一个容量为100，但是填入了10个0的切片。\n```\n\n官网上面对make的描述\n```\nFor slices, maps, and channels, make initializes the internal data structure and prepares the value for use.\n```\n\n返回值：\n一个对应类型的数据\n\n### <a id=\"MakediffNew\"><span class=\"thirdtitle\">Diff</span></a>\n区别上面的Make和New的目的是为了，对于切片、映射、channel这三种类型，在底层的实现原理中都必须要先创建一个底层的实现才能被引用到，才能在暴露给语言的使用者上面不会抛出错误。  \n所以本质上，new创建出来的可以理解为一个nil的对象，而make创建出来的是一个带有底层数据结构，并且有非nil的对象。  \n而且返回值有所不同。\n```\npackage main\n\nimport \"fmt\"\n\nfunc main(){\n\t // allocates slice structure; *p == nil; rarely useful\n\tvar p *[]int = new([]int)     \n\t// the slice v now refers to a new array of 100 ints \n\tvar v []int = make([]int, 5) \n\tfmt.Printf(\"p values is %v，%v\\n\", p, *p==nil)\n\tfmt.Printf(\"v values is %v, %v\\n\", v, v==nil)\n\t\n}\n\n------------------\np values is &[]，true\nv values is [0 0 0 0 0], false\n\n```\n\n## <a id=\"Array\"><span class=\"secondtitle\">Array</span></a>\n\n数组在Go的三个特点：\n1. 如果直接把数据传入到一个函数中，则是把这个数组的值拷贝一份，然后把拷贝的副本传到函数中进行使用。\n2. 数组的长度也是它的类型属性之一，[10]int和[20]int不是等价的。\n3. Array都是值。\n\n而且有一个使用的小技巧，如果想要减少传递的数据的量，可以直接传入指针，这样可以免于拷贝多一份中间的数据。  \n对于Go来说，因为数组类型支持的方法比较少，而且不能够通过动态去进行特定长度数组创建。因此更加建议的是用Slice来代替数组。  \n\n## <a id=\"Slice\"><span class=\"secondtitle\">Slice</span></a>\n\n可以看我的博客另外一篇的文章Go Slice上面有提及高级的用法，此处不再重复。  \n\n### 二维数组和二维切片\n\n对于二维数组的声明，可以使用这样的方法  \n```\ntype Transform [3][3]float64  // A 3x3 array, really an array of arrays.\ntype LinesOfText [][]byte     // A slice of byte slices.\n\ntext := LinesOfText{\n\t[]byte(\"Now is the time\"),\n\t[]byte(\"for all good gophers\"),\n\t[]byte(\"to bring some fun to the party.\"),\n}\n```\n\n如果使用Make来继续初始化的情况。需要考虑两个不同的使用场景导致的初始化方式的不同。  \n第一种：如果内部的一位数组可能发生扩展或者收缩，那么就要单独去分配这个一位数组。\n第二种： 如果内部的数组长度不会发生size变化而只会发生值得变化，则可以进行统一得初始化。(这样性能会比较好，因为可以一次性的调用Allocate的系统函数，减少分配内存的开销)\n```\n// First Method\npicture := make([][]uint8, YSize)\nfor i:= range picture{\n    picture[i] = make([]uint8, XSize)\n}\n\n// Second Method \npicture := make([][]uint8, YSize)\npixels := make([]uint8, XSize * YSize)\n\nfor i := range picture{\n    picture[i], pixels = pixels[:XSize], pixels[XSize:]\n}\n\n```\n\n## <a id=\"Map\"><span class=\"secondtitle\">Map</span></a>\n主要注意当一个Key不存在与一个Map中的情况下，需要使用这种方法来进行判断\n```\nvar tz map[string]int\nvar ds string = \"abc\"\nif val, ok := tz[ds]; ok{\n    return val\n}\n```\n\n同理在上面的例子上面，如果反过来进行使用，可以用于判断Key是否存在于Map中。\n```\nvar tz map[string]int\nvar ds string = \"abc\"\n_, exist := tz[ds]\nif !exist {\n    return \"is not exist\"\n}\n```\n\n如果需要删除一个值的情况下,使用delete的函数进行处理\n```\nvar tz map[string]int\nvar ds string = \"abc\"\n// delete(map, key)\ndelete(tz, ds)\n```\n\n## <a id=\"Append\"><span class=\"secondtitle\">Append</span></a>\n\nAppend 可以接受多个参数\n```\nfunc append(slice []T, elements ...T) []T\n\n// use case \nx := []int{1,2,3}\nx = append(x, 4, 5, 6)\nfmt.Println(x)\n```\n\n对于如果要把两个数组直接接起来的情况下\n```\nx := []int{1,2,3}\ny := []int{4,5,6}\nx = append(x, y...)\nfmt.Println(x)\n```\n\n# <a id=\"InterFace\"><span class=\"toptitle\">InterFace</span></a>\n\n## Interface\n\n一个结构体可以实现多个接口，只要它实现了那些接口所定义的方法。\n```\ntype Sequence []int\n\n// Methods required by sort.Interface.\nfunc (s Sequence) Len() int {\n    return len(s)\n}\nfunc (s Sequence) Less(i, j int) bool {\n    return s[i] < s[j]\n}\nfunc (s Sequence) Swap(i, j int) {\n    s[i], s[j] = s[j], s[i]\n}\n\n// Copy returns a copy of the Sequence.\nfunc (s Sequence) Copy() Sequence {\n    copy := make(Sequence, 0, len(s))\n    return append(copy, s...)\n}\n\n// Method for printing - sorts the elements before printing.\nfunc (s Sequence) String() string {\n    s = s.Copy() // Make a copy; don't overwrite argument.\n    sort.Sort(s)\n    str := \"[\"\n    for i, elem := range s { // Loop is O(N²); will fix that in next example.\n        if i > 0 {\n            str += \" \"\n        }\n        str += fmt.Sprint(elem)\n    }\n    return str + \"]\"\n}\n```\n\n## Coversions\n\n上面所引用的到方法其实是重新实现了fmt包里面的Sprint方法。我们可以用一些方法来为这个提速，在调用Sprint之前把数据转换成[]int类型，因为Sequence的本质上就\n是[]int。  \n\n```\n// 修改前\nfunc (s Sequence) String() string {\n    s = s.Copy()\n    sort.Sort(s)\n    return fmt.Sprint([]int(s))\n}\n\n// 修改后\ntype Sequence []int\n\n// Method for printing - sorts the elements before printing\nfunc (s Sequence) String() string {\n    s = s.Copy()\n    sort.IntSlice(s).Sort()\n    return fmt.Sprint([]int(s))\n}\n```\n\n## type assertions\n\n使用Type switch 实际上的操作会把那个变量根据分支的判断的类型来转型。  \n下面这段代码是一个例子，目的是如果不是string类型, 调用其String()进行输出。而如果是，直接输出。\n```\ntype Stringer interface {\n    String() string\n}\n\nvar value interface{} // Value provided by caller.\nswitch str := value.(type) {\ncase string:\n    return str\ncase Stringer:\n    return str.String()\n}\n```\n\n如果对于使用场景是单分支，只需要判断接口是否为那个类型的实现的情况下，可以使用\n```\n// \nstr, ok := value.(string)\n```\n\n注意的是继续类型推断的情况下，必须要填入实际的类型，不能再填入Interface。\n\n##  Generality\n\n如果包里面的一个类型只是为了实现接口并且其他方法不需要进行导出给外部使用的情况下。只需要导出接口就好，这样可以避免对于使用者不感兴趣的方法的实现的复杂度。\n如官方的Hash模块，crc32.NewIEEE 和 adler32.New这两个方法都是返回 接口类型Hash.Hash32。\n\n## interface & method\n\n只要这个类型实现了这个接口的所有方法，即可以把这个类型传入来当接口使用.可以理解为简单的依赖翻转。\n\n\n# <a id=\"Error\"><span class=\"toptitle\">Error</span></a>\n\n## <a id=\"Defination\"><span class=\"secondtitle\">Defination</span></a>\nError 接口在代码里面的定义是这样的。\n```\ntype error interface {\n    Error() string\n}\n```\n\n如果需要实现一个自定义的Error（添加部分与业务相关的信息）\n```\n// PathError records an error and the operation and\n// file path that caused it.\ntype PathError struct {\n    Op string    // \"open\", \"unlink\", etc.\n    Path string  // The associated file.\n    Err error    // Returned by the system call.\n}\n\nfunc (e *PathError) Error() string {\n    return e.Op + \" \" + e.Path + \": \" + e.Err.Error()\n}\n```\n\n并且建议的可行方法，错误信息应该能够表明他们的来源（即发生错误的模块是哪个模块的哪个函数）。  \n一般来说，函数调用者如果关心具体的错误信息的话，可以使用一个类型switch来获取具体的错误类型和相信信息。\n```\nfor try := 0; try < 2; try++ {\n    file, err = os.Create(filename)\n    if err == nil {\n        return\n    }\n    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {\n        deleteTempFiles()  // Recover some space.\n        continue\n    }\n    return\n}\n```\n\n## <a id=\"Panic\"><span class=\"secondtitle\">Panic</span></a>\n对于预设以内的错误，返回错误的方式应该是返回错误的信息为多一个参数.\n```\n\nfunc Get() (string, Error){\n    return \"\", nil\n}\n\nk, err := Get()\n```\n但是对于不可恢复的错误，我们不能让程序继续运行。  \nPanic()的作用是创建一个Runtime Error并且使得程序无法继续运行。  \nPanic可以接受任意长度的参数，并且打印到日志上，\n```\nfunc CubeRoot(x float64) float64 {\n    z := x/3   // Arbitrary initial value\n    for i := 0; i < 1e6; i++ {\n        prevz := z\n        z -= (z*z*z-x) / (3*z*z)\n        if veryClose(z, prevz) {\n            return z\n        }\n    }\n    // A million iterations has not converged; something is wrong.\n    panic(fmt.Sprintf(\"CubeRoot(%g) did not converge\", x))\n}\n```\n\n官方对于Panic的态度：程序员应该尽可能的去考虑并且解决所有的异常的情况。\n对于真实的代码库上面不建议使用这个方法。\n\n## <a id=\"Recover\"><span class=\"secondtitle\">Recover</span></a>\n\n用于恢复发生Panic的Goroutine。但是必须在panic前面的地方添加一个defer 并且把Recover函数放入其中。\n```\nfunc server(workChan <-chan *Work) {\n    for work := range workChan {\n        go safelyDo(work)\n    }\n}\n\nfunc safelyDo(work *Work) {\n    defer func() {\n        if err := recover(); err != nil {\n            log.Println(\"work failed:\", err)\n        }\n    }()\n    do(work)\n}\n```\n\n官方库中处理复杂错误的例子，Regexp\n```\n// Error is the type of a parse error; it satisfies the error interface.\ntype Error string\nfunc (e Error) Error() string {\n    return string(e)\n}\n\n// error is a method of *Regexp that reports parsing errors by\n// panicking with an Error.\nfunc (regexp *Regexp) error(err string) {\n    panic(Error(err))\n}\n\n// Compile returns a parsed representation of the regular expression.\nfunc Compile(str string) (regexp *Regexp, err error) {\n    regexp = new(Regexp)\n    // doParse will panic if there is a parse error.\n    defer func() {\n        if e := recover(); e != nil {\n            regexp = nil    // Clear return value.\n            err = e.(Error) // Will re-panic if not a parse error.\n        }\n    }()\n    return regexp.doParse(str), nil\n}\n```\n\n即使上面把regexp 的类型变成了nil。但是如果在e判断类型的时候如果不是Error的类型。程序仍然会发生错误，并且崩溃推出。\n```\nif pos == 0 {\n    re.error(\"'*' illegal at start of expression\")\n}\n```\n对于上面的这种re-panic的策略，官方建议是在一个包内进行使用，这样就不会把错误暴露给Client。  \n虽然re-panic最终程序还是崩溃了，但是这样可以使得程序具体的错误可以过滤一层，并且找到更加直接的错误的原因。\n\n# <a id=\"Init\"><span class=\"toptitle\">PackageInit</span></a>\n\n可以直接看[译文](https://zhuanlan.zhihu.com/p/34211611)即可。\n\n也可以直接读介绍的[原文](https://medium.com/golangspec/init-functions-in-go-eac191b3860a)\n\n# <a id=\"Defer\"><span class=\"toptitle\">Defer</span></a>\n\nDefer语法是在函数返回前进行调度的清除函数调用。它能够很好地处理多分支返回情况下的释放资源的问题。（类似于Python的With语法）\n\n```\nfunc Contents(filename string) (string, error) {\n    f, err := os.Open(filename)\n    if err != nil {\n        return \"\", err\n    }\n    defer f.Close()  // f.Close will run when we're finished.\n\n    var result []byte\n    buf := make([]byte, 100)\n    for {\n        n, err := f.Read(buf[0:])\n        result = append(result, buf[0:n]...) // append is discussed later.\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return \"\", err  // f will be closed if we return here.\n        }\n    }\n    return string(result), nil // f will be closed if we return here.\n}\n```\n\n```\n官方对于Defer的好处声明：\n1. 位置更加接近，更好的可以清晰的看出操作\n2. 防止资源忘了关闭导致的泄露问题\n```\n\n延迟函数（如果函数是方法，则包括接收方）的参数在延迟执行时而不是在调用执行时进行评估。除了避免担心函数执行时变量会更改值外，这还意味着单个延迟的调用站点可以延迟多个函数的执行。这是一个简单的例子。\n```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tfor i := 0; i < 5; i++ {\n    \t\tdefer fmt.Printf(\"%d \", i)\n\t}\n}\n\n-------\noutput:\n4 3 2 1 0 \n```\nDefer函数的执行吮吸是LIFO（LastInFirstOut)栈的结构。\n\n\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc trace(s string) string {\n    fmt.Println(\"entering:\", s)\n    return s\n}\n\nfunc un(s string) {\n    fmt.Println(\"leaving:\", s)\n}\n\nfunc a() {\n    defer un(trace(\"a\"))\n    fmt.Println(\"in a\")\n}\n\nfunc b() {\n    defer un(trace(\"b\"))\n    fmt.Println(\"in b\")\n    a()\n}\n\nfunc main() {\n    b()\n}\n-------------------\noutput\nentering: b\nin b\nentering: a\nin a\nleaving: a\nleaving: b\n```\n\n从上面的例子可以看出来，defer函数只能包含一层，如果像上面的代码 defer un(trace()), 那么会先执行trace()，然后再把un()函数压入defer的栈中。\n\n[更加实际的使用场景相关的例子](https://mp.weixin.qq.com/s/_wZQID0VatIlAiH6-x3U6A)\n\n# <a id=\"ShareNote\"><span class=\"toptitle\">ShareNote</span></a>\n1. [EffectiveGo](https://golang.org/doc/effective_go.html)\n2. [GoInitFunc](https://medium.com/golangspec/init-functions-in-go-eac191b3860a)\n3. [GoInitFunc译文](https://zhuanlan.zhihu.com/p/34211611)","slug":"effective-go","published":1,"updated":"2021-01-21T07:12:05.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6irarw000lk9i5fhb04215","content":"<!-- --- -->\n<!-- layout: post\ntitle: Effective Go Reading\nauthor: Ray Chan(ray1888)\ndate: '2019-09-16 11:07:38 +0800'\ncategory: go\nsummary: Effective Go \nthumbnail: go.png\n--- -->\n\n<p>本文章的目的是为了详细阅读和理解Effective GO所提及到的内容。</p>\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#Method\">Method</a><br>1.1 <a href=\"#PvV\">Pointers vs Values</a>  </li>\n<li><a href=\"#Data\">Data</a><br>2.1 <a href=\"#NewMake\">New vs Make</a><br>2.2 <a href=\"#Array\">Array</a><br>2.3 <a href=\"#Slice\">Slice</a><br>2.4 <a href=\"#Map\">Map</a><br>2.5 <a href=\"#Append\">Append</a>  </li>\n<li><a href=\"#InterFace\">Interface</a></li>\n<li><a href=\"#Error\">Error</a></li>\n<li><a href=\"#Init\">PackageInit</a>  </li>\n<li><a href=\"#Defer\">Defer</a></li>\n<li><a href=\"#ShareNote\">ShareNote</a></li>\n</ol>\n\n        <h1 id=\"Method\"   >\n          <a href=\"#Method\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Method</h1>\n      \n        <h2 id=\"Pointers-vs-Values\"   >\n          <a href=\"#Pointers-vs-Values\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Pointers vs Values</h2>\n      <p>主要的区别，如果方法是放在类型值上面而不是指针上面的，可以通过指针和普通类型来进行使用。但是对于方法绑定的是指针的类型，只能通过指针来进行使用。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">type ByteSlice []byte</span><br><span class=\"line\"></span><br><span class=\"line\">func (slice ByteSlice) Append(data []byte) []byte &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; Body exactly the same as the Append function defined above.</span><br><span class=\"line\">\tl :&#x3D; len(slice)</span><br><span class=\"line\">\tif l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class=\"line\">\t\tnewSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class=\"line\">\t\t&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class=\"line\">\t\tcopy(newSlice, slice)</span><br><span class=\"line\">\t\tslice &#x3D; newSlice</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tslice &#x3D; slice[0 : l+len(data)]</span><br><span class=\"line\">\tcopy(slice[l:], data)</span><br><span class=\"line\">\treturn slice</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *ByteSlice) Append2(data []byte) &#123;</span><br><span class=\"line\">\tslice :&#x3D; *p</span><br><span class=\"line\">\t&#x2F;&#x2F; Body as above, without the return.</span><br><span class=\"line\">\tl :&#x3D; len(slice)</span><br><span class=\"line\">\tif l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class=\"line\">\t\tnewSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class=\"line\">\t\t&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class=\"line\">\t\tcopy(newSlice, slice)</span><br><span class=\"line\">\t\tslice &#x3D; newSlice</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tslice &#x3D; slice[0 : l+len(data)]</span><br><span class=\"line\">\tcopy(slice[l:], data)</span><br><span class=\"line\">\t*p &#x3D; slice</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *ByteSlice) Write(data []byte) (n int, err error) &#123;</span><br><span class=\"line\">\tslice :&#x3D; *p</span><br><span class=\"line\">\t&#x2F;&#x2F; Body as above, without the return.</span><br><span class=\"line\">\tl :&#x3D; len(slice)</span><br><span class=\"line\">\tif l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class=\"line\">\t\tnewSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class=\"line\">\t\t&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class=\"line\">\t\tcopy(newSlice, slice)</span><br><span class=\"line\">\t\tslice &#x3D; newSlice</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tslice &#x3D; slice[0 : l+len(data)]</span><br><span class=\"line\">\tcopy(slice[l:], data)</span><br><span class=\"line\">\t*p &#x3D; slice</span><br><span class=\"line\">\t*p &#x3D; slice</span><br><span class=\"line\">\treturn len(data), nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tvar b ByteSlice</span><br><span class=\"line\">\tb &#x3D; b.Append([]byte&#123;1, 2, 3&#125;)</span><br><span class=\"line\">\tfmt.Printf(&quot;byteSlice 1 is %v&quot;, b)</span><br><span class=\"line\">\tb.Write([]byte&#123;7, 8, 9&#125;)</span><br><span class=\"line\">\tfmt.Printf(&quot;byteSlice 2 is %v&quot;, b)</span><br><span class=\"line\">    &#x2F;*</span><br><span class=\"line\">    func Fprintf(w io.Writer, format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class=\"line\">    *&#x2F;</span><br><span class=\"line\">\tfmt.Fprintf(&amp;b, &quot;This hour has %d days\\n&quot;, 7)</span><br><span class=\"line\">    &#x2F;*</span><br><span class=\"line\">    if use below code , will throw error </span><br><span class=\"line\">    fmt.Fprintf(b, &quot;This hour has %d days\\n&quot;, 7)</span><br><span class=\"line\">    *&#x2F;</span><br><span class=\"line\">\tb.Append2([]byte&#123;4, 5, 6&#125;)</span><br><span class=\"line\">\tfmt.Printf(&quot;byteSlice 3 is %v&quot;, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>上面的例子表达的是，假如直接像注释的代码那样，把B传入一个满足io.Writer的指针的方法中（含有Write方法），但是因为我们的自定义类型上面的Write是指针方法，而不是类型方法，所以会出现类型报错的问题。报错如下</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">as type io.Writer in argument to fmt.Fprintf:</span><br><span class=\"line\">\tByteSlice does not implement io.Writer (Write method has pointer receiver)</span><br></pre></td></tr></table></div></figure>\n<p>根据官方的描述，原文如下：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</span><br><span class=\"line\"></span><br><span class=\"line\">This rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call its Write method with just b.Write. The compiler will rewrite that to (&amp;b).Write for us.</span><br></pre></td></tr></table></div></figure>\n<p>翻译一下：<br>对于接收者类型是指针还是值的规则，值接收者可以 被值或者指针进行调用。而指针方法只能被指针进行调用。</p>\n<p>这个规则的产生的原因是因为指针方法可以修改接受者的值。 但是以值的方式继续调用的情况下，go是会自动把值复制一份，然后继续方法的调用，所有对于里面变量得修改都会被丢弃（因为是值传递，除非使用Return +调用的地方有返回值接收）。 因此语言不允许有这种的错误出现。当值是可以获得地址的情况下，语言会自动把值获取指针传入指针调用的方法里面。 </p>\n\n        <h1 id=\"Data\"   >\n          <a href=\"#Data\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Data</h1>\n      \n        <h2 id=\"New-vs-Make\"   >\n          <a href=\"#New-vs-Make\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>New vs Make</h2>\n      \n        <h3 id=\"New\"   >\n          <a href=\"#New\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>New</h3>\n      <p>New 是 Go里面的分配内存的方法，但是它只会创建一个Zero值（即创建一个0的空间给对应的内存，并且返回这个变量所占有的内存地址）。</p>\n<p>由于由new出来的内存占用为0。这样对于设计你自己的数据结构很有帮助，原因是因为可以默认初始化了0的值，而不用之后再去进行二次的初始化。</p>\n<p>官网上的例子：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">For example, the documentation for bytes.Buffer states that &quot;the zero value for Buffer is an empty buffer ready to use.&quot; Similarly, sync.Mutex does not have an explicit constructor or Init method. Instead, the zero value for a sync.Mutex is defined to be an unlocked mutex.</span><br><span class=\"line\"></span><br><span class=\"line\">The zero-value-is-useful property works transitively. Consider this type declaration.</span><br><span class=\"line\"></span><br><span class=\"line\">type SyncedBuffer struct &#123;</span><br><span class=\"line\">    lock    sync.Mutex</span><br><span class=\"line\">    buffer  bytes.Buffer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>但是有些时候直接初始化0值不要足够，需要一个构建者。像这个例子一样</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func NewFile(fd int, name string) *File &#123;</span><br><span class=\"line\">    if fd &lt; 0 &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f :&#x3D; new(File)</span><br><span class=\"line\">    f.fd &#x3D; fd</span><br><span class=\"line\">    f.name &#x3D; name</span><br><span class=\"line\">    f.dirinfo &#x3D; nil</span><br><span class=\"line\">    f.nepipe &#x3D; 0</span><br><span class=\"line\">    return f</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>因为上面这段代码有比较多的参数，因此我们可以用一个命名的字段来继续初始化</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func NewFile(fd int, name string) *File &#123;</span><br><span class=\"line\">    if fd &lt; 0 &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f :&#x3D; File&#123;fd, name, nil, 0&#125;</span><br><span class=\"line\">    return &amp;f</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>事实上，直接获取复合文字初始化的结构体的地址，实际上会创建一个全新的实例并且赋值，因此我们可以把上面的最后两行代码合成一行代码  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f :&#x3D; File&#123;fd, name, nil, 0&#125;</span><br><span class=\"line\">    return &amp;f</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D; </span><br><span class=\"line\"></span><br><span class=\"line\">return &amp;File&#123;fd, name, nil, 0&#125;</span><br></pre></td></tr></table></div></figure>\n<p>用于和范围： 适用于创建数组、切片、映射（with the field labels being indices or map keys as appropriate）。</p>\n<p>返回值：<br>一个对应类型的指针</p>\n\n        <h3 id=\"Make\"   >\n          <a href=\"#Make\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Make</h3>\n      <p>Make 可以用于创建并且返回一个非nil的值。<br>适用范围：<br>切片、映射、channel  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make([]int,10,100)  &#x2F;&#x2F; 这样是创建了一个容量为100，但是填入了10个0的切片。</span><br></pre></td></tr></table></div></figure>\n<p>官网上面对make的描述</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">For slices, maps, and channels, make initializes the internal data structure and prepares the value for use.</span><br></pre></td></tr></table></div></figure>\n<p>返回值：<br>一个对应类型的数据</p>\n\n        <h3 id=\"Diff\"   >\n          <a href=\"#Diff\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Diff</h3>\n      <p>区别上面的Make和New的目的是为了，对于切片、映射、channel这三种类型，在底层的实现原理中都必须要先创建一个底层的实现才能被引用到，才能在暴露给语言的使用者上面不会抛出错误。<br>所以本质上，new创建出来的可以理解为一个nil的对象，而make创建出来的是一个带有底层数据结构，并且有非nil的对象。<br>而且返回值有所不同。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">func main()&#123;</span><br><span class=\"line\">\t &#x2F;&#x2F; allocates slice structure; *p &#x3D;&#x3D; nil; rarely useful</span><br><span class=\"line\">\tvar p *[]int &#x3D; new([]int)     </span><br><span class=\"line\">\t&#x2F;&#x2F; the slice v now refers to a new array of 100 ints </span><br><span class=\"line\">\tvar v []int &#x3D; make([]int, 5) </span><br><span class=\"line\">\tfmt.Printf(&quot;p values is %v，%v\\n&quot;, p, *p&#x3D;&#x3D;nil)</span><br><span class=\"line\">\tfmt.Printf(&quot;v values is %v, %v\\n&quot;, v, v&#x3D;&#x3D;nil)</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------</span><br><span class=\"line\">p values is &amp;[]，true</span><br><span class=\"line\">v values is [0 0 0 0 0], false</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Array\"   >\n          <a href=\"#Array\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Array</h2>\n      <p>数组在Go的三个特点：</p>\n<ol>\n<li>如果直接把数据传入到一个函数中，则是把这个数组的值拷贝一份，然后把拷贝的副本传到函数中进行使用。</li>\n<li>数组的长度也是它的类型属性之一，[10]int和[20]int不是等价的。</li>\n<li>Array都是值。</li>\n</ol>\n<p>而且有一个使用的小技巧，如果想要减少传递的数据的量，可以直接传入指针，这样可以免于拷贝多一份中间的数据。<br>对于Go来说，因为数组类型支持的方法比较少，而且不能够通过动态去进行特定长度数组创建。因此更加建议的是用Slice来代替数组。  </p>\n\n        <h2 id=\"Slice\"   >\n          <a href=\"#Slice\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Slice</h2>\n      <p>可以看我的博客另外一篇的文章Go Slice上面有提及高级的用法，此处不再重复。  </p>\n\n        <h3 id=\"二维数组和二维切片\"   >\n          <a href=\"#二维数组和二维切片\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>二维数组和二维切片</h3>\n      <p>对于二维数组的声明，可以使用这样的方法  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Transform [3][3]float64  &#x2F;&#x2F; A 3x3 array, really an array of arrays.</span><br><span class=\"line\">type LinesOfText [][]byte     &#x2F;&#x2F; A slice of byte slices.</span><br><span class=\"line\"></span><br><span class=\"line\">text :&#x3D; LinesOfText&#123;</span><br><span class=\"line\">\t[]byte(&quot;Now is the time&quot;),</span><br><span class=\"line\">\t[]byte(&quot;for all good gophers&quot;),</span><br><span class=\"line\">\t[]byte(&quot;to bring some fun to the party.&quot;),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>如果使用Make来继续初始化的情况。需要考虑两个不同的使用场景导致的初始化方式的不同。<br>第一种：如果内部的一位数组可能发生扩展或者收缩，那么就要单独去分配这个一位数组。<br>第二种： 如果内部的数组长度不会发生size变化而只会发生值得变化，则可以进行统一得初始化。(这样性能会比较好，因为可以一次性的调用Allocate的系统函数，减少分配内存的开销)</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; First Method</span><br><span class=\"line\">picture :&#x3D; make([][]uint8, YSize)</span><br><span class=\"line\">for i:&#x3D; range picture&#123;</span><br><span class=\"line\">    picture[i] &#x3D; make([]uint8, XSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Second Method </span><br><span class=\"line\">picture :&#x3D; make([][]uint8, YSize)</span><br><span class=\"line\">pixels :&#x3D; make([]uint8, XSize * YSize)</span><br><span class=\"line\"></span><br><span class=\"line\">for i :&#x3D; range picture&#123;</span><br><span class=\"line\">    picture[i], pixels &#x3D; pixels[:XSize], pixels[XSize:]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Map\"   >\n          <a href=\"#Map\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Map</h2>\n      <p>主要注意当一个Key不存在与一个Map中的情况下，需要使用这种方法来进行判断</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tz map[string]int</span><br><span class=\"line\">var ds string &#x3D; &quot;abc&quot;</span><br><span class=\"line\">if val, ok :&#x3D; tz[ds]; ok&#123;</span><br><span class=\"line\">    return val</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>同理在上面的例子上面，如果反过来进行使用，可以用于判断Key是否存在于Map中。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tz map[string]int</span><br><span class=\"line\">var ds string &#x3D; &quot;abc&quot;</span><br><span class=\"line\">_, exist :&#x3D; tz[ds]</span><br><span class=\"line\">if !exist &#123;</span><br><span class=\"line\">    return &quot;is not exist&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>如果需要删除一个值的情况下,使用delete的函数进行处理</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tz map[string]int</span><br><span class=\"line\">var ds string &#x3D; &quot;abc&quot;</span><br><span class=\"line\">&#x2F;&#x2F; delete(map, key)</span><br><span class=\"line\">delete(tz, ds)</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Append\"   >\n          <a href=\"#Append\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Append</h2>\n      <p>Append 可以接受多个参数</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func append(slice []T, elements ...T) []T</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; use case </span><br><span class=\"line\">x :&#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">x &#x3D; append(x, 4, 5, 6)</span><br><span class=\"line\">fmt.Println(x)</span><br></pre></td></tr></table></div></figure>\n<p>对于如果要把两个数组直接接起来的情况下</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x :&#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">y :&#x3D; []int&#123;4,5,6&#125;</span><br><span class=\"line\">x &#x3D; append(x, y...)</span><br><span class=\"line\">fmt.Println(x)</span><br></pre></td></tr></table></div></figure>\n\n        <h1 id=\"InterFace\"   >\n          <a href=\"#InterFace\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>InterFace</h1>\n      \n        <h2 id=\"Interface\"   >\n          <a href=\"#Interface\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Interface</h2>\n      <p>一个结构体可以实现多个接口，只要它实现了那些接口所定义的方法。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Sequence []int</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Methods required by sort.Interface.</span><br><span class=\"line\">func (s Sequence) Len() int &#123;</span><br><span class=\"line\">    return len(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (s Sequence) Less(i, j int) bool &#123;</span><br><span class=\"line\">    return s[i] &lt; s[j]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (s Sequence) Swap(i, j int) &#123;</span><br><span class=\"line\">    s[i], s[j] &#x3D; s[j], s[i]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Copy returns a copy of the Sequence.</span><br><span class=\"line\">func (s Sequence) Copy() Sequence &#123;</span><br><span class=\"line\">    copy :&#x3D; make(Sequence, 0, len(s))</span><br><span class=\"line\">    return append(copy, s...)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Method for printing - sorts the elements before printing.</span><br><span class=\"line\">func (s Sequence) String() string &#123;</span><br><span class=\"line\">    s &#x3D; s.Copy() &#x2F;&#x2F; Make a copy; don&#39;t overwrite argument.</span><br><span class=\"line\">    sort.Sort(s)</span><br><span class=\"line\">    str :&#x3D; &quot;[&quot;</span><br><span class=\"line\">    for i, elem :&#x3D; range s &#123; &#x2F;&#x2F; Loop is O(N²); will fix that in next example.</span><br><span class=\"line\">        if i &gt; 0 &#123;</span><br><span class=\"line\">            str +&#x3D; &quot; &quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        str +&#x3D; fmt.Sprint(elem)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return str + &quot;]&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Coversions\"   >\n          <a href=\"#Coversions\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Coversions</h2>\n      <p>上面所引用的到方法其实是重新实现了fmt包里面的Sprint方法。我们可以用一些方法来为这个提速，在调用Sprint之前把数据转换成[]int类型，因为Sequence的本质上就<br>是[]int。  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 修改前</span><br><span class=\"line\">func (s Sequence) String() string &#123;</span><br><span class=\"line\">    s &#x3D; s.Copy()</span><br><span class=\"line\">    sort.Sort(s)</span><br><span class=\"line\">    return fmt.Sprint([]int(s))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 修改后</span><br><span class=\"line\">type Sequence []int</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Method for printing - sorts the elements before printing</span><br><span class=\"line\">func (s Sequence) String() string &#123;</span><br><span class=\"line\">    s &#x3D; s.Copy()</span><br><span class=\"line\">    sort.IntSlice(s).Sort()</span><br><span class=\"line\">    return fmt.Sprint([]int(s))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"type-assertions\"   >\n          <a href=\"#type-assertions\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>type assertions</h2>\n      <p>使用Type switch 实际上的操作会把那个变量根据分支的判断的类型来转型。<br>下面这段代码是一个例子，目的是如果不是string类型, 调用其String()进行输出。而如果是，直接输出。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Stringer interface &#123;</span><br><span class=\"line\">    String() string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var value interface&#123;&#125; &#x2F;&#x2F; Value provided by caller.</span><br><span class=\"line\">switch str :&#x3D; value.(type) &#123;</span><br><span class=\"line\">case string:</span><br><span class=\"line\">    return str</span><br><span class=\"line\">case Stringer:</span><br><span class=\"line\">    return str.String()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>如果对于使用场景是单分支，只需要判断接口是否为那个类型的实现的情况下，可以使用</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; </span><br><span class=\"line\">str, ok :&#x3D; value.(string)</span><br></pre></td></tr></table></div></figure>\n<p>注意的是继续类型推断的情况下，必须要填入实际的类型，不能再填入Interface。</p>\n\n        <h2 id=\"Generality\"   >\n          <a href=\"#Generality\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Generality</h2>\n      <p>如果包里面的一个类型只是为了实现接口并且其他方法不需要进行导出给外部使用的情况下。只需要导出接口就好，这样可以避免对于使用者不感兴趣的方法的实现的复杂度。<br>如官方的Hash模块，crc32.NewIEEE 和 adler32.New这两个方法都是返回 接口类型Hash.Hash32。</p>\n\n        <h2 id=\"interface-amp-method\"   >\n          <a href=\"#interface-amp-method\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>interface &amp; method</h2>\n      <p>只要这个类型实现了这个接口的所有方法，即可以把这个类型传入来当接口使用.可以理解为简单的依赖翻转。</p>\n\n        <h1 id=\"Error\"   >\n          <a href=\"#Error\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Error</h1>\n      \n        <h2 id=\"Defination\"   >\n          <a href=\"#Defination\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Defination</h2>\n      <p>Error 接口在代码里面的定义是这样的。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type error interface &#123;</span><br><span class=\"line\">    Error() string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>如果需要实现一个自定义的Error（添加部分与业务相关的信息）</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; PathError records an error and the operation and</span><br><span class=\"line\">&#x2F;&#x2F; file path that caused it.</span><br><span class=\"line\">type PathError struct &#123;</span><br><span class=\"line\">    Op string    &#x2F;&#x2F; &quot;open&quot;, &quot;unlink&quot;, etc.</span><br><span class=\"line\">    Path string  &#x2F;&#x2F; The associated file.</span><br><span class=\"line\">    Err error    &#x2F;&#x2F; Returned by the system call.</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (e *PathError) Error() string &#123;</span><br><span class=\"line\">    return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>并且建议的可行方法，错误信息应该能够表明他们的来源（即发生错误的模块是哪个模块的哪个函数）。<br>一般来说，函数调用者如果关心具体的错误信息的话，可以使用一个类型switch来获取具体的错误类型和相信信息。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for try :&#x3D; 0; try &lt; 2; try++ &#123;</span><br><span class=\"line\">    file, err &#x3D; os.Create(filename)</span><br><span class=\"line\">    if err &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if e, ok :&#x3D; err.(*os.PathError); ok &amp;&amp; e.Err &#x3D;&#x3D; syscall.ENOSPC &#123;</span><br><span class=\"line\">        deleteTempFiles()  &#x2F;&#x2F; Recover some space.</span><br><span class=\"line\">        continue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Panic\"   >\n          <a href=\"#Panic\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Panic</h2>\n      <p>对于预设以内的错误，返回错误的方式应该是返回错误的信息为多一个参数.</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">func Get() (string, Error)&#123;</span><br><span class=\"line\">    return &quot;&quot;, nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">k, err :&#x3D; Get()</span><br></pre></td></tr></table></div></figure>\n<p>但是对于不可恢复的错误，我们不能让程序继续运行。<br>Panic()的作用是创建一个Runtime Error并且使得程序无法继续运行。<br>Panic可以接受任意长度的参数，并且打印到日志上，</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func CubeRoot(x float64) float64 &#123;</span><br><span class=\"line\">    z :&#x3D; x&#x2F;3   &#x2F;&#x2F; Arbitrary initial value</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; 1e6; i++ &#123;</span><br><span class=\"line\">        prevz :&#x3D; z</span><br><span class=\"line\">        z -&#x3D; (z*z*z-x) &#x2F; (3*z*z)</span><br><span class=\"line\">        if veryClose(z, prevz) &#123;</span><br><span class=\"line\">            return z</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; A million iterations has not converged; something is wrong.</span><br><span class=\"line\">    panic(fmt.Sprintf(&quot;CubeRoot(%g) did not converge&quot;, x))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>官方对于Panic的态度：程序员应该尽可能的去考虑并且解决所有的异常的情况。<br>对于真实的代码库上面不建议使用这个方法。</p>\n\n        <h2 id=\"Recover\"   >\n          <a href=\"#Recover\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Recover</h2>\n      <p>用于恢复发生Panic的Goroutine。但是必须在panic前面的地方添加一个defer 并且把Recover函数放入其中。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func server(workChan &lt;-chan *Work) &#123;</span><br><span class=\"line\">    for work :&#x3D; range workChan &#123;</span><br><span class=\"line\">        go safelyDo(work)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func safelyDo(work *Work) &#123;</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class=\"line\">            log.Println(&quot;work failed:&quot;, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    do(work)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>官方库中处理复杂错误的例子，Regexp</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Error is the type of a parse error; it satisfies the error interface.</span><br><span class=\"line\">type Error string</span><br><span class=\"line\">func (e Error) Error() string &#123;</span><br><span class=\"line\">    return string(e)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; error is a method of *Regexp that reports parsing errors by</span><br><span class=\"line\">&#x2F;&#x2F; panicking with an Error.</span><br><span class=\"line\">func (regexp *Regexp) error(err string) &#123;</span><br><span class=\"line\">    panic(Error(err))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Compile returns a parsed representation of the regular expression.</span><br><span class=\"line\">func Compile(str string) (regexp *Regexp, err error) &#123;</span><br><span class=\"line\">    regexp &#x3D; new(Regexp)</span><br><span class=\"line\">    &#x2F;&#x2F; doParse will panic if there is a parse error.</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        if e :&#x3D; recover(); e !&#x3D; nil &#123;</span><br><span class=\"line\">            regexp &#x3D; nil    &#x2F;&#x2F; Clear return value.</span><br><span class=\"line\">            err &#x3D; e.(Error) &#x2F;&#x2F; Will re-panic if not a parse error.</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return regexp.doParse(str), nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>即使上面把regexp 的类型变成了nil。但是如果在e判断类型的时候如果不是Error的类型。程序仍然会发生错误，并且崩溃推出。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if pos &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">    re.error(&quot;&#39;*&#39; illegal at start of expression&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>对于上面的这种re-panic的策略，官方建议是在一个包内进行使用，这样就不会把错误暴露给Client。<br>虽然re-panic最终程序还是崩溃了，但是这样可以使得程序具体的错误可以过滤一层，并且找到更加直接的错误的原因。</p>\n\n        <h1 id=\"PackageInit\"   >\n          <a href=\"#PackageInit\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PackageInit</h1>\n      <p>可以直接看<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://zhuanlan.zhihu.com/p/34211611\" >译文</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>即可。</p>\n<p>也可以直接读介绍的<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://medium.com/golangspec/init-functions-in-go-eac191b3860a\" >原文</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h1 id=\"Defer\"   >\n          <a href=\"#Defer\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Defer</h1>\n      <p>Defer语法是在函数返回前进行调度的清除函数调用。它能够很好地处理多分支返回情况下的释放资源的问题。（类似于Python的With语法）</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func Contents(filename string) (string, error) &#123;</span><br><span class=\"line\">    f, err :&#x3D; os.Open(filename)</span><br><span class=\"line\">    if err !&#x3D; nil &#123;</span><br><span class=\"line\">        return &quot;&quot;, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    defer f.Close()  &#x2F;&#x2F; f.Close will run when we&#39;re finished.</span><br><span class=\"line\"></span><br><span class=\"line\">    var result []byte</span><br><span class=\"line\">    buf :&#x3D; make([]byte, 100)</span><br><span class=\"line\">    for &#123;</span><br><span class=\"line\">        n, err :&#x3D; f.Read(buf[0:])</span><br><span class=\"line\">        result &#x3D; append(result, buf[0:n]...) &#x2F;&#x2F; append is discussed later.</span><br><span class=\"line\">        if err !&#x3D; nil &#123;</span><br><span class=\"line\">            if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class=\"line\">                break</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return &quot;&quot;, err  &#x2F;&#x2F; f will be closed if we return here.</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return string(result), nil &#x2F;&#x2F; f will be closed if we return here.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">官方对于Defer的好处声明：</span><br><span class=\"line\">1. 位置更加接近，更好的可以清晰的看出操作</span><br><span class=\"line\">2. 防止资源忘了关闭导致的泄露问题</span><br></pre></td></tr></table></div></figure>\n<p>延迟函数（如果函数是方法，则包括接收方）的参数在延迟执行时而不是在调用执行时进行评估。除了避免担心函数执行时变量会更改值外，这还意味着单个延迟的调用站点可以延迟多个函数的执行。这是一个简单的例子。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class=\"line\">    \t\tdefer fmt.Printf(&quot;%d &quot;, i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-------</span><br><span class=\"line\">output:</span><br><span class=\"line\">4 3 2 1 0 </span><br></pre></td></tr></table></div></figure>\n<p>Defer函数的执行吮吸是LIFO（LastInFirstOut)栈的结构。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">func trace(s string) string &#123;</span><br><span class=\"line\">    fmt.Println(&quot;entering:&quot;, s)</span><br><span class=\"line\">    return s</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func un(s string) &#123;</span><br><span class=\"line\">    fmt.Println(&quot;leaving:&quot;, s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func a() &#123;</span><br><span class=\"line\">    defer un(trace(&quot;a&quot;))</span><br><span class=\"line\">    fmt.Println(&quot;in a&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func b() &#123;</span><br><span class=\"line\">    defer un(trace(&quot;b&quot;))</span><br><span class=\"line\">    fmt.Println(&quot;in b&quot;)</span><br><span class=\"line\">    a()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">output</span><br><span class=\"line\">entering: b</span><br><span class=\"line\">in b</span><br><span class=\"line\">entering: a</span><br><span class=\"line\">in a</span><br><span class=\"line\">leaving: a</span><br><span class=\"line\">leaving: b</span><br></pre></td></tr></table></div></figure>\n<p>从上面的例子可以看出来，defer函数只能包含一层，如果像上面的代码 defer un(trace()), 那么会先执行trace()，然后再把un()函数压入defer的栈中。</p>\n<p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://mp.weixin.qq.com/s/_wZQID0VatIlAiH6-x3U6A\" >更加实际的使用场景相关的例子</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://golang.org/doc/effective_go.html\" >EffectiveGo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://medium.com/golangspec/init-functions-in-go-eac191b3860a\" >GoInitFunc</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://zhuanlan.zhihu.com/p/34211611\" >GoInitFunc译文</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<!-- --- -->\n<!-- layout: post\ntitle: Effective Go Reading\nauthor: Ray Chan(ray1888)\ndate: '2019-09-16 11:07:38 +0800'\ncategory: go\nsummary: Effective Go \nthumbnail: go.png\n--- -->\n\n<p>本文章的目的是为了详细阅读和理解Effective GO所提及到的内容。</p>\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#Method\">Method</a><br>1.1 <a href=\"#PvV\">Pointers vs Values</a>  </li>\n<li><a href=\"#Data\">Data</a><br>2.1 <a href=\"#NewMake\">New vs Make</a><br>2.2 <a href=\"#Array\">Array</a><br>2.3 <a href=\"#Slice\">Slice</a><br>2.4 <a href=\"#Map\">Map</a><br>2.5 <a href=\"#Append\">Append</a>  </li>\n<li><a href=\"#InterFace\">Interface</a></li>\n<li><a href=\"#Error\">Error</a></li>\n<li><a href=\"#Init\">PackageInit</a>  </li>\n<li><a href=\"#Defer\">Defer</a></li>\n<li><a href=\"#ShareNote\">ShareNote</a></li>\n</ol>\n\n        <h1 id=\"Method\"   >\n          <a href=\"#Method\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Method</h1>\n      \n        <h2 id=\"Pointers-vs-Values\"   >\n          <a href=\"#Pointers-vs-Values\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Pointers vs Values</h2>\n      <p>主要的区别，如果方法是放在类型值上面而不是指针上面的，可以通过指针和普通类型来进行使用。但是对于方法绑定的是指针的类型，只能通过指针来进行使用。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">type ByteSlice []byte</span><br><span class=\"line\"></span><br><span class=\"line\">func (slice ByteSlice) Append(data []byte) []byte &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; Body exactly the same as the Append function defined above.</span><br><span class=\"line\">\tl :&#x3D; len(slice)</span><br><span class=\"line\">\tif l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class=\"line\">\t\tnewSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class=\"line\">\t\t&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class=\"line\">\t\tcopy(newSlice, slice)</span><br><span class=\"line\">\t\tslice &#x3D; newSlice</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tslice &#x3D; slice[0 : l+len(data)]</span><br><span class=\"line\">\tcopy(slice[l:], data)</span><br><span class=\"line\">\treturn slice</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *ByteSlice) Append2(data []byte) &#123;</span><br><span class=\"line\">\tslice :&#x3D; *p</span><br><span class=\"line\">\t&#x2F;&#x2F; Body as above, without the return.</span><br><span class=\"line\">\tl :&#x3D; len(slice)</span><br><span class=\"line\">\tif l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class=\"line\">\t\tnewSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class=\"line\">\t\t&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class=\"line\">\t\tcopy(newSlice, slice)</span><br><span class=\"line\">\t\tslice &#x3D; newSlice</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tslice &#x3D; slice[0 : l+len(data)]</span><br><span class=\"line\">\tcopy(slice[l:], data)</span><br><span class=\"line\">\t*p &#x3D; slice</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (p *ByteSlice) Write(data []byte) (n int, err error) &#123;</span><br><span class=\"line\">\tslice :&#x3D; *p</span><br><span class=\"line\">\t&#x2F;&#x2F; Body as above, without the return.</span><br><span class=\"line\">\tl :&#x3D; len(slice)</span><br><span class=\"line\">\tif l+len(data) &gt; cap(slice) &#123; &#x2F;&#x2F; reallocate</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class=\"line\">\t\tnewSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class=\"line\">\t\t&#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class=\"line\">\t\tcopy(newSlice, slice)</span><br><span class=\"line\">\t\tslice &#x3D; newSlice</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tslice &#x3D; slice[0 : l+len(data)]</span><br><span class=\"line\">\tcopy(slice[l:], data)</span><br><span class=\"line\">\t*p &#x3D; slice</span><br><span class=\"line\">\t*p &#x3D; slice</span><br><span class=\"line\">\treturn len(data), nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tvar b ByteSlice</span><br><span class=\"line\">\tb &#x3D; b.Append([]byte&#123;1, 2, 3&#125;)</span><br><span class=\"line\">\tfmt.Printf(&quot;byteSlice 1 is %v&quot;, b)</span><br><span class=\"line\">\tb.Write([]byte&#123;7, 8, 9&#125;)</span><br><span class=\"line\">\tfmt.Printf(&quot;byteSlice 2 is %v&quot;, b)</span><br><span class=\"line\">    &#x2F;*</span><br><span class=\"line\">    func Fprintf(w io.Writer, format string, a ...interface&#123;&#125;) (n int, err error)</span><br><span class=\"line\">    *&#x2F;</span><br><span class=\"line\">\tfmt.Fprintf(&amp;b, &quot;This hour has %d days\\n&quot;, 7)</span><br><span class=\"line\">    &#x2F;*</span><br><span class=\"line\">    if use below code , will throw error </span><br><span class=\"line\">    fmt.Fprintf(b, &quot;This hour has %d days\\n&quot;, 7)</span><br><span class=\"line\">    *&#x2F;</span><br><span class=\"line\">\tb.Append2([]byte&#123;4, 5, 6&#125;)</span><br><span class=\"line\">\tfmt.Printf(&quot;byteSlice 3 is %v&quot;, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>上面的例子表达的是，假如直接像注释的代码那样，把B传入一个满足io.Writer的指针的方法中（含有Write方法），但是因为我们的自定义类型上面的Write是指针方法，而不是类型方法，所以会出现类型报错的问题。报错如下</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">as type io.Writer in argument to fmt.Fprintf:</span><br><span class=\"line\">\tByteSlice does not implement io.Writer (Write method has pointer receiver)</span><br></pre></td></tr></table></div></figure>\n<p>根据官方的描述，原文如下：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</span><br><span class=\"line\"></span><br><span class=\"line\">This rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call its Write method with just b.Write. The compiler will rewrite that to (&amp;b).Write for us.</span><br></pre></td></tr></table></div></figure>\n<p>翻译一下：<br>对于接收者类型是指针还是值的规则，值接收者可以 被值或者指针进行调用。而指针方法只能被指针进行调用。</p>\n<p>这个规则的产生的原因是因为指针方法可以修改接受者的值。 但是以值的方式继续调用的情况下，go是会自动把值复制一份，然后继续方法的调用，所有对于里面变量得修改都会被丢弃（因为是值传递，除非使用Return +调用的地方有返回值接收）。 因此语言不允许有这种的错误出现。当值是可以获得地址的情况下，语言会自动把值获取指针传入指针调用的方法里面。 </p>\n\n        <h1 id=\"Data\"   >\n          <a href=\"#Data\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Data</h1>\n      \n        <h2 id=\"New-vs-Make\"   >\n          <a href=\"#New-vs-Make\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>New vs Make</h2>\n      \n        <h3 id=\"New\"   >\n          <a href=\"#New\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>New</h3>\n      <p>New 是 Go里面的分配内存的方法，但是它只会创建一个Zero值（即创建一个0的空间给对应的内存，并且返回这个变量所占有的内存地址）。</p>\n<p>由于由new出来的内存占用为0。这样对于设计你自己的数据结构很有帮助，原因是因为可以默认初始化了0的值，而不用之后再去进行二次的初始化。</p>\n<p>官网上的例子：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">For example, the documentation for bytes.Buffer states that &quot;the zero value for Buffer is an empty buffer ready to use.&quot; Similarly, sync.Mutex does not have an explicit constructor or Init method. Instead, the zero value for a sync.Mutex is defined to be an unlocked mutex.</span><br><span class=\"line\"></span><br><span class=\"line\">The zero-value-is-useful property works transitively. Consider this type declaration.</span><br><span class=\"line\"></span><br><span class=\"line\">type SyncedBuffer struct &#123;</span><br><span class=\"line\">    lock    sync.Mutex</span><br><span class=\"line\">    buffer  bytes.Buffer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>但是有些时候直接初始化0值不要足够，需要一个构建者。像这个例子一样</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func NewFile(fd int, name string) *File &#123;</span><br><span class=\"line\">    if fd &lt; 0 &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f :&#x3D; new(File)</span><br><span class=\"line\">    f.fd &#x3D; fd</span><br><span class=\"line\">    f.name &#x3D; name</span><br><span class=\"line\">    f.dirinfo &#x3D; nil</span><br><span class=\"line\">    f.nepipe &#x3D; 0</span><br><span class=\"line\">    return f</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>因为上面这段代码有比较多的参数，因此我们可以用一个命名的字段来继续初始化</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func NewFile(fd int, name string) *File &#123;</span><br><span class=\"line\">    if fd &lt; 0 &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f :&#x3D; File&#123;fd, name, nil, 0&#125;</span><br><span class=\"line\">    return &amp;f</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>事实上，直接获取复合文字初始化的结构体的地址，实际上会创建一个全新的实例并且赋值，因此我们可以把上面的最后两行代码合成一行代码  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f :&#x3D; File&#123;fd, name, nil, 0&#125;</span><br><span class=\"line\">    return &amp;f</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D; </span><br><span class=\"line\"></span><br><span class=\"line\">return &amp;File&#123;fd, name, nil, 0&#125;</span><br></pre></td></tr></table></div></figure>\n<p>用于和范围： 适用于创建数组、切片、映射（with the field labels being indices or map keys as appropriate）。</p>\n<p>返回值：<br>一个对应类型的指针</p>\n\n        <h3 id=\"Make\"   >\n          <a href=\"#Make\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Make</h3>\n      <p>Make 可以用于创建并且返回一个非nil的值。<br>适用范围：<br>切片、映射、channel  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make([]int,10,100)  &#x2F;&#x2F; 这样是创建了一个容量为100，但是填入了10个0的切片。</span><br></pre></td></tr></table></div></figure>\n<p>官网上面对make的描述</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">For slices, maps, and channels, make initializes the internal data structure and prepares the value for use.</span><br></pre></td></tr></table></div></figure>\n<p>返回值：<br>一个对应类型的数据</p>\n\n        <h3 id=\"Diff\"   >\n          <a href=\"#Diff\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Diff</h3>\n      <p>区别上面的Make和New的目的是为了，对于切片、映射、channel这三种类型，在底层的实现原理中都必须要先创建一个底层的实现才能被引用到，才能在暴露给语言的使用者上面不会抛出错误。<br>所以本质上，new创建出来的可以理解为一个nil的对象，而make创建出来的是一个带有底层数据结构，并且有非nil的对象。<br>而且返回值有所不同。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">func main()&#123;</span><br><span class=\"line\">\t &#x2F;&#x2F; allocates slice structure; *p &#x3D;&#x3D; nil; rarely useful</span><br><span class=\"line\">\tvar p *[]int &#x3D; new([]int)     </span><br><span class=\"line\">\t&#x2F;&#x2F; the slice v now refers to a new array of 100 ints </span><br><span class=\"line\">\tvar v []int &#x3D; make([]int, 5) </span><br><span class=\"line\">\tfmt.Printf(&quot;p values is %v，%v\\n&quot;, p, *p&#x3D;&#x3D;nil)</span><br><span class=\"line\">\tfmt.Printf(&quot;v values is %v, %v\\n&quot;, v, v&#x3D;&#x3D;nil)</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------</span><br><span class=\"line\">p values is &amp;[]，true</span><br><span class=\"line\">v values is [0 0 0 0 0], false</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Array\"   >\n          <a href=\"#Array\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Array</h2>\n      <p>数组在Go的三个特点：</p>\n<ol>\n<li>如果直接把数据传入到一个函数中，则是把这个数组的值拷贝一份，然后把拷贝的副本传到函数中进行使用。</li>\n<li>数组的长度也是它的类型属性之一，[10]int和[20]int不是等价的。</li>\n<li>Array都是值。</li>\n</ol>\n<p>而且有一个使用的小技巧，如果想要减少传递的数据的量，可以直接传入指针，这样可以免于拷贝多一份中间的数据。<br>对于Go来说，因为数组类型支持的方法比较少，而且不能够通过动态去进行特定长度数组创建。因此更加建议的是用Slice来代替数组。  </p>\n\n        <h2 id=\"Slice\"   >\n          <a href=\"#Slice\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Slice</h2>\n      <p>可以看我的博客另外一篇的文章Go Slice上面有提及高级的用法，此处不再重复。  </p>\n\n        <h3 id=\"二维数组和二维切片\"   >\n          <a href=\"#二维数组和二维切片\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>二维数组和二维切片</h3>\n      <p>对于二维数组的声明，可以使用这样的方法  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Transform [3][3]float64  &#x2F;&#x2F; A 3x3 array, really an array of arrays.</span><br><span class=\"line\">type LinesOfText [][]byte     &#x2F;&#x2F; A slice of byte slices.</span><br><span class=\"line\"></span><br><span class=\"line\">text :&#x3D; LinesOfText&#123;</span><br><span class=\"line\">\t[]byte(&quot;Now is the time&quot;),</span><br><span class=\"line\">\t[]byte(&quot;for all good gophers&quot;),</span><br><span class=\"line\">\t[]byte(&quot;to bring some fun to the party.&quot;),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>如果使用Make来继续初始化的情况。需要考虑两个不同的使用场景导致的初始化方式的不同。<br>第一种：如果内部的一位数组可能发生扩展或者收缩，那么就要单独去分配这个一位数组。<br>第二种： 如果内部的数组长度不会发生size变化而只会发生值得变化，则可以进行统一得初始化。(这样性能会比较好，因为可以一次性的调用Allocate的系统函数，减少分配内存的开销)</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; First Method</span><br><span class=\"line\">picture :&#x3D; make([][]uint8, YSize)</span><br><span class=\"line\">for i:&#x3D; range picture&#123;</span><br><span class=\"line\">    picture[i] &#x3D; make([]uint8, XSize)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Second Method </span><br><span class=\"line\">picture :&#x3D; make([][]uint8, YSize)</span><br><span class=\"line\">pixels :&#x3D; make([]uint8, XSize * YSize)</span><br><span class=\"line\"></span><br><span class=\"line\">for i :&#x3D; range picture&#123;</span><br><span class=\"line\">    picture[i], pixels &#x3D; pixels[:XSize], pixels[XSize:]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Map\"   >\n          <a href=\"#Map\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Map</h2>\n      <p>主要注意当一个Key不存在与一个Map中的情况下，需要使用这种方法来进行判断</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tz map[string]int</span><br><span class=\"line\">var ds string &#x3D; &quot;abc&quot;</span><br><span class=\"line\">if val, ok :&#x3D; tz[ds]; ok&#123;</span><br><span class=\"line\">    return val</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>同理在上面的例子上面，如果反过来进行使用，可以用于判断Key是否存在于Map中。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tz map[string]int</span><br><span class=\"line\">var ds string &#x3D; &quot;abc&quot;</span><br><span class=\"line\">_, exist :&#x3D; tz[ds]</span><br><span class=\"line\">if !exist &#123;</span><br><span class=\"line\">    return &quot;is not exist&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>如果需要删除一个值的情况下,使用delete的函数进行处理</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tz map[string]int</span><br><span class=\"line\">var ds string &#x3D; &quot;abc&quot;</span><br><span class=\"line\">&#x2F;&#x2F; delete(map, key)</span><br><span class=\"line\">delete(tz, ds)</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Append\"   >\n          <a href=\"#Append\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Append</h2>\n      <p>Append 可以接受多个参数</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func append(slice []T, elements ...T) []T</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; use case </span><br><span class=\"line\">x :&#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">x &#x3D; append(x, 4, 5, 6)</span><br><span class=\"line\">fmt.Println(x)</span><br></pre></td></tr></table></div></figure>\n<p>对于如果要把两个数组直接接起来的情况下</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x :&#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">y :&#x3D; []int&#123;4,5,6&#125;</span><br><span class=\"line\">x &#x3D; append(x, y...)</span><br><span class=\"line\">fmt.Println(x)</span><br></pre></td></tr></table></div></figure>\n\n        <h1 id=\"InterFace\"   >\n          <a href=\"#InterFace\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>InterFace</h1>\n      \n        <h2 id=\"Interface\"   >\n          <a href=\"#Interface\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Interface</h2>\n      <p>一个结构体可以实现多个接口，只要它实现了那些接口所定义的方法。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Sequence []int</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Methods required by sort.Interface.</span><br><span class=\"line\">func (s Sequence) Len() int &#123;</span><br><span class=\"line\">    return len(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (s Sequence) Less(i, j int) bool &#123;</span><br><span class=\"line\">    return s[i] &lt; s[j]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (s Sequence) Swap(i, j int) &#123;</span><br><span class=\"line\">    s[i], s[j] &#x3D; s[j], s[i]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Copy returns a copy of the Sequence.</span><br><span class=\"line\">func (s Sequence) Copy() Sequence &#123;</span><br><span class=\"line\">    copy :&#x3D; make(Sequence, 0, len(s))</span><br><span class=\"line\">    return append(copy, s...)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Method for printing - sorts the elements before printing.</span><br><span class=\"line\">func (s Sequence) String() string &#123;</span><br><span class=\"line\">    s &#x3D; s.Copy() &#x2F;&#x2F; Make a copy; don&#39;t overwrite argument.</span><br><span class=\"line\">    sort.Sort(s)</span><br><span class=\"line\">    str :&#x3D; &quot;[&quot;</span><br><span class=\"line\">    for i, elem :&#x3D; range s &#123; &#x2F;&#x2F; Loop is O(N²); will fix that in next example.</span><br><span class=\"line\">        if i &gt; 0 &#123;</span><br><span class=\"line\">            str +&#x3D; &quot; &quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        str +&#x3D; fmt.Sprint(elem)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return str + &quot;]&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Coversions\"   >\n          <a href=\"#Coversions\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Coversions</h2>\n      <p>上面所引用的到方法其实是重新实现了fmt包里面的Sprint方法。我们可以用一些方法来为这个提速，在调用Sprint之前把数据转换成[]int类型，因为Sequence的本质上就<br>是[]int。  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 修改前</span><br><span class=\"line\">func (s Sequence) String() string &#123;</span><br><span class=\"line\">    s &#x3D; s.Copy()</span><br><span class=\"line\">    sort.Sort(s)</span><br><span class=\"line\">    return fmt.Sprint([]int(s))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 修改后</span><br><span class=\"line\">type Sequence []int</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Method for printing - sorts the elements before printing</span><br><span class=\"line\">func (s Sequence) String() string &#123;</span><br><span class=\"line\">    s &#x3D; s.Copy()</span><br><span class=\"line\">    sort.IntSlice(s).Sort()</span><br><span class=\"line\">    return fmt.Sprint([]int(s))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"type-assertions\"   >\n          <a href=\"#type-assertions\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>type assertions</h2>\n      <p>使用Type switch 实际上的操作会把那个变量根据分支的判断的类型来转型。<br>下面这段代码是一个例子，目的是如果不是string类型, 调用其String()进行输出。而如果是，直接输出。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Stringer interface &#123;</span><br><span class=\"line\">    String() string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var value interface&#123;&#125; &#x2F;&#x2F; Value provided by caller.</span><br><span class=\"line\">switch str :&#x3D; value.(type) &#123;</span><br><span class=\"line\">case string:</span><br><span class=\"line\">    return str</span><br><span class=\"line\">case Stringer:</span><br><span class=\"line\">    return str.String()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>如果对于使用场景是单分支，只需要判断接口是否为那个类型的实现的情况下，可以使用</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; </span><br><span class=\"line\">str, ok :&#x3D; value.(string)</span><br></pre></td></tr></table></div></figure>\n<p>注意的是继续类型推断的情况下，必须要填入实际的类型，不能再填入Interface。</p>\n\n        <h2 id=\"Generality\"   >\n          <a href=\"#Generality\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Generality</h2>\n      <p>如果包里面的一个类型只是为了实现接口并且其他方法不需要进行导出给外部使用的情况下。只需要导出接口就好，这样可以避免对于使用者不感兴趣的方法的实现的复杂度。<br>如官方的Hash模块，crc32.NewIEEE 和 adler32.New这两个方法都是返回 接口类型Hash.Hash32。</p>\n\n        <h2 id=\"interface-amp-method\"   >\n          <a href=\"#interface-amp-method\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>interface &amp; method</h2>\n      <p>只要这个类型实现了这个接口的所有方法，即可以把这个类型传入来当接口使用.可以理解为简单的依赖翻转。</p>\n\n        <h1 id=\"Error\"   >\n          <a href=\"#Error\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Error</h1>\n      \n        <h2 id=\"Defination\"   >\n          <a href=\"#Defination\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Defination</h2>\n      <p>Error 接口在代码里面的定义是这样的。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type error interface &#123;</span><br><span class=\"line\">    Error() string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>如果需要实现一个自定义的Error（添加部分与业务相关的信息）</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; PathError records an error and the operation and</span><br><span class=\"line\">&#x2F;&#x2F; file path that caused it.</span><br><span class=\"line\">type PathError struct &#123;</span><br><span class=\"line\">    Op string    &#x2F;&#x2F; &quot;open&quot;, &quot;unlink&quot;, etc.</span><br><span class=\"line\">    Path string  &#x2F;&#x2F; The associated file.</span><br><span class=\"line\">    Err error    &#x2F;&#x2F; Returned by the system call.</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (e *PathError) Error() string &#123;</span><br><span class=\"line\">    return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>并且建议的可行方法，错误信息应该能够表明他们的来源（即发生错误的模块是哪个模块的哪个函数）。<br>一般来说，函数调用者如果关心具体的错误信息的话，可以使用一个类型switch来获取具体的错误类型和相信信息。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for try :&#x3D; 0; try &lt; 2; try++ &#123;</span><br><span class=\"line\">    file, err &#x3D; os.Create(filename)</span><br><span class=\"line\">    if err &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if e, ok :&#x3D; err.(*os.PathError); ok &amp;&amp; e.Err &#x3D;&#x3D; syscall.ENOSPC &#123;</span><br><span class=\"line\">        deleteTempFiles()  &#x2F;&#x2F; Recover some space.</span><br><span class=\"line\">        continue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"Panic\"   >\n          <a href=\"#Panic\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Panic</h2>\n      <p>对于预设以内的错误，返回错误的方式应该是返回错误的信息为多一个参数.</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">func Get() (string, Error)&#123;</span><br><span class=\"line\">    return &quot;&quot;, nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">k, err :&#x3D; Get()</span><br></pre></td></tr></table></div></figure>\n<p>但是对于不可恢复的错误，我们不能让程序继续运行。<br>Panic()的作用是创建一个Runtime Error并且使得程序无法继续运行。<br>Panic可以接受任意长度的参数，并且打印到日志上，</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func CubeRoot(x float64) float64 &#123;</span><br><span class=\"line\">    z :&#x3D; x&#x2F;3   &#x2F;&#x2F; Arbitrary initial value</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; 1e6; i++ &#123;</span><br><span class=\"line\">        prevz :&#x3D; z</span><br><span class=\"line\">        z -&#x3D; (z*z*z-x) &#x2F; (3*z*z)</span><br><span class=\"line\">        if veryClose(z, prevz) &#123;</span><br><span class=\"line\">            return z</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; A million iterations has not converged; something is wrong.</span><br><span class=\"line\">    panic(fmt.Sprintf(&quot;CubeRoot(%g) did not converge&quot;, x))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>官方对于Panic的态度：程序员应该尽可能的去考虑并且解决所有的异常的情况。<br>对于真实的代码库上面不建议使用这个方法。</p>\n\n        <h2 id=\"Recover\"   >\n          <a href=\"#Recover\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Recover</h2>\n      <p>用于恢复发生Panic的Goroutine。但是必须在panic前面的地方添加一个defer 并且把Recover函数放入其中。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func server(workChan &lt;-chan *Work) &#123;</span><br><span class=\"line\">    for work :&#x3D; range workChan &#123;</span><br><span class=\"line\">        go safelyDo(work)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func safelyDo(work *Work) &#123;</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class=\"line\">            log.Println(&quot;work failed:&quot;, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    do(work)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>官方库中处理复杂错误的例子，Regexp</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Error is the type of a parse error; it satisfies the error interface.</span><br><span class=\"line\">type Error string</span><br><span class=\"line\">func (e Error) Error() string &#123;</span><br><span class=\"line\">    return string(e)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; error is a method of *Regexp that reports parsing errors by</span><br><span class=\"line\">&#x2F;&#x2F; panicking with an Error.</span><br><span class=\"line\">func (regexp *Regexp) error(err string) &#123;</span><br><span class=\"line\">    panic(Error(err))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Compile returns a parsed representation of the regular expression.</span><br><span class=\"line\">func Compile(str string) (regexp *Regexp, err error) &#123;</span><br><span class=\"line\">    regexp &#x3D; new(Regexp)</span><br><span class=\"line\">    &#x2F;&#x2F; doParse will panic if there is a parse error.</span><br><span class=\"line\">    defer func() &#123;</span><br><span class=\"line\">        if e :&#x3D; recover(); e !&#x3D; nil &#123;</span><br><span class=\"line\">            regexp &#x3D; nil    &#x2F;&#x2F; Clear return value.</span><br><span class=\"line\">            err &#x3D; e.(Error) &#x2F;&#x2F; Will re-panic if not a parse error.</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    return regexp.doParse(str), nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>即使上面把regexp 的类型变成了nil。但是如果在e判断类型的时候如果不是Error的类型。程序仍然会发生错误，并且崩溃推出。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if pos &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">    re.error(&quot;&#39;*&#39; illegal at start of expression&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>对于上面的这种re-panic的策略，官方建议是在一个包内进行使用，这样就不会把错误暴露给Client。<br>虽然re-panic最终程序还是崩溃了，但是这样可以使得程序具体的错误可以过滤一层，并且找到更加直接的错误的原因。</p>\n\n        <h1 id=\"PackageInit\"   >\n          <a href=\"#PackageInit\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PackageInit</h1>\n      <p>可以直接看<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://zhuanlan.zhihu.com/p/34211611\" >译文</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span>即可。</p>\n<p>也可以直接读介绍的<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://medium.com/golangspec/init-functions-in-go-eac191b3860a\" >原文</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h1 id=\"Defer\"   >\n          <a href=\"#Defer\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Defer</h1>\n      <p>Defer语法是在函数返回前进行调度的清除函数调用。它能够很好地处理多分支返回情况下的释放资源的问题。（类似于Python的With语法）</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func Contents(filename string) (string, error) &#123;</span><br><span class=\"line\">    f, err :&#x3D; os.Open(filename)</span><br><span class=\"line\">    if err !&#x3D; nil &#123;</span><br><span class=\"line\">        return &quot;&quot;, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    defer f.Close()  &#x2F;&#x2F; f.Close will run when we&#39;re finished.</span><br><span class=\"line\"></span><br><span class=\"line\">    var result []byte</span><br><span class=\"line\">    buf :&#x3D; make([]byte, 100)</span><br><span class=\"line\">    for &#123;</span><br><span class=\"line\">        n, err :&#x3D; f.Read(buf[0:])</span><br><span class=\"line\">        result &#x3D; append(result, buf[0:n]...) &#x2F;&#x2F; append is discussed later.</span><br><span class=\"line\">        if err !&#x3D; nil &#123;</span><br><span class=\"line\">            if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class=\"line\">                break</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return &quot;&quot;, err  &#x2F;&#x2F; f will be closed if we return here.</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return string(result), nil &#x2F;&#x2F; f will be closed if we return here.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">官方对于Defer的好处声明：</span><br><span class=\"line\">1. 位置更加接近，更好的可以清晰的看出操作</span><br><span class=\"line\">2. 防止资源忘了关闭导致的泄露问题</span><br></pre></td></tr></table></div></figure>\n<p>延迟函数（如果函数是方法，则包括接收方）的参数在延迟执行时而不是在调用执行时进行评估。除了避免担心函数执行时变量会更改值外，这还意味着单个延迟的调用站点可以延迟多个函数的执行。这是一个简单的例子。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class=\"line\">    \t\tdefer fmt.Printf(&quot;%d &quot;, i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-------</span><br><span class=\"line\">output:</span><br><span class=\"line\">4 3 2 1 0 </span><br></pre></td></tr></table></div></figure>\n<p>Defer函数的执行吮吸是LIFO（LastInFirstOut)栈的结构。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">func trace(s string) string &#123;</span><br><span class=\"line\">    fmt.Println(&quot;entering:&quot;, s)</span><br><span class=\"line\">    return s</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func un(s string) &#123;</span><br><span class=\"line\">    fmt.Println(&quot;leaving:&quot;, s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func a() &#123;</span><br><span class=\"line\">    defer un(trace(&quot;a&quot;))</span><br><span class=\"line\">    fmt.Println(&quot;in a&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func b() &#123;</span><br><span class=\"line\">    defer un(trace(&quot;b&quot;))</span><br><span class=\"line\">    fmt.Println(&quot;in b&quot;)</span><br><span class=\"line\">    a()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-------------------</span><br><span class=\"line\">output</span><br><span class=\"line\">entering: b</span><br><span class=\"line\">in b</span><br><span class=\"line\">entering: a</span><br><span class=\"line\">in a</span><br><span class=\"line\">leaving: a</span><br><span class=\"line\">leaving: b</span><br></pre></td></tr></table></div></figure>\n<p>从上面的例子可以看出来，defer函数只能包含一层，如果像上面的代码 defer un(trace()), 那么会先执行trace()，然后再把un()函数压入defer的栈中。</p>\n<p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://mp.weixin.qq.com/s/_wZQID0VatIlAiH6-x3U6A\" >更加实际的使用场景相关的例子</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://golang.org/doc/effective_go.html\" >EffectiveGo</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://medium.com/golangspec/init-functions-in-go-eac191b3860a\" >GoInitFunc</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://zhuanlan.zhihu.com/p/34211611\" >GoInitFunc译文</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n"},{"title":"SQL复习","date":"2019-09-10T02:05:38.000Z","_content":"\n<!-- ---\nlayout: post\ntitle: SQL复习\nauthor: Ray Chan(ray1888)\ndate: '2019-09-10 10:05:38 +0800'\ncategory: sql\nsummary: sql-revise for interview \nthumbnail: sql.jfif\n--- -->\n\n# 目录\n1. [Join](#Join)    \n    1.1 [基本Join类型](#BasicJoin)  \n    1.2 [高级Join类型](#AdvanceJoin)\n2. [视图和子查询](#ViewNSubquery)  \n    2.1 [视图](#View)  \n    2.2 [子查询](#Subquery)  \n3. [基本语法](#Gramma)  \n    3.1 [Select](#Select)  \n    3.2 [OrderBy](#OrderBy)   \n    3.3 [Update](#Update)  \n    3.4 [Delete](#Delete)  \n4. [Having & GroupBy](#HavingNGroupBy)  \n5. [注意事项](#Notice)  \n6. [ShareNote](#ShareNote)  \n\n# 目的\n因为之前工作上面一直使用Python的ORM，然后很少使用手写SQL，因此需要回顾一些Sql的用法。\n\n# <a id=\"Join\"><span class=\"toptitle\">Join</span></a> \n## 此处所提及的表的数据和表类型\n```\nTABLE_A\n  PK Value\n---- ----------\n   1 FOX\n   2 COP\n   3 TAXI\n   6 WASHINGTON\n   7 DELL\n   5 ARIZONA\n   4 LINCOLN\n  10 LUCENT\n\nTABLE_B\n  PK Value\n---- ----------\n   1 TROT\n   2 CAR\n   3 CAB\n   6 MONUMENT\n   7 PC\n   8 MICROSOFT\n   9 APPLE\n  11 SCOTCH\n```\n\n## <a id=\"BasicJoin\"><span class=\"secondtitle\">基本Join类型</span></a>\n\n### InnerJoin\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/INNER_JOIN.png) -->\n{% asset_img INNER_JOIN.png InnerJoin %}\n\n求表A与表B数据的交集部分    \n\n```\n-- INNER JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\n       B.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nINNER JOIN Table_B B\nON A.PK = B.PK\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\n   1 FOX        TROT          1\n   2 COP        CAR           2\n   3 TAXI       CAB           3\n   6 WASHINGTON MONUMENT      6\n   7 DELL       PC            7\n\n(5 row(s) affected)\n```\n\n### LeftJoin\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/LEFT_JOIN.png) -->\n{% asset_img LEFT_JOIN.png LeftJoin %}\n\n选取表A的所有数据, 在此例子中，如果表B不存在对应查询的ID的时候，则会填入Null  \n\n```\n-- LEFT JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nLEFT JOIN Table_B B\nON A.PK = B.PK\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\n   1 FOX        TROT          1\n   2 COP        CAR           2\n   3 TAXI       CAB           3\n   4 LINCOLN    NULL       NULL\n   5 ARIZONA    NULL       NULL\n   6 WASHINGTON MONUMENT      6\n   7 DELL       PC            7\n  10 LUCENT     NULL       NULL\n\n(8 row(s) affected)\n```\n\n### RightJoin\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/RIGHT_JOIN.png) -->\n{% asset_img RIGHT_JOIN.png RightJoin %}\n\n选取表B的所有数据，在此例子中，如果表A不存在对应查询的ID的时候，则会填入Null  \n\n```\n-- RIGHT JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nRIGHT JOIN Table_B B\nON A.PK = B.PK\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\n   1 FOX        TROT          1\n   2 COP        CAR           2\n   3 TAXI       CAB           3\n   6 WASHINGTON MONUMENT      6\n   7 DELL       PC            7\nNULL NULL       MICROSOFT     8\nNULL NULL       APPLE         9\nNULL NULL       SCOTCH       11\n\n(8 row(s) affected)\n```\n\n### OuterJoin\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/FULL_OUTER_JOIN.png) -->\n{% asset_img FULL_OUTER_JOIN.png FullOuterJoin %}\n\n选取表A与表B的数据的全集,当另一张表缺失的情况下，会填补NUll信息  \n\n```\n-- OUTER JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nFULL OUTER JOIN Table_B B\nON A.PK = B.PK\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\n   1 FOX        TROT          1\n   2 COP        CAR           2\n   3 TAXI       CAB           3\n   6 WASHINGTON MONUMENT      6\n   7 DELL       PC            7\nNULL NULL       MICROSOFT     8\nNULL NULL       APPLE         9\nNULL NULL       SCOTCH       11\n   5 ARIZONA    NULL       NULL\n   4 LINCOLN    NULL       NULL\n  10 LUCENT     NULL       NULL\n\n(11 row(s) affected)\n```\n\n## <a id=\"AdvanceJoin\"><span class=\"secondtitle\">高级Join类型</span></a>\n\n### LEFT JOIN EXCLUDING INNER JOIN\n\n<!-- ![LeftJoin](/assets/img/posts/sqlJoin/LEFT_EXCLUDING_JOIN.png) -->\n{% asset_img LEFT_EXCLUDING_JOIN.png LeftExcludeJoin %}\n\n选择A与B中，A没有与B有交集的部分  \n```\n-- LEFT EXCLUDING JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nLEFT JOIN Table_B B\nON A.PK = B.PK\nWHERE B.PK IS NULL\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\n   4 LINCOLN    NULL       NULL\n   5 ARIZONA    NULL       NULL\n  10 LUCENT     NULL       NULL\n(3 row(s) affected)\n```\n\n### RIGHT JOIN EXCLUDING INNER JOIN\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/RIGHT_EXCLUDING_JOIN.png) -->\n{% asset_img RIGHT_EXCLUDING_JOIN.png RightExcludeJoin %}\n\n\n选择A与B中，B没有与A有交集的部分  \n```\n-- RIGHT EXCLUDING JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nRIGHT JOIN Table_B B\nON A.PK = B.PK\nWHERE A.PK IS NULL\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\nNULL NULL       MICROSOFT     8\nNULL NULL       APPLE         9\nNULL NULL       SCOTCH       11\n\n(3 row(s) affected)\n```\n\n### OUTER JOIN EXCLUDING INNER JOIN\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/OUTER_EXCLUDING_JOIN.png) -->\n{% asset_img OUTER_EXCLUDING_JOIN.png InnerJoin %}\n\n选择A与B中，A没有与B有交集的部分和B与A没有交集的部分  \n```\n-- OUTER EXCLUDING JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nFULL OUTER JOIN Table_B B\nON A.PK = B.PK\nWHERE A.PK IS NULL\nOR B.PK IS NULL\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\nNULL NULL       MICROSOFT     8\nNULL NULL       APPLE         9\nNULL NULL       SCOTCH       11\n   5 ARIZONA    NULL       NULL\n   4 LINCOLN    NULL       NULL\n  10 LUCENT     NULL       NULL\n\n(6 row(s) affected)\n```\n\n\n# <a id=\"ViewNSubquery\"><span class=\"toptitle\">视图与子查询</span></a>\n\n## <a id=\"View\"><span class=\"secondtitle\">视图</span></a>\n视图并不是用来保存数据的，而是通过保存读取数据的SELECT 语句的方法来为用户提供便利的工具。  \n\n究竟视图是什么呢？如果用一句话概述的话，就是“从SQL 的角度来看视图就是一张表”。实际上，在SQL 语句中并不需要区分哪些是表，哪些是视图。  \n视图和表的差别：区别只有一个，那就是“是否保存了实际的数据”。  \n但是使用视图时并不会将数据保存到存储设备之中，而且也不会将数据保存到其他任何地方。实际上视图保存的是SELECT 语句（图5-1）。我们从视图中读取数据时，视图会在内部执行该SELECT 语句并创建出一张临时表。\n\n视图是需要通过create view 的语法来创建的，本质也是满足一定条件的数据的集合。\n\n\n### 限制\n1. 视图不可以与Group By 同时使用（可能某些DB会不支持）\n\n\n## <a id=\"Subquery\"><span class=\"secondtitle\">子查询</span></a>\n\n基础定义：子查询就是一次性的视图（SELECT语句）。与视图不同，子查询在SELECT语句执行完毕之后就会消失。  \n\n```\nselect col_1 from (select col2_ from j  where $cond 1) p where $cond2\n\n其中\np为子查询，内容为select col2_ from j  where $cond 1 满足这个条件的 j 表数据创建出来的新临时表\n```\n\n### 标量子查询\n\n而标量子查询则有一个特殊的限制，那就是必须而且只能返回1 行1列的结果。也就是返回表中某一行的某一列的值。  \n由于返回的是单一的值，因此标量子查询的返回值可以用在= 或者<> 这样需要单一值的比较运算符之中。  \n\n#### 标量子查询的书写位置\n可以再任意位置： SELECT 子句、GROUP BY 子句、HAVING 子句，还是ORDERBY 子句，几乎所有的地方都可以使用。  \n\n\n# <a id=\"Gramma\"><span class=\"toptitle\">基本语法</span></a>\n\n## <a id=\"Select\"><span class=\"secondtitle\">select</span></a>\n\n基础的选择操作\n```\nselect col1, col2, col..... from table1... where $cond\n```\n\n### Select 中 引用别名列\n```\nselect * from (select sal as salary, comm as commission from emp) x where salary < 5000\n```\n上面的这种方法可以处理类似的情况：  \n1. 聚合函数(Sum()、Min()、Max())\n2. 标量子查询\n3. 窗口函数\n4. 别名\n  \n将含有别名列的查询放入内嵌视图，就可以在外层查询中引用别名列。为什么要这么做\n呢？ WHERE 子句会比SELECT 子句先执行，就最初那个失败的查询例子而言，当WHERE 子句  \n被执行时，SALARY 和COMMISSION 尚不存在。直到WHERE 子句执行完毕，那些别名列才会生  \n效。然而，FROM 子句会先于WHERE 子句执行。如果把最初的那个查询放入一个FROM 子句，  \n其查询结果会在最外层的WHERE 子句开始之前产生，这样一来，最外层的WHERE 子句就能  \n“看见”别名列了。当表里的某些列没有被恰当命名的时候，这个技巧尤其有用。  \n  \n### 使用条件逻辑\n```\nselect col1 , col2 ,\n       case when col2 <= 2000 then \"UnderPAID\"\n            when col2 > 4000 then \"OVERPAID\"\n        end as status\n    from emp \n```\n\n输出的列为[col1, status]  \n\n### 限制返回条数\n\n```\n select * from emp limit 1\n```\n\n随机返回固定条数\n```\nselect * from emp order by rand() limit 5 \n```\n\n### Null的判断\n\n```\n//  判断col1 是否为空\nselect * from emp where col1 is null\n//  判断col2 是否不为空\nselect * from emp where col2 is not null\n```\n\n### Union \n\n```\nselect deptno from emp \nunion \nselect deptno from dept \n``` \n  \n如果Union想获取到重复的条目，则应该使用union all   \n```\n// 如果使用union all 的等价实现\nselect distinct deptno from\n(select deptno from emp \nunion all \nselect deptno from dept )\n```\n\n### 对于多表Join查询  \n\n#### 合并相关的行\n目的：对一个共同的列或者具有相同值的列做连接查询，返回多个表中的行。\n```\nselect e.name, d.loc from emp e , dept d \nwhere e.deptno = 10 and e.deptno = d.deptno\n```\n\n这个解决方案是一个关于连接查询的例子。更准确地说，它是内连接中的相等连接。连接\n查询是一种把来自两个表的行合并起来的操作。对于相等连接而言，其连接条件依赖于某\n个相等条件（例如，一个表的部门编号和另一个表的部门编号相等）。内连接是最早的一\n种连接，它返回的每一行都包含了来自参与连接查询的各个表的数据。\n\n理论上，连接操作首先会依据FROM 子句里列出的表生成笛卡儿积（列出所有可能的行组\n合），如下所示。\n\n<!-- ![Union1](/assets/img/posts/sqlPost/Union-1.png) -->\n{% asset_img Union-1.png Union1 %}\nEMP 表里部门编号为10 的全部员工与DEPT 表的所有部门组合都被列出来了。然后，通过\nWHERE 子句里的e.deptno 和d.deptno 做连接操作，限定了只有EMP.DEPTNO 和DEPT.DEPTNO\n相等的行才会被返回。\n<!-- ![Union2](/assets/img/posts/sqlPost/Union-2.png) -->\n{% asset_img Union-2.png Union2 %}\n\n```\n类似实现，使用显式的Join来实现\nselect e.name, d.loc from emp e  \n   inner join  dept d on e.deptno = d.deptno\n   where e.deptno = 10 \n```\n\n如果把上面的变成小于等于10的情况,用Join的方式合并的话会变成这样\n```\nselect e.name, d.loc from emp e  \n   inner join  dept d on e.deptno = d.deptno\n   where (e.deptno = 10) or (e.deptno < 10)\n```\n\n#### 查找两个表相同的行并且连接多列\n\n需求： 获取Clerk的信息，但是需要全部的列  \n\n步骤： 1. 创建一个视图把Clerk的信息查出来  \n       2. 然后再去与emp表做Join获取完整的信息  \n```\nselect e.empno, e.name, e.job, e.sal, e.deptno from emp e, \n(select ename, job, sal from emp where job = \"CLERK\") V \nwhere V.ename = e.ename and \n      V.job = e.job and \n      V.sal = e.sal\n```\n\nJoin的处理手法  \n```\nselect e.empno, e.name, e.job, e.sal, e.deptno from emp e\njoin (select ename, job, sal from emp where job = \"CLERK\") V on (\n    V.ename = e.ename\n    V.job = e.job\n    V.sal = e.sal)\n```\n\n\n#### 查询只存在于一个表中的数据\n\n一般来说，直接使用not in 就可以了。但是对于如果含有Null的数据，就不能直接使用这样的方法处理。  \n那为什么null的数据就会出现问题呢？这个就要看一下他可能的实现方式  \n对于Mysql的实现， not in 和 in  本质上是  or的关系运算。 由于null 参与Or的逻辑运算方式不一致，In 和Not in 将产生不同的结果。  \n\n此处默认表中有一条Null的数据\n```\n// In\nselect deptno from dept where deptno in (10, 50, null)\n~~~~~~~~~~\nDeptno\n--------\n10\n\nselect deptno from dept where (deptno=10 or deptno=50 or deptno=null)\n~~~~~~~~~~\nDeptno\n--------\n10\n\n//Not in \n\nselect deptno from dept where deptno not in (10, 50, null)\n~~~~~~~~~~\nDeptno\n--------\nno rows\n\nselect deptno from dept where deptno not  (deptno=10 or deptno=50 or deptno=null)\n~~~~~~~~~~\nDeptno\n--------\nno rows\n\n```\n\n如果想要解决上面的null 所导致的问题， 需要结合Not exists 和关联子查询。 \n```\nselect d.deptno from dept d where\nnot exists (select null from emp e where d.deptno = e.deptno)\n~~~~~~~~~\nDeptno\n--------\n40\n```\n\n\n#### 确定两个表是否有相同的数据\n\n<!-- ![Union3](/assets/img/posts/sqlPost/Union-3.png) -->\n对于上面这种查询，可能会出现红色圈的数据重复的现象。那么我们要怎样才能确定是否有重复数据呢？  \n{% asset_img Union-3.png Union3 %}\n\n```\ncreate view v as \nselect * from emp where deptno != 10\nunion all \nselect * from emp where ename = \"ward\"\n\n```\n\n处理手法使用关联子查询和UNION ALL 找出那些存在于视图V 而不存在于EMP 表的数据，以及存在于EMP 表而不存在于视图V 的数据，并将它们合并起来。  \n\n```\n//  处理存在于EMP 不存于v的查询\nselect * from (\n   select e.empno, e.ename, e.job, e.mgr, e.hiredate,\n          e.sal, e.comm, e.deptno, count(*) as cnt from emp e\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) e \n) where not exists (\n   select null from (\n      select v.empno, v.ename, v.job, v.mgr, v.hiredate,\n          v.sal, v.comm, v.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) v\n      where v.empno = e.empno and \n            v.ename = e.ename and\n            v.job = e.job and\n            v.mgr = e.mgr and\n            v.hiredate = e.hiredate and\n            v.sal = e.sal and\n            v.deptno = e.deptno and\n            v.cnt = e.cnt and \n            coalesce(v.comm, 0) = coalesce(e.comm, 0)\n   )  \n)\n```\n\n```\n//  处理存在于V 不存于EMP的查询\nselect * from (\n   select v.empno, v.ename, v.job, v.mgr, v.hiredate,\n          v.sal, v.comm, v.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) v\n) where not exists (\n   select null from (\n      select e.empno, e.ename, e.job, e.mgr, e.hiredate,\n          e.sal, e.comm, e.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) e\n      where v.empno = e.empno and \n            v.ename = e.ename and\n            v.job = e.job and\n            v.mgr = e.mgr and\n            v.hiredate = e.hiredate and\n            v.sal = e.sal and\n            v.deptno = e.deptno and\n            v.cnt = e.cnt and \n            coalesce(v.comm, 0) = coalesce(e.comm, 0)\n   )  \n)\n```\n\n```\n// 总体\nselect * from (\n   select e.empno, e.ename, e.job, e.mgr, e.hiredate,\n          e.sal, e.comm, e.deptno, count(*) as cnt from emp e\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) e \n) where not exists (\n   select null from (\n      select v.empno, v.ename, v.job, v.mgr, v.hiredate,\n          v.sal, v.comm, v.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) v\n      where v.empno = e.empno and \n            v.ename = e.ename and\n            v.job = e.job and\n            v.mgr = e.mgr and\n            v.hiredate = e.hiredate and\n            v.sal = e.sal and\n            v.deptno = e.deptno and\n            v.cnt = e.cnt and \n            coalesce(v.comm, 0) = coalesce(e.comm, 0)\n   )  \n)\nUnoin all\nselect * from (\n   select v.empno, v.ename, v.job, v.mgr, v.hiredate,\n          v.sal, v.comm, v.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) v\n) where not exists (\n   select null from (\n      select e.empno, e.ename, e.job, e.mgr, e.hiredate,\n          e.sal, e.comm, e.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) e\n      where v.empno = e.empno and \n            v.ename = e.ename and\n            v.job = e.job and\n            v.mgr = e.mgr and\n            v.hiredate = e.hiredate and\n            v.sal = e.sal and\n            v.deptno = e.deptno and\n            v.cnt = e.cnt and \n            coalesce(v.comm, 0) = coalesce(e.comm, 0)\n   )  \n)\n```\n\n### <a id=\"AdvanceApp\"><span class=\"thirdtitle\">高级应用</span></a>\n#### 分页\n\n可以使用Mysql 或者PG 内置的 limit 和 offset 进行处理 \n```\nselect sal from emp order by sal limit 5 offset 0\n\nselect sal from emp order by sal limit 5 offset 5 \n```\n\n#### 间隔获取记录\n对于没有默认编号的数据，我们需要先编号再进行过滤的操作\n如果默认是已经有字段是序号的话，则采用直接Mod数据即可\n```\nselect x.name from (\n   select a.ename , (\n      select count(*) from emp b where\n      b.ename <= a.ename\n   ) as rn from emp a \n) x where mod(rn,2) = 1\n```\n\n#### 外查询使用OR逻辑\n1. 先去Join表，然后再去进行Or的逻辑判断\n```\nselect e.ename, d.deptno , d.dname, d.loc from dept d \nleft join emp e on (d.deptno = e.deptno\n                    and (e.deptno=10 or e.deptno=20))\norder by 2 \n```\n\n2. 先创建一个中间表，然后再去进行Join的操作\n\nselect e.ename, d.deptno , d.dname, d.loc from dept d\nleft join (select * from emp e where e.deptno=10 or e.deptno=20)\non d.deptno = e.deptno order by 2 \n\n\n#### 对单表需要做数据运算情况\n情况1： 找出互逆的记录（本例）  \n情况2： 查找表中某列1相差为1，并且某列2差为5的记录  \n\n总体的思路，把自己与自己(或者与自己的子集)求笛卡尔积，然后去进行条件的筛选\n\n```\nselect distinct v1.* from V v1, V v2 where\n        v1.test1 = v2.test2\n        and v1.test2 = v2.test1\n        and v1.test1 <= v1.test2\n```\n\n#### 找出最靠前的N条记录\n\n此处使用了标量子查询来创建了一张临时表的RNK的列\n```\n// \nselect ename, sal from (\n   select (\n      select (count(distinct b.sal) from emp b where \n             a.sal <= b.sal) as rnk,\n             a.sal,\n             a.ename\n   ) from emp a \n) where rnk <=5\n```\n\n\n\n## <a id=\"OrderBy\"><span class=\"secondtitle\">OrderBy</span></a>\n\n### 基础查询\n```\n// 升序查询\nselect * from emp order by col2 asc;\n// 降序查询\nselect * from emp order by col2 desc;\n```\n\n### 多字段排序\n```\nselect empno, deptno, sal, ename, job from emp order by deptno (asc), sal desc;\n```\n\n### 动态排序\n```\nselect ename, sal, job, comm from emp order by \n       case when job = \"salesman\" then comm\n            else  sal \n       end;\n```\n\n\n## <a id=\"Update\"><span class=\"secondtitle\"> update </span></a>\n\n### 基础语法\n```\nupdate table name set col_name = xxx where $cond\n```\n\n## <a id=\"Delete\"><span class=\"secondtitle\">delete</span></a>\n\n基础语法  \n```\ndelete from table_name where $cond\n```\n\n删除重复记录\n```\ndelete from table where id not in (select min(id) from table group by name)\n```\n\n# <a id=\"HavingNGroupBy\"><span class=\"toptitle\">Having & GroupBy</span></a>\n```\nwiki原文\nA HAVING clause in SQL specifies that an SQL SELECT statement should only return rows where aggregate values meet the specified conditions. It was added to the SQL language because the WHERE keyword could not be used with aggregate functions.\nThe HAVING clause filters the data on the group row but not on the individual row.\nTo view the present condition formed by the GROUP BY clause, the HAVING clause is used.\n```\n\nHaving的语句是必须要在GroupBy后面才能使用。并且与Where的区别是，Where不能直接接入聚合的函数（如Sum()、Count()、Avg()） 这种的聚合函数， 意思是不能 where sum(column_a) 这样的用法）, 并且Having可以对按Group区分的Row进行过滤的操作\n\n所以常规语法一般是\n```\nselect * from table_a A group by columa_a having count (A.column_a ) > 200\n```\n\n# <a id=\"Notice\"><span class=\"toptitle\">特殊注意</span></a>\n\n1. 类似于Sum， max， min , avg 这些也是可以直接用于select 的条件上面的\n```\nselect max(Salary) as SecondHighestSalary from employee where salary<(select max(distinct(salary)) from employee)\n```\n\n2. sql 三元运算符\nif (expr1, expr2, expr3)\n跟正常编程语言中的三元运算符一致，只是语法有变动。也是满足条件一，则返回expr2，否则返回expr3\n\n\n\n# <a id=\"ShareNote\"><span class=\"toptitle\">ShareNote</span></a>\n1. [Visual-Representation-of-SQL](https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins)\n2. [Having-Sql-Cluse-wiki](https://en.wikipedia.org/wiki/Having_(SQL))\n3. [Sql经典实例](https://book.douban.com/subject/30259463/)\n4. [Sql基础教程](https://www.ituring.com.cn/book/miniarticle/47448)","source":"_posts/sql-revise.md","raw":"---\ntitle: SQL复习\ndate: 2019-09-10 10:05:38\ntags: SQL\n---\n\n<!-- ---\nlayout: post\ntitle: SQL复习\nauthor: Ray Chan(ray1888)\ndate: '2019-09-10 10:05:38 +0800'\ncategory: sql\nsummary: sql-revise for interview \nthumbnail: sql.jfif\n--- -->\n\n# 目录\n1. [Join](#Join)    \n    1.1 [基本Join类型](#BasicJoin)  \n    1.2 [高级Join类型](#AdvanceJoin)\n2. [视图和子查询](#ViewNSubquery)  \n    2.1 [视图](#View)  \n    2.2 [子查询](#Subquery)  \n3. [基本语法](#Gramma)  \n    3.1 [Select](#Select)  \n    3.2 [OrderBy](#OrderBy)   \n    3.3 [Update](#Update)  \n    3.4 [Delete](#Delete)  \n4. [Having & GroupBy](#HavingNGroupBy)  \n5. [注意事项](#Notice)  \n6. [ShareNote](#ShareNote)  \n\n# 目的\n因为之前工作上面一直使用Python的ORM，然后很少使用手写SQL，因此需要回顾一些Sql的用法。\n\n# <a id=\"Join\"><span class=\"toptitle\">Join</span></a> \n## 此处所提及的表的数据和表类型\n```\nTABLE_A\n  PK Value\n---- ----------\n   1 FOX\n   2 COP\n   3 TAXI\n   6 WASHINGTON\n   7 DELL\n   5 ARIZONA\n   4 LINCOLN\n  10 LUCENT\n\nTABLE_B\n  PK Value\n---- ----------\n   1 TROT\n   2 CAR\n   3 CAB\n   6 MONUMENT\n   7 PC\n   8 MICROSOFT\n   9 APPLE\n  11 SCOTCH\n```\n\n## <a id=\"BasicJoin\"><span class=\"secondtitle\">基本Join类型</span></a>\n\n### InnerJoin\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/INNER_JOIN.png) -->\n{% asset_img INNER_JOIN.png InnerJoin %}\n\n求表A与表B数据的交集部分    \n\n```\n-- INNER JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\n       B.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nINNER JOIN Table_B B\nON A.PK = B.PK\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\n   1 FOX        TROT          1\n   2 COP        CAR           2\n   3 TAXI       CAB           3\n   6 WASHINGTON MONUMENT      6\n   7 DELL       PC            7\n\n(5 row(s) affected)\n```\n\n### LeftJoin\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/LEFT_JOIN.png) -->\n{% asset_img LEFT_JOIN.png LeftJoin %}\n\n选取表A的所有数据, 在此例子中，如果表B不存在对应查询的ID的时候，则会填入Null  \n\n```\n-- LEFT JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nLEFT JOIN Table_B B\nON A.PK = B.PK\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\n   1 FOX        TROT          1\n   2 COP        CAR           2\n   3 TAXI       CAB           3\n   4 LINCOLN    NULL       NULL\n   5 ARIZONA    NULL       NULL\n   6 WASHINGTON MONUMENT      6\n   7 DELL       PC            7\n  10 LUCENT     NULL       NULL\n\n(8 row(s) affected)\n```\n\n### RightJoin\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/RIGHT_JOIN.png) -->\n{% asset_img RIGHT_JOIN.png RightJoin %}\n\n选取表B的所有数据，在此例子中，如果表A不存在对应查询的ID的时候，则会填入Null  \n\n```\n-- RIGHT JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nRIGHT JOIN Table_B B\nON A.PK = B.PK\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\n   1 FOX        TROT          1\n   2 COP        CAR           2\n   3 TAXI       CAB           3\n   6 WASHINGTON MONUMENT      6\n   7 DELL       PC            7\nNULL NULL       MICROSOFT     8\nNULL NULL       APPLE         9\nNULL NULL       SCOTCH       11\n\n(8 row(s) affected)\n```\n\n### OuterJoin\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/FULL_OUTER_JOIN.png) -->\n{% asset_img FULL_OUTER_JOIN.png FullOuterJoin %}\n\n选取表A与表B的数据的全集,当另一张表缺失的情况下，会填补NUll信息  \n\n```\n-- OUTER JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nFULL OUTER JOIN Table_B B\nON A.PK = B.PK\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\n   1 FOX        TROT          1\n   2 COP        CAR           2\n   3 TAXI       CAB           3\n   6 WASHINGTON MONUMENT      6\n   7 DELL       PC            7\nNULL NULL       MICROSOFT     8\nNULL NULL       APPLE         9\nNULL NULL       SCOTCH       11\n   5 ARIZONA    NULL       NULL\n   4 LINCOLN    NULL       NULL\n  10 LUCENT     NULL       NULL\n\n(11 row(s) affected)\n```\n\n## <a id=\"AdvanceJoin\"><span class=\"secondtitle\">高级Join类型</span></a>\n\n### LEFT JOIN EXCLUDING INNER JOIN\n\n<!-- ![LeftJoin](/assets/img/posts/sqlJoin/LEFT_EXCLUDING_JOIN.png) -->\n{% asset_img LEFT_EXCLUDING_JOIN.png LeftExcludeJoin %}\n\n选择A与B中，A没有与B有交集的部分  \n```\n-- LEFT EXCLUDING JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nLEFT JOIN Table_B B\nON A.PK = B.PK\nWHERE B.PK IS NULL\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\n   4 LINCOLN    NULL       NULL\n   5 ARIZONA    NULL       NULL\n  10 LUCENT     NULL       NULL\n(3 row(s) affected)\n```\n\n### RIGHT JOIN EXCLUDING INNER JOIN\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/RIGHT_EXCLUDING_JOIN.png) -->\n{% asset_img RIGHT_EXCLUDING_JOIN.png RightExcludeJoin %}\n\n\n选择A与B中，B没有与A有交集的部分  \n```\n-- RIGHT EXCLUDING JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nRIGHT JOIN Table_B B\nON A.PK = B.PK\nWHERE A.PK IS NULL\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\nNULL NULL       MICROSOFT     8\nNULL NULL       APPLE         9\nNULL NULL       SCOTCH       11\n\n(3 row(s) affected)\n```\n\n### OUTER JOIN EXCLUDING INNER JOIN\n\n<!-- ![InnerJoin](/assets/img/posts/sqlJoin/OUTER_EXCLUDING_JOIN.png) -->\n{% asset_img OUTER_EXCLUDING_JOIN.png InnerJoin %}\n\n选择A与B中，A没有与B有交集的部分和B与A没有交集的部分  \n```\n-- OUTER EXCLUDING JOIN\nSELECT A.PK AS A_PK, A.Value AS A_Value,\nB.Value AS B_Value, B.PK AS B_PK\nFROM Table_A A\nFULL OUTER JOIN Table_B B\nON A.PK = B.PK\nWHERE A.PK IS NULL\nOR B.PK IS NULL\n\nA_PK A_Value    B_Value    B_PK\n---- ---------- ---------- ----\nNULL NULL       MICROSOFT     8\nNULL NULL       APPLE         9\nNULL NULL       SCOTCH       11\n   5 ARIZONA    NULL       NULL\n   4 LINCOLN    NULL       NULL\n  10 LUCENT     NULL       NULL\n\n(6 row(s) affected)\n```\n\n\n# <a id=\"ViewNSubquery\"><span class=\"toptitle\">视图与子查询</span></a>\n\n## <a id=\"View\"><span class=\"secondtitle\">视图</span></a>\n视图并不是用来保存数据的，而是通过保存读取数据的SELECT 语句的方法来为用户提供便利的工具。  \n\n究竟视图是什么呢？如果用一句话概述的话，就是“从SQL 的角度来看视图就是一张表”。实际上，在SQL 语句中并不需要区分哪些是表，哪些是视图。  \n视图和表的差别：区别只有一个，那就是“是否保存了实际的数据”。  \n但是使用视图时并不会将数据保存到存储设备之中，而且也不会将数据保存到其他任何地方。实际上视图保存的是SELECT 语句（图5-1）。我们从视图中读取数据时，视图会在内部执行该SELECT 语句并创建出一张临时表。\n\n视图是需要通过create view 的语法来创建的，本质也是满足一定条件的数据的集合。\n\n\n### 限制\n1. 视图不可以与Group By 同时使用（可能某些DB会不支持）\n\n\n## <a id=\"Subquery\"><span class=\"secondtitle\">子查询</span></a>\n\n基础定义：子查询就是一次性的视图（SELECT语句）。与视图不同，子查询在SELECT语句执行完毕之后就会消失。  \n\n```\nselect col_1 from (select col2_ from j  where $cond 1) p where $cond2\n\n其中\np为子查询，内容为select col2_ from j  where $cond 1 满足这个条件的 j 表数据创建出来的新临时表\n```\n\n### 标量子查询\n\n而标量子查询则有一个特殊的限制，那就是必须而且只能返回1 行1列的结果。也就是返回表中某一行的某一列的值。  \n由于返回的是单一的值，因此标量子查询的返回值可以用在= 或者<> 这样需要单一值的比较运算符之中。  \n\n#### 标量子查询的书写位置\n可以再任意位置： SELECT 子句、GROUP BY 子句、HAVING 子句，还是ORDERBY 子句，几乎所有的地方都可以使用。  \n\n\n# <a id=\"Gramma\"><span class=\"toptitle\">基本语法</span></a>\n\n## <a id=\"Select\"><span class=\"secondtitle\">select</span></a>\n\n基础的选择操作\n```\nselect col1, col2, col..... from table1... where $cond\n```\n\n### Select 中 引用别名列\n```\nselect * from (select sal as salary, comm as commission from emp) x where salary < 5000\n```\n上面的这种方法可以处理类似的情况：  \n1. 聚合函数(Sum()、Min()、Max())\n2. 标量子查询\n3. 窗口函数\n4. 别名\n  \n将含有别名列的查询放入内嵌视图，就可以在外层查询中引用别名列。为什么要这么做\n呢？ WHERE 子句会比SELECT 子句先执行，就最初那个失败的查询例子而言，当WHERE 子句  \n被执行时，SALARY 和COMMISSION 尚不存在。直到WHERE 子句执行完毕，那些别名列才会生  \n效。然而，FROM 子句会先于WHERE 子句执行。如果把最初的那个查询放入一个FROM 子句，  \n其查询结果会在最外层的WHERE 子句开始之前产生，这样一来，最外层的WHERE 子句就能  \n“看见”别名列了。当表里的某些列没有被恰当命名的时候，这个技巧尤其有用。  \n  \n### 使用条件逻辑\n```\nselect col1 , col2 ,\n       case when col2 <= 2000 then \"UnderPAID\"\n            when col2 > 4000 then \"OVERPAID\"\n        end as status\n    from emp \n```\n\n输出的列为[col1, status]  \n\n### 限制返回条数\n\n```\n select * from emp limit 1\n```\n\n随机返回固定条数\n```\nselect * from emp order by rand() limit 5 \n```\n\n### Null的判断\n\n```\n//  判断col1 是否为空\nselect * from emp where col1 is null\n//  判断col2 是否不为空\nselect * from emp where col2 is not null\n```\n\n### Union \n\n```\nselect deptno from emp \nunion \nselect deptno from dept \n``` \n  \n如果Union想获取到重复的条目，则应该使用union all   \n```\n// 如果使用union all 的等价实现\nselect distinct deptno from\n(select deptno from emp \nunion all \nselect deptno from dept )\n```\n\n### 对于多表Join查询  \n\n#### 合并相关的行\n目的：对一个共同的列或者具有相同值的列做连接查询，返回多个表中的行。\n```\nselect e.name, d.loc from emp e , dept d \nwhere e.deptno = 10 and e.deptno = d.deptno\n```\n\n这个解决方案是一个关于连接查询的例子。更准确地说，它是内连接中的相等连接。连接\n查询是一种把来自两个表的行合并起来的操作。对于相等连接而言，其连接条件依赖于某\n个相等条件（例如，一个表的部门编号和另一个表的部门编号相等）。内连接是最早的一\n种连接，它返回的每一行都包含了来自参与连接查询的各个表的数据。\n\n理论上，连接操作首先会依据FROM 子句里列出的表生成笛卡儿积（列出所有可能的行组\n合），如下所示。\n\n<!-- ![Union1](/assets/img/posts/sqlPost/Union-1.png) -->\n{% asset_img Union-1.png Union1 %}\nEMP 表里部门编号为10 的全部员工与DEPT 表的所有部门组合都被列出来了。然后，通过\nWHERE 子句里的e.deptno 和d.deptno 做连接操作，限定了只有EMP.DEPTNO 和DEPT.DEPTNO\n相等的行才会被返回。\n<!-- ![Union2](/assets/img/posts/sqlPost/Union-2.png) -->\n{% asset_img Union-2.png Union2 %}\n\n```\n类似实现，使用显式的Join来实现\nselect e.name, d.loc from emp e  \n   inner join  dept d on e.deptno = d.deptno\n   where e.deptno = 10 \n```\n\n如果把上面的变成小于等于10的情况,用Join的方式合并的话会变成这样\n```\nselect e.name, d.loc from emp e  \n   inner join  dept d on e.deptno = d.deptno\n   where (e.deptno = 10) or (e.deptno < 10)\n```\n\n#### 查找两个表相同的行并且连接多列\n\n需求： 获取Clerk的信息，但是需要全部的列  \n\n步骤： 1. 创建一个视图把Clerk的信息查出来  \n       2. 然后再去与emp表做Join获取完整的信息  \n```\nselect e.empno, e.name, e.job, e.sal, e.deptno from emp e, \n(select ename, job, sal from emp where job = \"CLERK\") V \nwhere V.ename = e.ename and \n      V.job = e.job and \n      V.sal = e.sal\n```\n\nJoin的处理手法  \n```\nselect e.empno, e.name, e.job, e.sal, e.deptno from emp e\njoin (select ename, job, sal from emp where job = \"CLERK\") V on (\n    V.ename = e.ename\n    V.job = e.job\n    V.sal = e.sal)\n```\n\n\n#### 查询只存在于一个表中的数据\n\n一般来说，直接使用not in 就可以了。但是对于如果含有Null的数据，就不能直接使用这样的方法处理。  \n那为什么null的数据就会出现问题呢？这个就要看一下他可能的实现方式  \n对于Mysql的实现， not in 和 in  本质上是  or的关系运算。 由于null 参与Or的逻辑运算方式不一致，In 和Not in 将产生不同的结果。  \n\n此处默认表中有一条Null的数据\n```\n// In\nselect deptno from dept where deptno in (10, 50, null)\n~~~~~~~~~~\nDeptno\n--------\n10\n\nselect deptno from dept where (deptno=10 or deptno=50 or deptno=null)\n~~~~~~~~~~\nDeptno\n--------\n10\n\n//Not in \n\nselect deptno from dept where deptno not in (10, 50, null)\n~~~~~~~~~~\nDeptno\n--------\nno rows\n\nselect deptno from dept where deptno not  (deptno=10 or deptno=50 or deptno=null)\n~~~~~~~~~~\nDeptno\n--------\nno rows\n\n```\n\n如果想要解决上面的null 所导致的问题， 需要结合Not exists 和关联子查询。 \n```\nselect d.deptno from dept d where\nnot exists (select null from emp e where d.deptno = e.deptno)\n~~~~~~~~~\nDeptno\n--------\n40\n```\n\n\n#### 确定两个表是否有相同的数据\n\n<!-- ![Union3](/assets/img/posts/sqlPost/Union-3.png) -->\n对于上面这种查询，可能会出现红色圈的数据重复的现象。那么我们要怎样才能确定是否有重复数据呢？  \n{% asset_img Union-3.png Union3 %}\n\n```\ncreate view v as \nselect * from emp where deptno != 10\nunion all \nselect * from emp where ename = \"ward\"\n\n```\n\n处理手法使用关联子查询和UNION ALL 找出那些存在于视图V 而不存在于EMP 表的数据，以及存在于EMP 表而不存在于视图V 的数据，并将它们合并起来。  \n\n```\n//  处理存在于EMP 不存于v的查询\nselect * from (\n   select e.empno, e.ename, e.job, e.mgr, e.hiredate,\n          e.sal, e.comm, e.deptno, count(*) as cnt from emp e\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) e \n) where not exists (\n   select null from (\n      select v.empno, v.ename, v.job, v.mgr, v.hiredate,\n          v.sal, v.comm, v.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) v\n      where v.empno = e.empno and \n            v.ename = e.ename and\n            v.job = e.job and\n            v.mgr = e.mgr and\n            v.hiredate = e.hiredate and\n            v.sal = e.sal and\n            v.deptno = e.deptno and\n            v.cnt = e.cnt and \n            coalesce(v.comm, 0) = coalesce(e.comm, 0)\n   )  \n)\n```\n\n```\n//  处理存在于V 不存于EMP的查询\nselect * from (\n   select v.empno, v.ename, v.job, v.mgr, v.hiredate,\n          v.sal, v.comm, v.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) v\n) where not exists (\n   select null from (\n      select e.empno, e.ename, e.job, e.mgr, e.hiredate,\n          e.sal, e.comm, e.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) e\n      where v.empno = e.empno and \n            v.ename = e.ename and\n            v.job = e.job and\n            v.mgr = e.mgr and\n            v.hiredate = e.hiredate and\n            v.sal = e.sal and\n            v.deptno = e.deptno and\n            v.cnt = e.cnt and \n            coalesce(v.comm, 0) = coalesce(e.comm, 0)\n   )  \n)\n```\n\n```\n// 总体\nselect * from (\n   select e.empno, e.ename, e.job, e.mgr, e.hiredate,\n          e.sal, e.comm, e.deptno, count(*) as cnt from emp e\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) e \n) where not exists (\n   select null from (\n      select v.empno, v.ename, v.job, v.mgr, v.hiredate,\n          v.sal, v.comm, v.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) v\n      where v.empno = e.empno and \n            v.ename = e.ename and\n            v.job = e.job and\n            v.mgr = e.mgr and\n            v.hiredate = e.hiredate and\n            v.sal = e.sal and\n            v.deptno = e.deptno and\n            v.cnt = e.cnt and \n            coalesce(v.comm, 0) = coalesce(e.comm, 0)\n   )  \n)\nUnoin all\nselect * from (\n   select v.empno, v.ename, v.job, v.mgr, v.hiredate,\n          v.sal, v.comm, v.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) v\n) where not exists (\n   select null from (\n      select e.empno, e.ename, e.job, e.mgr, e.hiredate,\n          e.sal, e.comm, e.deptno, count(*) as cnt from v\n          group by empno, ename, job, mgr, hiredate,\n                   sal, comm, deptno) e\n      where v.empno = e.empno and \n            v.ename = e.ename and\n            v.job = e.job and\n            v.mgr = e.mgr and\n            v.hiredate = e.hiredate and\n            v.sal = e.sal and\n            v.deptno = e.deptno and\n            v.cnt = e.cnt and \n            coalesce(v.comm, 0) = coalesce(e.comm, 0)\n   )  \n)\n```\n\n### <a id=\"AdvanceApp\"><span class=\"thirdtitle\">高级应用</span></a>\n#### 分页\n\n可以使用Mysql 或者PG 内置的 limit 和 offset 进行处理 \n```\nselect sal from emp order by sal limit 5 offset 0\n\nselect sal from emp order by sal limit 5 offset 5 \n```\n\n#### 间隔获取记录\n对于没有默认编号的数据，我们需要先编号再进行过滤的操作\n如果默认是已经有字段是序号的话，则采用直接Mod数据即可\n```\nselect x.name from (\n   select a.ename , (\n      select count(*) from emp b where\n      b.ename <= a.ename\n   ) as rn from emp a \n) x where mod(rn,2) = 1\n```\n\n#### 外查询使用OR逻辑\n1. 先去Join表，然后再去进行Or的逻辑判断\n```\nselect e.ename, d.deptno , d.dname, d.loc from dept d \nleft join emp e on (d.deptno = e.deptno\n                    and (e.deptno=10 or e.deptno=20))\norder by 2 \n```\n\n2. 先创建一个中间表，然后再去进行Join的操作\n\nselect e.ename, d.deptno , d.dname, d.loc from dept d\nleft join (select * from emp e where e.deptno=10 or e.deptno=20)\non d.deptno = e.deptno order by 2 \n\n\n#### 对单表需要做数据运算情况\n情况1： 找出互逆的记录（本例）  \n情况2： 查找表中某列1相差为1，并且某列2差为5的记录  \n\n总体的思路，把自己与自己(或者与自己的子集)求笛卡尔积，然后去进行条件的筛选\n\n```\nselect distinct v1.* from V v1, V v2 where\n        v1.test1 = v2.test2\n        and v1.test2 = v2.test1\n        and v1.test1 <= v1.test2\n```\n\n#### 找出最靠前的N条记录\n\n此处使用了标量子查询来创建了一张临时表的RNK的列\n```\n// \nselect ename, sal from (\n   select (\n      select (count(distinct b.sal) from emp b where \n             a.sal <= b.sal) as rnk,\n             a.sal,\n             a.ename\n   ) from emp a \n) where rnk <=5\n```\n\n\n\n## <a id=\"OrderBy\"><span class=\"secondtitle\">OrderBy</span></a>\n\n### 基础查询\n```\n// 升序查询\nselect * from emp order by col2 asc;\n// 降序查询\nselect * from emp order by col2 desc;\n```\n\n### 多字段排序\n```\nselect empno, deptno, sal, ename, job from emp order by deptno (asc), sal desc;\n```\n\n### 动态排序\n```\nselect ename, sal, job, comm from emp order by \n       case when job = \"salesman\" then comm\n            else  sal \n       end;\n```\n\n\n## <a id=\"Update\"><span class=\"secondtitle\"> update </span></a>\n\n### 基础语法\n```\nupdate table name set col_name = xxx where $cond\n```\n\n## <a id=\"Delete\"><span class=\"secondtitle\">delete</span></a>\n\n基础语法  \n```\ndelete from table_name where $cond\n```\n\n删除重复记录\n```\ndelete from table where id not in (select min(id) from table group by name)\n```\n\n# <a id=\"HavingNGroupBy\"><span class=\"toptitle\">Having & GroupBy</span></a>\n```\nwiki原文\nA HAVING clause in SQL specifies that an SQL SELECT statement should only return rows where aggregate values meet the specified conditions. It was added to the SQL language because the WHERE keyword could not be used with aggregate functions.\nThe HAVING clause filters the data on the group row but not on the individual row.\nTo view the present condition formed by the GROUP BY clause, the HAVING clause is used.\n```\n\nHaving的语句是必须要在GroupBy后面才能使用。并且与Where的区别是，Where不能直接接入聚合的函数（如Sum()、Count()、Avg()） 这种的聚合函数， 意思是不能 where sum(column_a) 这样的用法）, 并且Having可以对按Group区分的Row进行过滤的操作\n\n所以常规语法一般是\n```\nselect * from table_a A group by columa_a having count (A.column_a ) > 200\n```\n\n# <a id=\"Notice\"><span class=\"toptitle\">特殊注意</span></a>\n\n1. 类似于Sum， max， min , avg 这些也是可以直接用于select 的条件上面的\n```\nselect max(Salary) as SecondHighestSalary from employee where salary<(select max(distinct(salary)) from employee)\n```\n\n2. sql 三元运算符\nif (expr1, expr2, expr3)\n跟正常编程语言中的三元运算符一致，只是语法有变动。也是满足条件一，则返回expr2，否则返回expr3\n\n\n\n# <a id=\"ShareNote\"><span class=\"toptitle\">ShareNote</span></a>\n1. [Visual-Representation-of-SQL](https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins)\n2. [Having-Sql-Cluse-wiki](https://en.wikipedia.org/wiki/Having_(SQL))\n3. [Sql经典实例](https://book.douban.com/subject/30259463/)\n4. [Sql基础教程](https://www.ituring.com.cn/book/miniarticle/47448)","slug":"sql-revise","published":1,"updated":"2021-01-21T07:01:46.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6iras3000nk9i5dse38iw3","content":"<!-- ---\nlayout: post\ntitle: SQL复习\nauthor: Ray Chan(ray1888)\ndate: '2019-09-10 10:05:38 +0800'\ncategory: sql\nsummary: sql-revise for interview \nthumbnail: sql.jfif\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#Join\">Join</a><br> 1.1 <a href=\"#BasicJoin\">基本Join类型</a><br> 1.2 <a href=\"#AdvanceJoin\">高级Join类型</a></li>\n<li><a href=\"#ViewNSubquery\">视图和子查询</a><br> 2.1 <a href=\"#View\">视图</a><br> 2.2 <a href=\"#Subquery\">子查询</a>  </li>\n<li><a href=\"#Gramma\">基本语法</a><br> 3.1 <a href=\"#Select\">Select</a><br> 3.2 <a href=\"#OrderBy\">OrderBy</a><br> 3.3 <a href=\"#Update\">Update</a><br> 3.4 <a href=\"#Delete\">Delete</a>  </li>\n<li><a href=\"#HavingNGroupBy\">Having &amp; GroupBy</a>  </li>\n<li><a href=\"#Notice\">注意事项</a>  </li>\n<li><a href=\"#ShareNote\">ShareNote</a>  </li>\n</ol>\n\n        <h1 id=\"目的\"   >\n          <a href=\"#目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目的</h1>\n      <p>因为之前工作上面一直使用Python的ORM，然后很少使用手写SQL，因此需要回顾一些Sql的用法。</p>\n\n        <h1 id=\"Join\"   >\n          <a href=\"#Join\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Join</h1>\n      \n        <h2 id=\"此处所提及的表的数据和表类型\"   >\n          <a href=\"#此处所提及的表的数据和表类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>此处所提及的表的数据和表类型</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TABLE_A</span><br><span class=\"line\">  PK Value</span><br><span class=\"line\">---- ----------</span><br><span class=\"line\">   1 FOX</span><br><span class=\"line\">   2 COP</span><br><span class=\"line\">   3 TAXI</span><br><span class=\"line\">   6 WASHINGTON</span><br><span class=\"line\">   7 DELL</span><br><span class=\"line\">   5 ARIZONA</span><br><span class=\"line\">   4 LINCOLN</span><br><span class=\"line\">  10 LUCENT</span><br><span class=\"line\"></span><br><span class=\"line\">TABLE_B</span><br><span class=\"line\">  PK Value</span><br><span class=\"line\">---- ----------</span><br><span class=\"line\">   1 TROT</span><br><span class=\"line\">   2 CAR</span><br><span class=\"line\">   3 CAB</span><br><span class=\"line\">   6 MONUMENT</span><br><span class=\"line\">   7 PC</span><br><span class=\"line\">   8 MICROSOFT</span><br><span class=\"line\">   9 APPLE</span><br><span class=\"line\">  11 SCOTCH</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"基本Join类型\"   >\n          <a href=\"#基本Join类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基本Join类型</h2>\n      \n        <h3 id=\"InnerJoin\"   >\n          <a href=\"#InnerJoin\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>InnerJoin</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/INNER_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/INNER_JOIN.png\" class=\"\" title=\"InnerJoin\">\n\n<p>求表A与表B数据的交集部分    </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- INNER JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">       B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">INNER JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">   1 FOX        TROT          1</span><br><span class=\"line\">   2 COP        CAR           2</span><br><span class=\"line\">   3 TAXI       CAB           3</span><br><span class=\"line\">   6 WASHINGTON MONUMENT      6</span><br><span class=\"line\">   7 DELL       PC            7</span><br><span class=\"line\"></span><br><span class=\"line\">(5 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"LeftJoin\"   >\n          <a href=\"#LeftJoin\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>LeftJoin</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/LEFT_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/LEFT_JOIN.png\" class=\"\" title=\"LeftJoin\">\n\n<p>选取表A的所有数据, 在此例子中，如果表B不存在对应查询的ID的时候，则会填入Null  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- LEFT JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">LEFT JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">   1 FOX        TROT          1</span><br><span class=\"line\">   2 COP        CAR           2</span><br><span class=\"line\">   3 TAXI       CAB           3</span><br><span class=\"line\">   4 LINCOLN    NULL       NULL</span><br><span class=\"line\">   5 ARIZONA    NULL       NULL</span><br><span class=\"line\">   6 WASHINGTON MONUMENT      6</span><br><span class=\"line\">   7 DELL       PC            7</span><br><span class=\"line\">  10 LUCENT     NULL       NULL</span><br><span class=\"line\"></span><br><span class=\"line\">(8 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"RightJoin\"   >\n          <a href=\"#RightJoin\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>RightJoin</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/RIGHT_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/RIGHT_JOIN.png\" class=\"\" title=\"RightJoin\">\n\n<p>选取表B的所有数据，在此例子中，如果表A不存在对应查询的ID的时候，则会填入Null  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- RIGHT JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">RIGHT JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">   1 FOX        TROT          1</span><br><span class=\"line\">   2 COP        CAR           2</span><br><span class=\"line\">   3 TAXI       CAB           3</span><br><span class=\"line\">   6 WASHINGTON MONUMENT      6</span><br><span class=\"line\">   7 DELL       PC            7</span><br><span class=\"line\">NULL NULL       MICROSOFT     8</span><br><span class=\"line\">NULL NULL       APPLE         9</span><br><span class=\"line\">NULL NULL       SCOTCH       11</span><br><span class=\"line\"></span><br><span class=\"line\">(8 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"OuterJoin\"   >\n          <a href=\"#OuterJoin\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>OuterJoin</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/FULL_OUTER_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/FULL_OUTER_JOIN.png\" class=\"\" title=\"FullOuterJoin\">\n\n<p>选取表A与表B的数据的全集,当另一张表缺失的情况下，会填补NUll信息  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- OUTER JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">FULL OUTER JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">   1 FOX        TROT          1</span><br><span class=\"line\">   2 COP        CAR           2</span><br><span class=\"line\">   3 TAXI       CAB           3</span><br><span class=\"line\">   6 WASHINGTON MONUMENT      6</span><br><span class=\"line\">   7 DELL       PC            7</span><br><span class=\"line\">NULL NULL       MICROSOFT     8</span><br><span class=\"line\">NULL NULL       APPLE         9</span><br><span class=\"line\">NULL NULL       SCOTCH       11</span><br><span class=\"line\">   5 ARIZONA    NULL       NULL</span><br><span class=\"line\">   4 LINCOLN    NULL       NULL</span><br><span class=\"line\">  10 LUCENT     NULL       NULL</span><br><span class=\"line\"></span><br><span class=\"line\">(11 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"高级Join类型\"   >\n          <a href=\"#高级Join类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>高级Join类型</h2>\n      \n        <h3 id=\"LEFT-JOIN-EXCLUDING-INNER-JOIN\"   >\n          <a href=\"#LEFT-JOIN-EXCLUDING-INNER-JOIN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>LEFT JOIN EXCLUDING INNER JOIN</h3>\n      <!-- ![LeftJoin](/assets/img/posts/sqlJoin/LEFT_EXCLUDING_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/LEFT_EXCLUDING_JOIN.png\" class=\"\" title=\"LeftExcludeJoin\">\n\n<p>选择A与B中，A没有与B有交集的部分  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- LEFT EXCLUDING JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">LEFT JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\">WHERE B.PK IS NULL</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">   4 LINCOLN    NULL       NULL</span><br><span class=\"line\">   5 ARIZONA    NULL       NULL</span><br><span class=\"line\">  10 LUCENT     NULL       NULL</span><br><span class=\"line\">(3 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"RIGHT-JOIN-EXCLUDING-INNER-JOIN\"   >\n          <a href=\"#RIGHT-JOIN-EXCLUDING-INNER-JOIN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>RIGHT JOIN EXCLUDING INNER JOIN</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/RIGHT_EXCLUDING_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/RIGHT_EXCLUDING_JOIN.png\" class=\"\" title=\"RightExcludeJoin\">\n\n\n<p>选择A与B中，B没有与A有交集的部分  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- RIGHT EXCLUDING JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">RIGHT JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\">WHERE A.PK IS NULL</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">NULL NULL       MICROSOFT     8</span><br><span class=\"line\">NULL NULL       APPLE         9</span><br><span class=\"line\">NULL NULL       SCOTCH       11</span><br><span class=\"line\"></span><br><span class=\"line\">(3 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"OUTER-JOIN-EXCLUDING-INNER-JOIN\"   >\n          <a href=\"#OUTER-JOIN-EXCLUDING-INNER-JOIN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>OUTER JOIN EXCLUDING INNER JOIN</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/OUTER_EXCLUDING_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/OUTER_EXCLUDING_JOIN.png\" class=\"\" title=\"InnerJoin\">\n\n<p>选择A与B中，A没有与B有交集的部分和B与A没有交集的部分  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- OUTER EXCLUDING JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">FULL OUTER JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\">WHERE A.PK IS NULL</span><br><span class=\"line\">OR B.PK IS NULL</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">NULL NULL       MICROSOFT     8</span><br><span class=\"line\">NULL NULL       APPLE         9</span><br><span class=\"line\">NULL NULL       SCOTCH       11</span><br><span class=\"line\">   5 ARIZONA    NULL       NULL</span><br><span class=\"line\">   4 LINCOLN    NULL       NULL</span><br><span class=\"line\">  10 LUCENT     NULL       NULL</span><br><span class=\"line\"></span><br><span class=\"line\">(6 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"视图与子查询\"   >\n          <a href=\"#视图与子查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>视图与子查询</h1>\n      \n        <h2 id=\"视图\"   >\n          <a href=\"#视图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>视图</h2>\n      <p>视图并不是用来保存数据的，而是通过保存读取数据的SELECT 语句的方法来为用户提供便利的工具。  </p>\n<p>究竟视图是什么呢？如果用一句话概述的话，就是“从SQL 的角度来看视图就是一张表”。实际上，在SQL 语句中并不需要区分哪些是表，哪些是视图。<br>视图和表的差别：区别只有一个，那就是“是否保存了实际的数据”。<br>但是使用视图时并不会将数据保存到存储设备之中，而且也不会将数据保存到其他任何地方。实际上视图保存的是SELECT 语句（图5-1）。我们从视图中读取数据时，视图会在内部执行该SELECT 语句并创建出一张临时表。</p>\n<p>视图是需要通过create view 的语法来创建的，本质也是满足一定条件的数据的集合。</p>\n\n        <h3 id=\"限制\"   >\n          <a href=\"#限制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>限制</h3>\n      <ol>\n<li>视图不可以与Group By 同时使用（可能某些DB会不支持）</li>\n</ol>\n\n        <h2 id=\"子查询\"   >\n          <a href=\"#子查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>子查询</h2>\n      <p>基础定义：子查询就是一次性的视图（SELECT语句）。与视图不同，子查询在SELECT语句执行完毕之后就会消失。  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select col_1 from (select col2_ from j  where $cond 1) p where $cond2</span><br><span class=\"line\"></span><br><span class=\"line\">其中</span><br><span class=\"line\">p为子查询，内容为select col2_ from j  where $cond 1 满足这个条件的 j 表数据创建出来的新临时表</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"标量子查询\"   >\n          <a href=\"#标量子查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>标量子查询</h3>\n      <p>而标量子查询则有一个特殊的限制，那就是必须而且只能返回1 行1列的结果。也就是返回表中某一行的某一列的值。<br>由于返回的是单一的值，因此标量子查询的返回值可以用在= 或者&lt;&gt; 这样需要单一值的比较运算符之中。  </p>\n\n        <h4 id=\"标量子查询的书写位置\"   >\n          <a href=\"#标量子查询的书写位置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>标量子查询的书写位置</h4>\n      <p>可以再任意位置： SELECT 子句、GROUP BY 子句、HAVING 子句，还是ORDERBY 子句，几乎所有的地方都可以使用。  </p>\n\n        <h1 id=\"基本语法\"   >\n          <a href=\"#基本语法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基本语法</h1>\n      \n        <h2 id=\"select\"   >\n          <a href=\"#select\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>select</h2>\n      <p>基础的选择操作</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select col1, col2, col..... from table1... where $cond</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"Select-中-引用别名列\"   >\n          <a href=\"#Select-中-引用别名列\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Select 中 引用别名列</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from (select sal as salary, comm as commission from emp) x where salary &lt; 5000</span><br></pre></td></tr></table></div></figure>\n<p>上面的这种方法可以处理类似的情况：  </p>\n<ol>\n<li>聚合函数(Sum()、Min()、Max())</li>\n<li>标量子查询</li>\n<li>窗口函数</li>\n<li>别名</li>\n</ol>\n<p>将含有别名列的查询放入内嵌视图，就可以在外层查询中引用别名列。为什么要这么做<br>呢？ WHERE 子句会比SELECT 子句先执行，就最初那个失败的查询例子而言，当WHERE 子句<br>被执行时，SALARY 和COMMISSION 尚不存在。直到WHERE 子句执行完毕，那些别名列才会生<br>效。然而，FROM 子句会先于WHERE 子句执行。如果把最初的那个查询放入一个FROM 子句，<br>其查询结果会在最外层的WHERE 子句开始之前产生，这样一来，最外层的WHERE 子句就能<br>“看见”别名列了。当表里的某些列没有被恰当命名的时候，这个技巧尤其有用。  </p>\n\n        <h3 id=\"使用条件逻辑\"   >\n          <a href=\"#使用条件逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用条件逻辑</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select col1 , col2 ,</span><br><span class=\"line\">       case when col2 &lt;&#x3D; 2000 then &quot;UnderPAID&quot;</span><br><span class=\"line\">            when col2 &gt; 4000 then &quot;OVERPAID&quot;</span><br><span class=\"line\">        end as status</span><br><span class=\"line\">    from emp </span><br></pre></td></tr></table></div></figure>\n<p>输出的列为[col1, status]  </p>\n\n        <h3 id=\"限制返回条数\"   >\n          <a href=\"#限制返回条数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>限制返回条数</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from emp limit 1</span><br></pre></td></tr></table></div></figure>\n<p>随机返回固定条数</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from emp order by rand() limit 5 </span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"Null的判断\"   >\n          <a href=\"#Null的判断\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Null的判断</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;  判断col1 是否为空</span><br><span class=\"line\">select * from emp where col1 is null</span><br><span class=\"line\">&#x2F;&#x2F;  判断col2 是否不为空</span><br><span class=\"line\">select * from emp where col2 is not null</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"Union\"   >\n          <a href=\"#Union\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Union</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select deptno from emp </span><br><span class=\"line\">union </span><br><span class=\"line\">select deptno from dept </span><br></pre></td></tr></table></div></figure>\n\n<p>如果Union想获取到重复的条目，则应该使用union all   </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 如果使用union all 的等价实现</span><br><span class=\"line\">select distinct deptno from</span><br><span class=\"line\">(select deptno from emp </span><br><span class=\"line\">union all </span><br><span class=\"line\">select deptno from dept )</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"对于多表Join查询\"   >\n          <a href=\"#对于多表Join查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对于多表Join查询</h3>\n      \n        <h4 id=\"合并相关的行\"   >\n          <a href=\"#合并相关的行\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>合并相关的行</h4>\n      <p>目的：对一个共同的列或者具有相同值的列做连接查询，返回多个表中的行。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.name, d.loc from emp e , dept d </span><br><span class=\"line\">where e.deptno &#x3D; 10 and e.deptno &#x3D; d.deptno</span><br></pre></td></tr></table></div></figure>\n<p>这个解决方案是一个关于连接查询的例子。更准确地说，它是内连接中的相等连接。连接<br>查询是一种把来自两个表的行合并起来的操作。对于相等连接而言，其连接条件依赖于某<br>个相等条件（例如，一个表的部门编号和另一个表的部门编号相等）。内连接是最早的一<br>种连接，它返回的每一行都包含了来自参与连接查询的各个表的数据。</p>\n<p>理论上，连接操作首先会依据FROM 子句里列出的表生成笛卡儿积（列出所有可能的行组<br>合），如下所示。</p>\n<!-- ![Union1](/assets/img/posts/sqlPost/Union-1.png) -->\n<img src=\"/2019/09/10/sql-revise/Union-1.png\" class=\"\" title=\"Union1\">\n<p>EMP 表里部门编号为10 的全部员工与DEPT 表的所有部门组合都被列出来了。然后，通过<br>WHERE 子句里的e.deptno 和d.deptno 做连接操作，限定了只有EMP.DEPTNO 和DEPT.DEPTNO<br>相等的行才会被返回。</p>\n<!-- ![Union2](/assets/img/posts/sqlPost/Union-2.png) -->\n<img src=\"/2019/09/10/sql-revise/Union-2.png\" class=\"\" title=\"Union2\">\n\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类似实现，使用显式的Join来实现</span><br><span class=\"line\">select e.name, d.loc from emp e  </span><br><span class=\"line\">   inner join  dept d on e.deptno &#x3D; d.deptno</span><br><span class=\"line\">   where e.deptno &#x3D; 10 </span><br></pre></td></tr></table></div></figure>\n<p>如果把上面的变成小于等于10的情况,用Join的方式合并的话会变成这样</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.name, d.loc from emp e  </span><br><span class=\"line\">   inner join  dept d on e.deptno &#x3D; d.deptno</span><br><span class=\"line\">   where (e.deptno &#x3D; 10) or (e.deptno &lt; 10)</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"查找两个表相同的行并且连接多列\"   >\n          <a href=\"#查找两个表相同的行并且连接多列\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>查找两个表相同的行并且连接多列</h4>\n      <p>需求： 获取Clerk的信息，但是需要全部的列  </p>\n<p>步骤： 1. 创建一个视图把Clerk的信息查出来<br>       2. 然后再去与emp表做Join获取完整的信息  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.empno, e.name, e.job, e.sal, e.deptno from emp e, </span><br><span class=\"line\">(select ename, job, sal from emp where job &#x3D; &quot;CLERK&quot;) V </span><br><span class=\"line\">where V.ename &#x3D; e.ename and </span><br><span class=\"line\">      V.job &#x3D; e.job and </span><br><span class=\"line\">      V.sal &#x3D; e.sal</span><br></pre></td></tr></table></div></figure>\n<p>Join的处理手法  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.empno, e.name, e.job, e.sal, e.deptno from emp e</span><br><span class=\"line\">join (select ename, job, sal from emp where job &#x3D; &quot;CLERK&quot;) V on (</span><br><span class=\"line\">    V.ename &#x3D; e.ename</span><br><span class=\"line\">    V.job &#x3D; e.job</span><br><span class=\"line\">    V.sal &#x3D; e.sal)</span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"查询只存在于一个表中的数据\"   >\n          <a href=\"#查询只存在于一个表中的数据\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>查询只存在于一个表中的数据</h4>\n      <p>一般来说，直接使用not in 就可以了。但是对于如果含有Null的数据，就不能直接使用这样的方法处理。<br>那为什么null的数据就会出现问题呢？这个就要看一下他可能的实现方式<br>对于Mysql的实现， not in 和 in  本质上是  or的关系运算。 由于null 参与Or的逻辑运算方式不一致，In 和Not in 将产生不同的结果。  </p>\n<p>此处默认表中有一条Null的数据</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; In</span><br><span class=\"line\">select deptno from dept where deptno in (10, 50, null)</span><br><span class=\"line\">~~~~~~~~~~</span><br><span class=\"line\">Deptno</span><br><span class=\"line\">--------</span><br><span class=\"line\">10</span><br><span class=\"line\"></span><br><span class=\"line\">select deptno from dept where (deptno&#x3D;10 or deptno&#x3D;50 or deptno&#x3D;null)</span><br><span class=\"line\">~~~~~~~~~~</span><br><span class=\"line\">Deptno</span><br><span class=\"line\">--------</span><br><span class=\"line\">10</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Not in </span><br><span class=\"line\"></span><br><span class=\"line\">select deptno from dept where deptno not in (10, 50, null)</span><br><span class=\"line\">~~~~~~~~~~</span><br><span class=\"line\">Deptno</span><br><span class=\"line\">--------</span><br><span class=\"line\">no rows</span><br><span class=\"line\"></span><br><span class=\"line\">select deptno from dept where deptno not  (deptno&#x3D;10 or deptno&#x3D;50 or deptno&#x3D;null)</span><br><span class=\"line\">~~~~~~~~~~</span><br><span class=\"line\">Deptno</span><br><span class=\"line\">--------</span><br><span class=\"line\">no rows</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>如果想要解决上面的null 所导致的问题， 需要结合Not exists 和关联子查询。 </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select d.deptno from dept d where</span><br><span class=\"line\">not exists (select null from emp e where d.deptno &#x3D; e.deptno)</span><br><span class=\"line\">~~~~~~~~~</span><br><span class=\"line\">Deptno</span><br><span class=\"line\">--------</span><br><span class=\"line\">40</span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"确定两个表是否有相同的数据\"   >\n          <a href=\"#确定两个表是否有相同的数据\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>确定两个表是否有相同的数据</h4>\n      <!-- ![Union3](/assets/img/posts/sqlPost/Union-3.png) -->\n<p>对于上面这种查询，可能会出现红色圈的数据重复的现象。那么我们要怎样才能确定是否有重复数据呢？  </p>\n<img src=\"/2019/09/10/sql-revise/Union-3.png\" class=\"\" title=\"Union3\">\n\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view v as </span><br><span class=\"line\">select * from emp where deptno !&#x3D; 10</span><br><span class=\"line\">union all </span><br><span class=\"line\">select * from emp where ename &#x3D; &quot;ward&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>处理手法使用关联子查询和UNION ALL 找出那些存在于视图V 而不存在于EMP 表的数据，以及存在于EMP 表而不存在于视图V 的数据，并将它们合并起来。  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;  处理存在于EMP 不存于v的查询</span><br><span class=\"line\">select * from (</span><br><span class=\"line\">   select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class=\"line\">          e.sal, e.comm, e.deptno, count(*) as cnt from emp e</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) e </span><br><span class=\"line\">) where not exists (</span><br><span class=\"line\">   select null from (</span><br><span class=\"line\">      select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class=\"line\">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) v</span><br><span class=\"line\">      where v.empno &#x3D; e.empno and </span><br><span class=\"line\">            v.ename &#x3D; e.ename and</span><br><span class=\"line\">            v.job &#x3D; e.job and</span><br><span class=\"line\">            v.mgr &#x3D; e.mgr and</span><br><span class=\"line\">            v.hiredate &#x3D; e.hiredate and</span><br><span class=\"line\">            v.sal &#x3D; e.sal and</span><br><span class=\"line\">            v.deptno &#x3D; e.deptno and</span><br><span class=\"line\">            v.cnt &#x3D; e.cnt and </span><br><span class=\"line\">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class=\"line\">   )  </span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;  处理存在于V 不存于EMP的查询</span><br><span class=\"line\">select * from (</span><br><span class=\"line\">   select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class=\"line\">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) v</span><br><span class=\"line\">) where not exists (</span><br><span class=\"line\">   select null from (</span><br><span class=\"line\">      select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class=\"line\">          e.sal, e.comm, e.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) e</span><br><span class=\"line\">      where v.empno &#x3D; e.empno and </span><br><span class=\"line\">            v.ename &#x3D; e.ename and</span><br><span class=\"line\">            v.job &#x3D; e.job and</span><br><span class=\"line\">            v.mgr &#x3D; e.mgr and</span><br><span class=\"line\">            v.hiredate &#x3D; e.hiredate and</span><br><span class=\"line\">            v.sal &#x3D; e.sal and</span><br><span class=\"line\">            v.deptno &#x3D; e.deptno and</span><br><span class=\"line\">            v.cnt &#x3D; e.cnt and </span><br><span class=\"line\">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class=\"line\">   )  </span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 总体</span><br><span class=\"line\">select * from (</span><br><span class=\"line\">   select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class=\"line\">          e.sal, e.comm, e.deptno, count(*) as cnt from emp e</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) e </span><br><span class=\"line\">) where not exists (</span><br><span class=\"line\">   select null from (</span><br><span class=\"line\">      select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class=\"line\">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) v</span><br><span class=\"line\">      where v.empno &#x3D; e.empno and </span><br><span class=\"line\">            v.ename &#x3D; e.ename and</span><br><span class=\"line\">            v.job &#x3D; e.job and</span><br><span class=\"line\">            v.mgr &#x3D; e.mgr and</span><br><span class=\"line\">            v.hiredate &#x3D; e.hiredate and</span><br><span class=\"line\">            v.sal &#x3D; e.sal and</span><br><span class=\"line\">            v.deptno &#x3D; e.deptno and</span><br><span class=\"line\">            v.cnt &#x3D; e.cnt and </span><br><span class=\"line\">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class=\"line\">   )  </span><br><span class=\"line\">)</span><br><span class=\"line\">Unoin all</span><br><span class=\"line\">select * from (</span><br><span class=\"line\">   select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class=\"line\">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) v</span><br><span class=\"line\">) where not exists (</span><br><span class=\"line\">   select null from (</span><br><span class=\"line\">      select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class=\"line\">          e.sal, e.comm, e.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) e</span><br><span class=\"line\">      where v.empno &#x3D; e.empno and </span><br><span class=\"line\">            v.ename &#x3D; e.ename and</span><br><span class=\"line\">            v.job &#x3D; e.job and</span><br><span class=\"line\">            v.mgr &#x3D; e.mgr and</span><br><span class=\"line\">            v.hiredate &#x3D; e.hiredate and</span><br><span class=\"line\">            v.sal &#x3D; e.sal and</span><br><span class=\"line\">            v.deptno &#x3D; e.deptno and</span><br><span class=\"line\">            v.cnt &#x3D; e.cnt and </span><br><span class=\"line\">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class=\"line\">   )  </span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"高级应用\"   >\n          <a href=\"#高级应用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>高级应用</h3>\n      \n        <h4 id=\"分页\"   >\n          <a href=\"#分页\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分页</h4>\n      <p>可以使用Mysql 或者PG 内置的 limit 和 offset 进行处理 </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select sal from emp order by sal limit 5 offset 0</span><br><span class=\"line\"></span><br><span class=\"line\">select sal from emp order by sal limit 5 offset 5 </span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"间隔获取记录\"   >\n          <a href=\"#间隔获取记录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>间隔获取记录</h4>\n      <p>对于没有默认编号的数据，我们需要先编号再进行过滤的操作<br>如果默认是已经有字段是序号的话，则采用直接Mod数据即可</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select x.name from (</span><br><span class=\"line\">   select a.ename , (</span><br><span class=\"line\">      select count(*) from emp b where</span><br><span class=\"line\">      b.ename &lt;&#x3D; a.ename</span><br><span class=\"line\">   ) as rn from emp a </span><br><span class=\"line\">) x where mod(rn,2) &#x3D; 1</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"外查询使用OR逻辑\"   >\n          <a href=\"#外查询使用OR逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>外查询使用OR逻辑</h4>\n      <ol>\n<li>先去Join表，然后再去进行Or的逻辑判断<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.ename, d.deptno , d.dname, d.loc from dept d </span><br><span class=\"line\">left join emp e on (d.deptno &#x3D; e.deptno</span><br><span class=\"line\">                    and (e.deptno&#x3D;10 or e.deptno&#x3D;20))</span><br><span class=\"line\">order by 2 </span><br></pre></td></tr></table></div></figure></li>\n<li>先创建一个中间表，然后再去进行Join的操作</li>\n</ol>\n<p>select e.ename, d.deptno , d.dname, d.loc from dept d<br>left join (select * from emp e where e.deptno=10 or e.deptno=20)<br>on d.deptno = e.deptno order by 2 </p>\n\n        <h4 id=\"对单表需要做数据运算情况\"   >\n          <a href=\"#对单表需要做数据运算情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对单表需要做数据运算情况</h4>\n      <p>情况1： 找出互逆的记录（本例）<br>情况2： 查找表中某列1相差为1，并且某列2差为5的记录  </p>\n<p>总体的思路，把自己与自己(或者与自己的子集)求笛卡尔积，然后去进行条件的筛选</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct v1.* from V v1, V v2 where</span><br><span class=\"line\">        v1.test1 &#x3D; v2.test2</span><br><span class=\"line\">        and v1.test2 &#x3D; v2.test1</span><br><span class=\"line\">        and v1.test1 &lt;&#x3D; v1.test2</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"找出最靠前的N条记录\"   >\n          <a href=\"#找出最靠前的N条记录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>找出最靠前的N条记录</h4>\n      <p>此处使用了标量子查询来创建了一张临时表的RNK的列</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; </span><br><span class=\"line\">select ename, sal from (</span><br><span class=\"line\">   select (</span><br><span class=\"line\">      select (count(distinct b.sal) from emp b where </span><br><span class=\"line\">             a.sal &lt;&#x3D; b.sal) as rnk,</span><br><span class=\"line\">             a.sal,</span><br><span class=\"line\">             a.ename</span><br><span class=\"line\">   ) from emp a </span><br><span class=\"line\">) where rnk &lt;&#x3D;5</span><br></pre></td></tr></table></div></figure>\n\n\n\n        <h2 id=\"OrderBy\"   >\n          <a href=\"#OrderBy\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>OrderBy</h2>\n      \n        <h3 id=\"基础查询\"   >\n          <a href=\"#基础查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基础查询</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 升序查询</span><br><span class=\"line\">select * from emp order by col2 asc;</span><br><span class=\"line\">&#x2F;&#x2F; 降序查询</span><br><span class=\"line\">select * from emp order by col2 desc;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"多字段排序\"   >\n          <a href=\"#多字段排序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>多字段排序</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select empno, deptno, sal, ename, job from emp order by deptno (asc), sal desc;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"动态排序\"   >\n          <a href=\"#动态排序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>动态排序</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ename, sal, job, comm from emp order by </span><br><span class=\"line\">       case when job &#x3D; &quot;salesman&quot; then comm</span><br><span class=\"line\">            else  sal </span><br><span class=\"line\">       end;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"update\"   >\n          <a href=\"#update\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>update</h2>\n      \n        <h3 id=\"基础语法\"   >\n          <a href=\"#基础语法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基础语法</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update table name set col_name &#x3D; xxx where $cond</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"delete\"   >\n          <a href=\"#delete\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>delete</h2>\n      <p>基础语法  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete from table_name where $cond</span><br></pre></td></tr></table></div></figure>\n<p>删除重复记录</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete from table where id not in (select min(id) from table group by name)</span><br></pre></td></tr></table></div></figure>\n\n        <h1 id=\"Having-amp-GroupBy\"   >\n          <a href=\"#Having-amp-GroupBy\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Having &amp; GroupBy</h1>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wiki原文</span><br><span class=\"line\">A HAVING clause in SQL specifies that an SQL SELECT statement should only return rows where aggregate values meet the specified conditions. It was added to the SQL language because the WHERE keyword could not be used with aggregate functions.</span><br><span class=\"line\">The HAVING clause filters the data on the group row but not on the individual row.</span><br><span class=\"line\">To view the present condition formed by the GROUP BY clause, the HAVING clause is used.</span><br></pre></td></tr></table></div></figure>\n<p>Having的语句是必须要在GroupBy后面才能使用。并且与Where的区别是，Where不能直接接入聚合的函数（如Sum()、Count()、Avg()） 这种的聚合函数， 意思是不能 where sum(column_a) 这样的用法）, 并且Having可以对按Group区分的Row进行过滤的操作</p>\n<p>所以常规语法一般是</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from table_a A group by columa_a having count (A.column_a ) &gt; 200</span><br></pre></td></tr></table></div></figure>\n\n        <h1 id=\"特殊注意\"   >\n          <a href=\"#特殊注意\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>特殊注意</h1>\n      <ol>\n<li>类似于Sum， max， min , avg 这些也是可以直接用于select 的条件上面的<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select max(Salary) as SecondHighestSalary from employee where salary&lt;(select max(distinct(salary)) from employee)</span><br></pre></td></tr></table></div></figure></li>\n<li>sql 三元运算符<br>if (expr1, expr2, expr3)<br>跟正常编程语言中的三元运算符一致，只是语法有变动。也是满足条件一，则返回expr2，否则返回expr3</li>\n</ol>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins\" >Visual-Representation-of-SQL</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://en.wikipedia.org/wiki/Having_(SQL)\" >Having-Sql-Cluse-wiki</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://book.douban.com/subject/30259463/\" >Sql经典实例</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.ituring.com.cn/book/miniarticle/47448\" >Sql基础教程</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<!-- ---\nlayout: post\ntitle: SQL复习\nauthor: Ray Chan(ray1888)\ndate: '2019-09-10 10:05:38 +0800'\ncategory: sql\nsummary: sql-revise for interview \nthumbnail: sql.jfif\n--- -->\n\n\n        <h1 id=\"目录\"   >\n          <a href=\"#目录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目录</h1>\n      <ol>\n<li><a href=\"#Join\">Join</a><br> 1.1 <a href=\"#BasicJoin\">基本Join类型</a><br> 1.2 <a href=\"#AdvanceJoin\">高级Join类型</a></li>\n<li><a href=\"#ViewNSubquery\">视图和子查询</a><br> 2.1 <a href=\"#View\">视图</a><br> 2.2 <a href=\"#Subquery\">子查询</a>  </li>\n<li><a href=\"#Gramma\">基本语法</a><br> 3.1 <a href=\"#Select\">Select</a><br> 3.2 <a href=\"#OrderBy\">OrderBy</a><br> 3.3 <a href=\"#Update\">Update</a><br> 3.4 <a href=\"#Delete\">Delete</a>  </li>\n<li><a href=\"#HavingNGroupBy\">Having &amp; GroupBy</a>  </li>\n<li><a href=\"#Notice\">注意事项</a>  </li>\n<li><a href=\"#ShareNote\">ShareNote</a>  </li>\n</ol>\n\n        <h1 id=\"目的\"   >\n          <a href=\"#目的\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>目的</h1>\n      <p>因为之前工作上面一直使用Python的ORM，然后很少使用手写SQL，因此需要回顾一些Sql的用法。</p>\n\n        <h1 id=\"Join\"   >\n          <a href=\"#Join\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Join</h1>\n      \n        <h2 id=\"此处所提及的表的数据和表类型\"   >\n          <a href=\"#此处所提及的表的数据和表类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>此处所提及的表的数据和表类型</h2>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TABLE_A</span><br><span class=\"line\">  PK Value</span><br><span class=\"line\">---- ----------</span><br><span class=\"line\">   1 FOX</span><br><span class=\"line\">   2 COP</span><br><span class=\"line\">   3 TAXI</span><br><span class=\"line\">   6 WASHINGTON</span><br><span class=\"line\">   7 DELL</span><br><span class=\"line\">   5 ARIZONA</span><br><span class=\"line\">   4 LINCOLN</span><br><span class=\"line\">  10 LUCENT</span><br><span class=\"line\"></span><br><span class=\"line\">TABLE_B</span><br><span class=\"line\">  PK Value</span><br><span class=\"line\">---- ----------</span><br><span class=\"line\">   1 TROT</span><br><span class=\"line\">   2 CAR</span><br><span class=\"line\">   3 CAB</span><br><span class=\"line\">   6 MONUMENT</span><br><span class=\"line\">   7 PC</span><br><span class=\"line\">   8 MICROSOFT</span><br><span class=\"line\">   9 APPLE</span><br><span class=\"line\">  11 SCOTCH</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"基本Join类型\"   >\n          <a href=\"#基本Join类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基本Join类型</h2>\n      \n        <h3 id=\"InnerJoin\"   >\n          <a href=\"#InnerJoin\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>InnerJoin</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/INNER_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/INNER_JOIN.png\" class=\"\" title=\"InnerJoin\">\n\n<p>求表A与表B数据的交集部分    </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- INNER JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">       B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">INNER JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">   1 FOX        TROT          1</span><br><span class=\"line\">   2 COP        CAR           2</span><br><span class=\"line\">   3 TAXI       CAB           3</span><br><span class=\"line\">   6 WASHINGTON MONUMENT      6</span><br><span class=\"line\">   7 DELL       PC            7</span><br><span class=\"line\"></span><br><span class=\"line\">(5 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"LeftJoin\"   >\n          <a href=\"#LeftJoin\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>LeftJoin</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/LEFT_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/LEFT_JOIN.png\" class=\"\" title=\"LeftJoin\">\n\n<p>选取表A的所有数据, 在此例子中，如果表B不存在对应查询的ID的时候，则会填入Null  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- LEFT JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">LEFT JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">   1 FOX        TROT          1</span><br><span class=\"line\">   2 COP        CAR           2</span><br><span class=\"line\">   3 TAXI       CAB           3</span><br><span class=\"line\">   4 LINCOLN    NULL       NULL</span><br><span class=\"line\">   5 ARIZONA    NULL       NULL</span><br><span class=\"line\">   6 WASHINGTON MONUMENT      6</span><br><span class=\"line\">   7 DELL       PC            7</span><br><span class=\"line\">  10 LUCENT     NULL       NULL</span><br><span class=\"line\"></span><br><span class=\"line\">(8 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"RightJoin\"   >\n          <a href=\"#RightJoin\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>RightJoin</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/RIGHT_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/RIGHT_JOIN.png\" class=\"\" title=\"RightJoin\">\n\n<p>选取表B的所有数据，在此例子中，如果表A不存在对应查询的ID的时候，则会填入Null  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- RIGHT JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">RIGHT JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">   1 FOX        TROT          1</span><br><span class=\"line\">   2 COP        CAR           2</span><br><span class=\"line\">   3 TAXI       CAB           3</span><br><span class=\"line\">   6 WASHINGTON MONUMENT      6</span><br><span class=\"line\">   7 DELL       PC            7</span><br><span class=\"line\">NULL NULL       MICROSOFT     8</span><br><span class=\"line\">NULL NULL       APPLE         9</span><br><span class=\"line\">NULL NULL       SCOTCH       11</span><br><span class=\"line\"></span><br><span class=\"line\">(8 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"OuterJoin\"   >\n          <a href=\"#OuterJoin\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>OuterJoin</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/FULL_OUTER_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/FULL_OUTER_JOIN.png\" class=\"\" title=\"FullOuterJoin\">\n\n<p>选取表A与表B的数据的全集,当另一张表缺失的情况下，会填补NUll信息  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- OUTER JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">FULL OUTER JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">   1 FOX        TROT          1</span><br><span class=\"line\">   2 COP        CAR           2</span><br><span class=\"line\">   3 TAXI       CAB           3</span><br><span class=\"line\">   6 WASHINGTON MONUMENT      6</span><br><span class=\"line\">   7 DELL       PC            7</span><br><span class=\"line\">NULL NULL       MICROSOFT     8</span><br><span class=\"line\">NULL NULL       APPLE         9</span><br><span class=\"line\">NULL NULL       SCOTCH       11</span><br><span class=\"line\">   5 ARIZONA    NULL       NULL</span><br><span class=\"line\">   4 LINCOLN    NULL       NULL</span><br><span class=\"line\">  10 LUCENT     NULL       NULL</span><br><span class=\"line\"></span><br><span class=\"line\">(11 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"高级Join类型\"   >\n          <a href=\"#高级Join类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>高级Join类型</h2>\n      \n        <h3 id=\"LEFT-JOIN-EXCLUDING-INNER-JOIN\"   >\n          <a href=\"#LEFT-JOIN-EXCLUDING-INNER-JOIN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>LEFT JOIN EXCLUDING INNER JOIN</h3>\n      <!-- ![LeftJoin](/assets/img/posts/sqlJoin/LEFT_EXCLUDING_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/LEFT_EXCLUDING_JOIN.png\" class=\"\" title=\"LeftExcludeJoin\">\n\n<p>选择A与B中，A没有与B有交集的部分  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- LEFT EXCLUDING JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">LEFT JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\">WHERE B.PK IS NULL</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">   4 LINCOLN    NULL       NULL</span><br><span class=\"line\">   5 ARIZONA    NULL       NULL</span><br><span class=\"line\">  10 LUCENT     NULL       NULL</span><br><span class=\"line\">(3 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"RIGHT-JOIN-EXCLUDING-INNER-JOIN\"   >\n          <a href=\"#RIGHT-JOIN-EXCLUDING-INNER-JOIN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>RIGHT JOIN EXCLUDING INNER JOIN</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/RIGHT_EXCLUDING_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/RIGHT_EXCLUDING_JOIN.png\" class=\"\" title=\"RightExcludeJoin\">\n\n\n<p>选择A与B中，B没有与A有交集的部分  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- RIGHT EXCLUDING JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">RIGHT JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\">WHERE A.PK IS NULL</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">NULL NULL       MICROSOFT     8</span><br><span class=\"line\">NULL NULL       APPLE         9</span><br><span class=\"line\">NULL NULL       SCOTCH       11</span><br><span class=\"line\"></span><br><span class=\"line\">(3 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"OUTER-JOIN-EXCLUDING-INNER-JOIN\"   >\n          <a href=\"#OUTER-JOIN-EXCLUDING-INNER-JOIN\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>OUTER JOIN EXCLUDING INNER JOIN</h3>\n      <!-- ![InnerJoin](/assets/img/posts/sqlJoin/OUTER_EXCLUDING_JOIN.png) -->\n<img src=\"/2019/09/10/sql-revise/OUTER_EXCLUDING_JOIN.png\" class=\"\" title=\"InnerJoin\">\n\n<p>选择A与B中，A没有与B有交集的部分和B与A没有交集的部分  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- OUTER EXCLUDING JOIN</span><br><span class=\"line\">SELECT A.PK AS A_PK, A.Value AS A_Value,</span><br><span class=\"line\">B.Value AS B_Value, B.PK AS B_PK</span><br><span class=\"line\">FROM Table_A A</span><br><span class=\"line\">FULL OUTER JOIN Table_B B</span><br><span class=\"line\">ON A.PK &#x3D; B.PK</span><br><span class=\"line\">WHERE A.PK IS NULL</span><br><span class=\"line\">OR B.PK IS NULL</span><br><span class=\"line\"></span><br><span class=\"line\">A_PK A_Value    B_Value    B_PK</span><br><span class=\"line\">---- ---------- ---------- ----</span><br><span class=\"line\">NULL NULL       MICROSOFT     8</span><br><span class=\"line\">NULL NULL       APPLE         9</span><br><span class=\"line\">NULL NULL       SCOTCH       11</span><br><span class=\"line\">   5 ARIZONA    NULL       NULL</span><br><span class=\"line\">   4 LINCOLN    NULL       NULL</span><br><span class=\"line\">  10 LUCENT     NULL       NULL</span><br><span class=\"line\"></span><br><span class=\"line\">(6 row(s) affected)</span><br></pre></td></tr></table></div></figure>\n\n\n        <h1 id=\"视图与子查询\"   >\n          <a href=\"#视图与子查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>视图与子查询</h1>\n      \n        <h2 id=\"视图\"   >\n          <a href=\"#视图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>视图</h2>\n      <p>视图并不是用来保存数据的，而是通过保存读取数据的SELECT 语句的方法来为用户提供便利的工具。  </p>\n<p>究竟视图是什么呢？如果用一句话概述的话，就是“从SQL 的角度来看视图就是一张表”。实际上，在SQL 语句中并不需要区分哪些是表，哪些是视图。<br>视图和表的差别：区别只有一个，那就是“是否保存了实际的数据”。<br>但是使用视图时并不会将数据保存到存储设备之中，而且也不会将数据保存到其他任何地方。实际上视图保存的是SELECT 语句（图5-1）。我们从视图中读取数据时，视图会在内部执行该SELECT 语句并创建出一张临时表。</p>\n<p>视图是需要通过create view 的语法来创建的，本质也是满足一定条件的数据的集合。</p>\n\n        <h3 id=\"限制\"   >\n          <a href=\"#限制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>限制</h3>\n      <ol>\n<li>视图不可以与Group By 同时使用（可能某些DB会不支持）</li>\n</ol>\n\n        <h2 id=\"子查询\"   >\n          <a href=\"#子查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>子查询</h2>\n      <p>基础定义：子查询就是一次性的视图（SELECT语句）。与视图不同，子查询在SELECT语句执行完毕之后就会消失。  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select col_1 from (select col2_ from j  where $cond 1) p where $cond2</span><br><span class=\"line\"></span><br><span class=\"line\">其中</span><br><span class=\"line\">p为子查询，内容为select col2_ from j  where $cond 1 满足这个条件的 j 表数据创建出来的新临时表</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"标量子查询\"   >\n          <a href=\"#标量子查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>标量子查询</h3>\n      <p>而标量子查询则有一个特殊的限制，那就是必须而且只能返回1 行1列的结果。也就是返回表中某一行的某一列的值。<br>由于返回的是单一的值，因此标量子查询的返回值可以用在= 或者&lt;&gt; 这样需要单一值的比较运算符之中。  </p>\n\n        <h4 id=\"标量子查询的书写位置\"   >\n          <a href=\"#标量子查询的书写位置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>标量子查询的书写位置</h4>\n      <p>可以再任意位置： SELECT 子句、GROUP BY 子句、HAVING 子句，还是ORDERBY 子句，几乎所有的地方都可以使用。  </p>\n\n        <h1 id=\"基本语法\"   >\n          <a href=\"#基本语法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基本语法</h1>\n      \n        <h2 id=\"select\"   >\n          <a href=\"#select\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>select</h2>\n      <p>基础的选择操作</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select col1, col2, col..... from table1... where $cond</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"Select-中-引用别名列\"   >\n          <a href=\"#Select-中-引用别名列\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Select 中 引用别名列</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from (select sal as salary, comm as commission from emp) x where salary &lt; 5000</span><br></pre></td></tr></table></div></figure>\n<p>上面的这种方法可以处理类似的情况：  </p>\n<ol>\n<li>聚合函数(Sum()、Min()、Max())</li>\n<li>标量子查询</li>\n<li>窗口函数</li>\n<li>别名</li>\n</ol>\n<p>将含有别名列的查询放入内嵌视图，就可以在外层查询中引用别名列。为什么要这么做<br>呢？ WHERE 子句会比SELECT 子句先执行，就最初那个失败的查询例子而言，当WHERE 子句<br>被执行时，SALARY 和COMMISSION 尚不存在。直到WHERE 子句执行完毕，那些别名列才会生<br>效。然而，FROM 子句会先于WHERE 子句执行。如果把最初的那个查询放入一个FROM 子句，<br>其查询结果会在最外层的WHERE 子句开始之前产生，这样一来，最外层的WHERE 子句就能<br>“看见”别名列了。当表里的某些列没有被恰当命名的时候，这个技巧尤其有用。  </p>\n\n        <h3 id=\"使用条件逻辑\"   >\n          <a href=\"#使用条件逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用条件逻辑</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select col1 , col2 ,</span><br><span class=\"line\">       case when col2 &lt;&#x3D; 2000 then &quot;UnderPAID&quot;</span><br><span class=\"line\">            when col2 &gt; 4000 then &quot;OVERPAID&quot;</span><br><span class=\"line\">        end as status</span><br><span class=\"line\">    from emp </span><br></pre></td></tr></table></div></figure>\n<p>输出的列为[col1, status]  </p>\n\n        <h3 id=\"限制返回条数\"   >\n          <a href=\"#限制返回条数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>限制返回条数</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from emp limit 1</span><br></pre></td></tr></table></div></figure>\n<p>随机返回固定条数</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from emp order by rand() limit 5 </span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"Null的判断\"   >\n          <a href=\"#Null的判断\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Null的判断</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;  判断col1 是否为空</span><br><span class=\"line\">select * from emp where col1 is null</span><br><span class=\"line\">&#x2F;&#x2F;  判断col2 是否不为空</span><br><span class=\"line\">select * from emp where col2 is not null</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"Union\"   >\n          <a href=\"#Union\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Union</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select deptno from emp </span><br><span class=\"line\">union </span><br><span class=\"line\">select deptno from dept </span><br></pre></td></tr></table></div></figure>\n\n<p>如果Union想获取到重复的条目，则应该使用union all   </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 如果使用union all 的等价实现</span><br><span class=\"line\">select distinct deptno from</span><br><span class=\"line\">(select deptno from emp </span><br><span class=\"line\">union all </span><br><span class=\"line\">select deptno from dept )</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"对于多表Join查询\"   >\n          <a href=\"#对于多表Join查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对于多表Join查询</h3>\n      \n        <h4 id=\"合并相关的行\"   >\n          <a href=\"#合并相关的行\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>合并相关的行</h4>\n      <p>目的：对一个共同的列或者具有相同值的列做连接查询，返回多个表中的行。</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.name, d.loc from emp e , dept d </span><br><span class=\"line\">where e.deptno &#x3D; 10 and e.deptno &#x3D; d.deptno</span><br></pre></td></tr></table></div></figure>\n<p>这个解决方案是一个关于连接查询的例子。更准确地说，它是内连接中的相等连接。连接<br>查询是一种把来自两个表的行合并起来的操作。对于相等连接而言，其连接条件依赖于某<br>个相等条件（例如，一个表的部门编号和另一个表的部门编号相等）。内连接是最早的一<br>种连接，它返回的每一行都包含了来自参与连接查询的各个表的数据。</p>\n<p>理论上，连接操作首先会依据FROM 子句里列出的表生成笛卡儿积（列出所有可能的行组<br>合），如下所示。</p>\n<!-- ![Union1](/assets/img/posts/sqlPost/Union-1.png) -->\n<img src=\"/2019/09/10/sql-revise/Union-1.png\" class=\"\" title=\"Union1\">\n<p>EMP 表里部门编号为10 的全部员工与DEPT 表的所有部门组合都被列出来了。然后，通过<br>WHERE 子句里的e.deptno 和d.deptno 做连接操作，限定了只有EMP.DEPTNO 和DEPT.DEPTNO<br>相等的行才会被返回。</p>\n<!-- ![Union2](/assets/img/posts/sqlPost/Union-2.png) -->\n<img src=\"/2019/09/10/sql-revise/Union-2.png\" class=\"\" title=\"Union2\">\n\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类似实现，使用显式的Join来实现</span><br><span class=\"line\">select e.name, d.loc from emp e  </span><br><span class=\"line\">   inner join  dept d on e.deptno &#x3D; d.deptno</span><br><span class=\"line\">   where e.deptno &#x3D; 10 </span><br></pre></td></tr></table></div></figure>\n<p>如果把上面的变成小于等于10的情况,用Join的方式合并的话会变成这样</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.name, d.loc from emp e  </span><br><span class=\"line\">   inner join  dept d on e.deptno &#x3D; d.deptno</span><br><span class=\"line\">   where (e.deptno &#x3D; 10) or (e.deptno &lt; 10)</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"查找两个表相同的行并且连接多列\"   >\n          <a href=\"#查找两个表相同的行并且连接多列\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>查找两个表相同的行并且连接多列</h4>\n      <p>需求： 获取Clerk的信息，但是需要全部的列  </p>\n<p>步骤： 1. 创建一个视图把Clerk的信息查出来<br>       2. 然后再去与emp表做Join获取完整的信息  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.empno, e.name, e.job, e.sal, e.deptno from emp e, </span><br><span class=\"line\">(select ename, job, sal from emp where job &#x3D; &quot;CLERK&quot;) V </span><br><span class=\"line\">where V.ename &#x3D; e.ename and </span><br><span class=\"line\">      V.job &#x3D; e.job and </span><br><span class=\"line\">      V.sal &#x3D; e.sal</span><br></pre></td></tr></table></div></figure>\n<p>Join的处理手法  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.empno, e.name, e.job, e.sal, e.deptno from emp e</span><br><span class=\"line\">join (select ename, job, sal from emp where job &#x3D; &quot;CLERK&quot;) V on (</span><br><span class=\"line\">    V.ename &#x3D; e.ename</span><br><span class=\"line\">    V.job &#x3D; e.job</span><br><span class=\"line\">    V.sal &#x3D; e.sal)</span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"查询只存在于一个表中的数据\"   >\n          <a href=\"#查询只存在于一个表中的数据\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>查询只存在于一个表中的数据</h4>\n      <p>一般来说，直接使用not in 就可以了。但是对于如果含有Null的数据，就不能直接使用这样的方法处理。<br>那为什么null的数据就会出现问题呢？这个就要看一下他可能的实现方式<br>对于Mysql的实现， not in 和 in  本质上是  or的关系运算。 由于null 参与Or的逻辑运算方式不一致，In 和Not in 将产生不同的结果。  </p>\n<p>此处默认表中有一条Null的数据</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; In</span><br><span class=\"line\">select deptno from dept where deptno in (10, 50, null)</span><br><span class=\"line\">~~~~~~~~~~</span><br><span class=\"line\">Deptno</span><br><span class=\"line\">--------</span><br><span class=\"line\">10</span><br><span class=\"line\"></span><br><span class=\"line\">select deptno from dept where (deptno&#x3D;10 or deptno&#x3D;50 or deptno&#x3D;null)</span><br><span class=\"line\">~~~~~~~~~~</span><br><span class=\"line\">Deptno</span><br><span class=\"line\">--------</span><br><span class=\"line\">10</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Not in </span><br><span class=\"line\"></span><br><span class=\"line\">select deptno from dept where deptno not in (10, 50, null)</span><br><span class=\"line\">~~~~~~~~~~</span><br><span class=\"line\">Deptno</span><br><span class=\"line\">--------</span><br><span class=\"line\">no rows</span><br><span class=\"line\"></span><br><span class=\"line\">select deptno from dept where deptno not  (deptno&#x3D;10 or deptno&#x3D;50 or deptno&#x3D;null)</span><br><span class=\"line\">~~~~~~~~~~</span><br><span class=\"line\">Deptno</span><br><span class=\"line\">--------</span><br><span class=\"line\">no rows</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>如果想要解决上面的null 所导致的问题， 需要结合Not exists 和关联子查询。 </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select d.deptno from dept d where</span><br><span class=\"line\">not exists (select null from emp e where d.deptno &#x3D; e.deptno)</span><br><span class=\"line\">~~~~~~~~~</span><br><span class=\"line\">Deptno</span><br><span class=\"line\">--------</span><br><span class=\"line\">40</span><br></pre></td></tr></table></div></figure>\n\n\n        <h4 id=\"确定两个表是否有相同的数据\"   >\n          <a href=\"#确定两个表是否有相同的数据\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>确定两个表是否有相同的数据</h4>\n      <!-- ![Union3](/assets/img/posts/sqlPost/Union-3.png) -->\n<p>对于上面这种查询，可能会出现红色圈的数据重复的现象。那么我们要怎样才能确定是否有重复数据呢？  </p>\n<img src=\"/2019/09/10/sql-revise/Union-3.png\" class=\"\" title=\"Union3\">\n\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view v as </span><br><span class=\"line\">select * from emp where deptno !&#x3D; 10</span><br><span class=\"line\">union all </span><br><span class=\"line\">select * from emp where ename &#x3D; &quot;ward&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>处理手法使用关联子查询和UNION ALL 找出那些存在于视图V 而不存在于EMP 表的数据，以及存在于EMP 表而不存在于视图V 的数据，并将它们合并起来。  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;  处理存在于EMP 不存于v的查询</span><br><span class=\"line\">select * from (</span><br><span class=\"line\">   select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class=\"line\">          e.sal, e.comm, e.deptno, count(*) as cnt from emp e</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) e </span><br><span class=\"line\">) where not exists (</span><br><span class=\"line\">   select null from (</span><br><span class=\"line\">      select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class=\"line\">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) v</span><br><span class=\"line\">      where v.empno &#x3D; e.empno and </span><br><span class=\"line\">            v.ename &#x3D; e.ename and</span><br><span class=\"line\">            v.job &#x3D; e.job and</span><br><span class=\"line\">            v.mgr &#x3D; e.mgr and</span><br><span class=\"line\">            v.hiredate &#x3D; e.hiredate and</span><br><span class=\"line\">            v.sal &#x3D; e.sal and</span><br><span class=\"line\">            v.deptno &#x3D; e.deptno and</span><br><span class=\"line\">            v.cnt &#x3D; e.cnt and </span><br><span class=\"line\">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class=\"line\">   )  </span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;  处理存在于V 不存于EMP的查询</span><br><span class=\"line\">select * from (</span><br><span class=\"line\">   select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class=\"line\">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) v</span><br><span class=\"line\">) where not exists (</span><br><span class=\"line\">   select null from (</span><br><span class=\"line\">      select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class=\"line\">          e.sal, e.comm, e.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) e</span><br><span class=\"line\">      where v.empno &#x3D; e.empno and </span><br><span class=\"line\">            v.ename &#x3D; e.ename and</span><br><span class=\"line\">            v.job &#x3D; e.job and</span><br><span class=\"line\">            v.mgr &#x3D; e.mgr and</span><br><span class=\"line\">            v.hiredate &#x3D; e.hiredate and</span><br><span class=\"line\">            v.sal &#x3D; e.sal and</span><br><span class=\"line\">            v.deptno &#x3D; e.deptno and</span><br><span class=\"line\">            v.cnt &#x3D; e.cnt and </span><br><span class=\"line\">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class=\"line\">   )  </span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 总体</span><br><span class=\"line\">select * from (</span><br><span class=\"line\">   select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class=\"line\">          e.sal, e.comm, e.deptno, count(*) as cnt from emp e</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) e </span><br><span class=\"line\">) where not exists (</span><br><span class=\"line\">   select null from (</span><br><span class=\"line\">      select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class=\"line\">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) v</span><br><span class=\"line\">      where v.empno &#x3D; e.empno and </span><br><span class=\"line\">            v.ename &#x3D; e.ename and</span><br><span class=\"line\">            v.job &#x3D; e.job and</span><br><span class=\"line\">            v.mgr &#x3D; e.mgr and</span><br><span class=\"line\">            v.hiredate &#x3D; e.hiredate and</span><br><span class=\"line\">            v.sal &#x3D; e.sal and</span><br><span class=\"line\">            v.deptno &#x3D; e.deptno and</span><br><span class=\"line\">            v.cnt &#x3D; e.cnt and </span><br><span class=\"line\">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class=\"line\">   )  </span><br><span class=\"line\">)</span><br><span class=\"line\">Unoin all</span><br><span class=\"line\">select * from (</span><br><span class=\"line\">   select v.empno, v.ename, v.job, v.mgr, v.hiredate,</span><br><span class=\"line\">          v.sal, v.comm, v.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) v</span><br><span class=\"line\">) where not exists (</span><br><span class=\"line\">   select null from (</span><br><span class=\"line\">      select e.empno, e.ename, e.job, e.mgr, e.hiredate,</span><br><span class=\"line\">          e.sal, e.comm, e.deptno, count(*) as cnt from v</span><br><span class=\"line\">          group by empno, ename, job, mgr, hiredate,</span><br><span class=\"line\">                   sal, comm, deptno) e</span><br><span class=\"line\">      where v.empno &#x3D; e.empno and </span><br><span class=\"line\">            v.ename &#x3D; e.ename and</span><br><span class=\"line\">            v.job &#x3D; e.job and</span><br><span class=\"line\">            v.mgr &#x3D; e.mgr and</span><br><span class=\"line\">            v.hiredate &#x3D; e.hiredate and</span><br><span class=\"line\">            v.sal &#x3D; e.sal and</span><br><span class=\"line\">            v.deptno &#x3D; e.deptno and</span><br><span class=\"line\">            v.cnt &#x3D; e.cnt and </span><br><span class=\"line\">            coalesce(v.comm, 0) &#x3D; coalesce(e.comm, 0)</span><br><span class=\"line\">   )  </span><br><span class=\"line\">)</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"高级应用\"   >\n          <a href=\"#高级应用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>高级应用</h3>\n      \n        <h4 id=\"分页\"   >\n          <a href=\"#分页\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分页</h4>\n      <p>可以使用Mysql 或者PG 内置的 limit 和 offset 进行处理 </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select sal from emp order by sal limit 5 offset 0</span><br><span class=\"line\"></span><br><span class=\"line\">select sal from emp order by sal limit 5 offset 5 </span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"间隔获取记录\"   >\n          <a href=\"#间隔获取记录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>间隔获取记录</h4>\n      <p>对于没有默认编号的数据，我们需要先编号再进行过滤的操作<br>如果默认是已经有字段是序号的话，则采用直接Mod数据即可</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select x.name from (</span><br><span class=\"line\">   select a.ename , (</span><br><span class=\"line\">      select count(*) from emp b where</span><br><span class=\"line\">      b.ename &lt;&#x3D; a.ename</span><br><span class=\"line\">   ) as rn from emp a </span><br><span class=\"line\">) x where mod(rn,2) &#x3D; 1</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"外查询使用OR逻辑\"   >\n          <a href=\"#外查询使用OR逻辑\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>外查询使用OR逻辑</h4>\n      <ol>\n<li>先去Join表，然后再去进行Or的逻辑判断<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.ename, d.deptno , d.dname, d.loc from dept d </span><br><span class=\"line\">left join emp e on (d.deptno &#x3D; e.deptno</span><br><span class=\"line\">                    and (e.deptno&#x3D;10 or e.deptno&#x3D;20))</span><br><span class=\"line\">order by 2 </span><br></pre></td></tr></table></div></figure></li>\n<li>先创建一个中间表，然后再去进行Join的操作</li>\n</ol>\n<p>select e.ename, d.deptno , d.dname, d.loc from dept d<br>left join (select * from emp e where e.deptno=10 or e.deptno=20)<br>on d.deptno = e.deptno order by 2 </p>\n\n        <h4 id=\"对单表需要做数据运算情况\"   >\n          <a href=\"#对单表需要做数据运算情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>对单表需要做数据运算情况</h4>\n      <p>情况1： 找出互逆的记录（本例）<br>情况2： 查找表中某列1相差为1，并且某列2差为5的记录  </p>\n<p>总体的思路，把自己与自己(或者与自己的子集)求笛卡尔积，然后去进行条件的筛选</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct v1.* from V v1, V v2 where</span><br><span class=\"line\">        v1.test1 &#x3D; v2.test2</span><br><span class=\"line\">        and v1.test2 &#x3D; v2.test1</span><br><span class=\"line\">        and v1.test1 &lt;&#x3D; v1.test2</span><br></pre></td></tr></table></div></figure>\n\n        <h4 id=\"找出最靠前的N条记录\"   >\n          <a href=\"#找出最靠前的N条记录\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>找出最靠前的N条记录</h4>\n      <p>此处使用了标量子查询来创建了一张临时表的RNK的列</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; </span><br><span class=\"line\">select ename, sal from (</span><br><span class=\"line\">   select (</span><br><span class=\"line\">      select (count(distinct b.sal) from emp b where </span><br><span class=\"line\">             a.sal &lt;&#x3D; b.sal) as rnk,</span><br><span class=\"line\">             a.sal,</span><br><span class=\"line\">             a.ename</span><br><span class=\"line\">   ) from emp a </span><br><span class=\"line\">) where rnk &lt;&#x3D;5</span><br></pre></td></tr></table></div></figure>\n\n\n\n        <h2 id=\"OrderBy\"   >\n          <a href=\"#OrderBy\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>OrderBy</h2>\n      \n        <h3 id=\"基础查询\"   >\n          <a href=\"#基础查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基础查询</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 升序查询</span><br><span class=\"line\">select * from emp order by col2 asc;</span><br><span class=\"line\">&#x2F;&#x2F; 降序查询</span><br><span class=\"line\">select * from emp order by col2 desc;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"多字段排序\"   >\n          <a href=\"#多字段排序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>多字段排序</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select empno, deptno, sal, ename, job from emp order by deptno (asc), sal desc;</span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"动态排序\"   >\n          <a href=\"#动态排序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>动态排序</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ename, sal, job, comm from emp order by </span><br><span class=\"line\">       case when job &#x3D; &quot;salesman&quot; then comm</span><br><span class=\"line\">            else  sal </span><br><span class=\"line\">       end;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"update\"   >\n          <a href=\"#update\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>update</h2>\n      \n        <h3 id=\"基础语法\"   >\n          <a href=\"#基础语法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基础语法</h3>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update table name set col_name &#x3D; xxx where $cond</span><br></pre></td></tr></table></div></figure>\n\n        <h2 id=\"delete\"   >\n          <a href=\"#delete\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>delete</h2>\n      <p>基础语法  </p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete from table_name where $cond</span><br></pre></td></tr></table></div></figure>\n<p>删除重复记录</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete from table where id not in (select min(id) from table group by name)</span><br></pre></td></tr></table></div></figure>\n\n        <h1 id=\"Having-amp-GroupBy\"   >\n          <a href=\"#Having-amp-GroupBy\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Having &amp; GroupBy</h1>\n      <figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wiki原文</span><br><span class=\"line\">A HAVING clause in SQL specifies that an SQL SELECT statement should only return rows where aggregate values meet the specified conditions. It was added to the SQL language because the WHERE keyword could not be used with aggregate functions.</span><br><span class=\"line\">The HAVING clause filters the data on the group row but not on the individual row.</span><br><span class=\"line\">To view the present condition formed by the GROUP BY clause, the HAVING clause is used.</span><br></pre></td></tr></table></div></figure>\n<p>Having的语句是必须要在GroupBy后面才能使用。并且与Where的区别是，Where不能直接接入聚合的函数（如Sum()、Count()、Avg()） 这种的聚合函数， 意思是不能 where sum(column_a) 这样的用法）, 并且Having可以对按Group区分的Row进行过滤的操作</p>\n<p>所以常规语法一般是</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from table_a A group by columa_a having count (A.column_a ) &gt; 200</span><br></pre></td></tr></table></div></figure>\n\n        <h1 id=\"特殊注意\"   >\n          <a href=\"#特殊注意\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>特殊注意</h1>\n      <ol>\n<li>类似于Sum， max， min , avg 这些也是可以直接用于select 的条件上面的<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select max(Salary) as SecondHighestSalary from employee where salary&lt;(select max(distinct(salary)) from employee)</span><br></pre></td></tr></table></div></figure></li>\n<li>sql 三元运算符<br>if (expr1, expr2, expr3)<br>跟正常编程语言中的三元运算符一致，只是语法有变动。也是满足条件一，则返回expr2，否则返回expr3</li>\n</ol>\n\n        <h1 id=\"ShareNote\"   >\n          <a href=\"#ShareNote\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ShareNote</h1>\n      <ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins\" >Visual-Representation-of-SQL</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://en.wikipedia.org/wiki/Having_(SQL)\" >Having-Sql-Cluse-wiki</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://book.douban.com/subject/30259463/\" >Sql经典实例</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.ituring.com.cn/book/miniarticle/47448\" >Sql基础教程</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n"}],"PostAsset":[{"_id":"source/_posts/intro-distributed-system/SchdulerTimeJump.png","slug":"SchdulerTimeJump.png","post":"ckk6h2epk0004eci5cgca101l","modified":0,"renderable":0},{"_id":"source/_posts/intro-distributed-system/Time&EventMissmatch.png","slug":"Time&EventMissmatch.png","post":"ckk6h2epk0004eci5cgca101l","modified":0,"renderable":0},{"_id":"source/_posts/intro-distributed-system/TimeJump.png","slug":"TimeJump.png","post":"ckk6h2epk0004eci5cgca101l","modified":0,"renderable":0},{"_id":"source/_posts/intro-distributed-system/lockingproblem.png","slug":"lockingproblem.png","post":"ckk6h2epk0004eci5cgca101l","modified":0,"renderable":0},{"_id":"source/_posts/intro-distributed-system/lockingproblem2.png","slug":"lockingproblem2.png","post":"ckk6h2epk0004eci5cgca101l","modified":0,"renderable":0},{"_id":"source/_posts/distribute-system-consensus/LamportTimestamp.png","slug":"LamportTimestamp.png","post":"ckk6h2epk0003eci51vj6gdyl","modified":0,"renderable":0},{"_id":"source/_posts/distribute-system-consensus/generate-line.png","slug":"generate-line.png","post":"ckk6h2epk0003eci51vj6gdyl","modified":0,"renderable":0},{"_id":"source/_posts/distribute-system-consensus/line-final.png","slug":"line-final.png","post":"ckk6h2epk0003eci51vj6gdyl","modified":0,"renderable":0},{"_id":"source/_posts/distribute-system-consensus/more-detail-line.png","slug":"more-detail-line.png","post":"ckk6h2epk0003eci51vj6gdyl","modified":0,"renderable":0},{"_id":"source/_posts/distribute-system-consensus/non-linearized-example.png","slug":"non-linearized-example.png","post":"ckk6h2epk0003eci51vj6gdyl","modified":0,"renderable":0},{"_id":"source/_posts/distribute-system-consensus/quroum-fail.png","slug":"quroum-fail.png","post":"ckk6h2epk0003eci51vj6gdyl","modified":0,"renderable":0},{"_id":"source/_posts/raft-lab-2/RaftProcess.png","slug":"RaftProcess.png","post":"ckk6h2epb0000eci53tuy7iuk","modified":0,"renderable":0},{"_id":"source/_posts/raft-lab-2/RaftStateMachine.png","slug":"RaftStateMachine.png","post":"ckk6h2epb0000eci53tuy7iuk","modified":0,"renderable":0},{"_id":"source/_posts/go-slice/GoSlice.png","slug":"GoSlice.png","post":"ckk6irar50001k9i59fu05t2q","modified":0,"renderable":0},{"_id":"source/_posts/go-slice/GoSliceExtend.png","slug":"GoSliceExtend.png","post":"ckk6irar50001k9i59fu05t2q","modified":0,"renderable":0},{"_id":"source/_posts/prometheus-scrape/ScrapeModule.png","slug":"ScrapeModule.png","post":"ckk6irard0006k9i5gsd7bfrr","modified":0,"renderable":0},{"_id":"source/_posts/raft-lab-3/Lab3-Process.png","slug":"Lab3-Process.png","post":"ckk6irarf000ak9i58ywe0055","modified":0,"renderable":0},{"_id":"source/_posts/raft-lab-4/lab4.png","slug":"lab4.png","post":"ckk6irarh000dk9i5944l19ix","modified":0,"renderable":0},{"_id":"source/_posts/sql-revise/FULL_OUTER_JOIN.png","slug":"FULL_OUTER_JOIN.png","post":"ckk6iras3000nk9i5dse38iw3","modified":0,"renderable":0},{"_id":"source/_posts/sql-revise/INNER_JOIN.png","slug":"INNER_JOIN.png","post":"ckk6iras3000nk9i5dse38iw3","modified":0,"renderable":0},{"_id":"source/_posts/sql-revise/LEFT_EXCLUDING_JOIN.png","slug":"LEFT_EXCLUDING_JOIN.png","post":"ckk6iras3000nk9i5dse38iw3","modified":0,"renderable":0},{"_id":"source/_posts/sql-revise/LEFT_JOIN.png","slug":"LEFT_JOIN.png","post":"ckk6iras3000nk9i5dse38iw3","modified":0,"renderable":0},{"_id":"source/_posts/sql-revise/OUTER_EXCLUDING_JOIN.png","slug":"OUTER_EXCLUDING_JOIN.png","post":"ckk6iras3000nk9i5dse38iw3","modified":0,"renderable":0},{"_id":"source/_posts/sql-revise/RIGHT_EXCLUDING_JOIN.png","slug":"RIGHT_EXCLUDING_JOIN.png","post":"ckk6iras3000nk9i5dse38iw3","modified":0,"renderable":0},{"_id":"source/_posts/sql-revise/RIGHT_JOIN.png","slug":"RIGHT_JOIN.png","post":"ckk6iras3000nk9i5dse38iw3","modified":0,"renderable":0},{"_id":"source/_posts/sql-revise/Union-1.png","slug":"Union-1.png","post":"ckk6iras3000nk9i5dse38iw3","modified":0,"renderable":0},{"_id":"source/_posts/sql-revise/Union-2.png","slug":"Union-2.png","post":"ckk6iras3000nk9i5dse38iw3","modified":0,"renderable":0},{"_id":"source/_posts/sql-revise/Union-3.png","slug":"Union-3.png","post":"ckk6iras3000nk9i5dse38iw3","modified":0,"renderable":0},{"_id":"source/_posts/sql-revise/Visual_SQL_JOINS_orig.jpg","slug":"Visual_SQL_JOINS_orig.jpg","post":"ckk6iras3000nk9i5dse38iw3","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ckk6h2epb0000eci53tuy7iuk","tag_id":"ckk6h2epf0001eci515jx2v09","_id":"ckk6h2epg0002eci50sji7mbp"},{"post_id":"ckk6h2epk0003eci51vj6gdyl","tag_id":"ckk6h2epf0001eci515jx2v09","_id":"ckk6h2epl0005eci5av1qg3g3"},{"post_id":"ckk6h2epk0004eci5cgca101l","tag_id":"ckk6h2epf0001eci515jx2v09","_id":"ckk6h2epl0006eci5duzvch6d"},{"post_id":"ckk6irar50001k9i59fu05t2q","tag_id":"ckk6irara0004k9i502oscp0w","_id":"ckk6irarf0009k9i5ap5b3w4o"},{"post_id":"ckk6irar90003k9i55pq9f6d4","tag_id":"ckk6irara0004k9i502oscp0w","_id":"ckk6irarg000ck9i5fkjf71cr"},{"post_id":"ckk6irarf000ak9i58ywe0055","tag_id":"ckk6h2epf0001eci515jx2v09","_id":"ckk6irarh000ek9i59yx417s1"},{"post_id":"ckk6irarh000dk9i5944l19ix","tag_id":"ckk6h2epf0001eci515jx2v09","_id":"ckk6irari000gk9i51fro0xms"},{"post_id":"ckk6irarc0005k9i5b6x757te","tag_id":"ckk6irarg000bk9i52szw42nk","_id":"ckk6irari000hk9i59kb8ctlm"},{"post_id":"ckk6irard0006k9i5gsd7bfrr","tag_id":"ckk6irarh000fk9i5eax6e036","_id":"ckk6irari000jk9i5h8o97uws"},{"post_id":"ckk6irard0007k9i54bt9hz6n","tag_id":"ckk6irarh000fk9i5eax6e036","_id":"ckk6irari000kk9i5e2yv3ls7"},{"post_id":"ckk6irarw000lk9i5fhb04215","tag_id":"ckk6irara0004k9i502oscp0w","_id":"ckk6irarw000mk9i55hpcdsue"},{"post_id":"ckk6iras3000nk9i5dse38iw3","tag_id":"ckk6iras4000ok9i58ztc974n","_id":"ckk6iras4000pk9i51w4848zg"}],"Tag":[{"name":"distributed-system","_id":"ckk6h2epf0001eci515jx2v09"},{"name":"Go","_id":"ckk6irara0004k9i502oscp0w"},{"name":"distributed-system, mit6.824","_id":"ckk6irarg000bk9i52szw42nk"},{"name":"Prometheus","_id":"ckk6irarh000fk9i5eax6e036"},{"name":"SQL","_id":"ckk6iras4000ok9i58ztc974n"}]}}